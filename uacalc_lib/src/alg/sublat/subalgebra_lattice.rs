use pyo3::prelude::*;
use pyo3::exceptions::PyValueError;
use uacalc::lat::{Lattice, Order};
use crate::alg::PyBasicAlgebra;
use crate::alg::PyBasicSet;

/// Python wrapper for SubalgebraLattice
#[pyclass]
pub struct PySubalgebraLattice {
    inner: std::cell::RefCell<uacalc::alg::sublat::SubalgebraLattice<i32>>,
}

#[pymethods]
impl PySubalgebraLattice {
    /// Create a new SubalgebraLattice from a BasicAlgebra.
    ///
    /// Args:
    ///     algebra (BasicAlgebra): The algebra to compute subalgebras for
    ///
    /// Returns:
    ///     SubalgebraLattice: A new SubalgebraLattice instance
    ///
    /// Raises:
    ///     ValueError: If the algebra is invalid or initialization fails
    #[new]
    fn new(algebra: &PyBasicAlgebra) -> PyResult<Self> {
        let alg_box: Box<dyn uacalc::alg::SmallAlgebra<UniverseItem = i32>> =
            Box::new(algebra.inner.clone());

        match uacalc::alg::sublat::SubalgebraLattice::new_safe(alg_box) {
            Ok(inner) => Ok(PySubalgebraLattice {
                inner: std::cell::RefCell::new(inner)
            }),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }

    /// Get the underlying algebra.
    ///
    /// Returns:
    ///     str: String representation of the algebra
    fn get_algebra(&self) -> String {
        let inner = self.inner.borrow();
        format!("Algebra: size={}", inner.get_algebra().cardinality())
    }

    /// Get the description of this subalgebra lattice.
    ///
    /// Returns:
    ///     str: The description
    fn get_description(&self) -> String {
        self.inner.borrow().get_description().to_string()
    }

    /// Set the description of this subalgebra lattice.
    ///
    /// Args:
    ///     description (str): The new description
    fn set_description(&mut self, description: String) {
        self.inner.borrow_mut().set_description(description);
    }

    /// Check if the lattice can be drawn (small enough).
    ///
    /// Returns:
    ///     bool: True if the lattice is small enough to draw
    fn is_drawable(&self) -> bool {
        self.inner.borrow().is_drawable()
    }

    /// Check if the lattice size is smaller than a given size.
    ///
    /// Args:
    ///     size (int): The size to compare against
    ///
    /// Returns:
    ///     bool: True if the lattice is smaller than the given size
    fn is_smaller_than(&self, size: i32) -> bool {
        self.inner.borrow().is_smaller_than(size.try_into().unwrap())
    }

    /// Check if the universe has been computed.
    ///
    /// Returns:
    ///     bool: True if the universe has been computed
    fn universe_found(&self) -> bool {
        self.inner.borrow().universe_found()
    }

    /// Generate the subalgebra generated by the given elements.
    ///
    /// Args:
    ///     generators (List[int]): List of generator elements
    ///
    /// Returns:
    ///     BasicSet: The subalgebra generated by the given elements
    fn sg(&self, generators: Vec<i32>) -> PyBasicSet {
        let inner = self.inner.borrow();
        let result = inner.sg(&generators);
        PyBasicSet::from_inner(result)
    }

    /// Get the one-generated subalgebras.
    ///
    /// Returns:
    ///     List[BasicSet]: List of one-generated subalgebras
    fn one_generated_subalgebras(&self) -> Vec<PyBasicSet> {
        let mut inner = self.inner.borrow_mut();
        let one_gens = inner.one_generated_subalgebras();
        one_gens.iter().map(|bs| PyBasicSet::from_inner(bs.clone())).collect()
    }

    /// Get the join irreducibles.
    ///
    /// Returns:
    ///     List[BasicSet]: List of join irreducible subalgebras
    fn join_irreducibles(&self) -> Vec<PyBasicSet> {
        let mut inner = self.inner.borrow_mut();
        let jis = inner.join_irreducibles_mut();
        jis.iter().map(|bs| PyBasicSet::from_inner(bs.clone())).collect()
    }

    /// Get the meet irreducibles (stub implementation).
    ///
    /// Returns:
    ///     List[BasicSet]: List of meet irreducible subalgebras (currently empty)
    fn meet_irreducibles(&self) -> Vec<PyBasicSet> {
        let mut inner = self.inner.borrow_mut();
        let mis = inner.meet_irreducibles_mut();
        mis.iter().map(|bs| PyBasicSet::from_inner(bs.clone())).collect()
    }

    /// Get the join irreducibles as an OrderedSet.
    ///
    /// Returns:
    ///     OrderedSetBasicSet: An OrderedSet containing the join irreducible elements with their order relations
    fn join_irreducibles_po(&self) -> PyResult<crate::lat::PyOrderedSetBasicSet> {
        let mut inner = self.inner.borrow_mut();
        match inner.join_irreducibles_po() {
            Ok(ordered_set) => Ok(crate::lat::PyOrderedSetBasicSet {
                inner: std::sync::Arc::new(std::sync::Mutex::new(ordered_set)),
            }),
            Err(e) => Err(pyo3::exceptions::PyRuntimeError::new_err(format!("Failed to create OrderedSet: {}", e))),
        }
    }

    /// Get the meet irreducibles as an OrderedSet.
    ///
    /// Returns:
    ///     OrderedSetBasicSet: An OrderedSet containing the meet irreducible elements with their order relations
    fn meet_irreducibles_po(&self) -> PyResult<crate::lat::PyOrderedSetBasicSet> {
        let mut inner = self.inner.borrow_mut();
        match inner.meet_irreducibles_po() {
            Ok(ordered_set) => Ok(crate::lat::PyOrderedSetBasicSet {
                inner: std::sync::Arc::new(std::sync::Mutex::new(ordered_set)),
            }),
            Err(e) => Err(pyo3::exceptions::PyRuntimeError::new_err(format!("Failed to create OrderedSet: {}", e))),
        }
    }

    /// Compute the join of two subalgebras.
    ///
    /// Args:
    ///     a (BasicSet): First subalgebra
    ///     b (BasicSet): Second subalgebra
    ///
    /// Returns:
    ///     BasicSet: The join (smallest subalgebra containing both)
    fn join(&self, a: &PyBasicSet, b: &PyBasicSet) -> PyBasicSet {
        let inner = self.inner.borrow();
        let result = inner.join_sets(a.get_inner(), b.get_inner());
        PyBasicSet::from_inner(result)
    }

    /// Compute the meet of two subalgebras.
    ///
    /// Args:
    ///     a (BasicSet): First subalgebra
    ///     b (BasicSet): Second subalgebra
    ///
    /// Returns:
    ///     BasicSet: The meet (intersection)
    fn meet(&self, a: &PyBasicSet, b: &PyBasicSet) -> PyBasicSet {
        let inner = self.inner.borrow();
        let result = Lattice::meet(&*inner, a.get_inner(), b.get_inner());
        PyBasicSet::from_inner(result)
    }

    /// Check if one subalgebra is less than or equal to another (subset).
    ///
    /// Args:
    ///     a (BasicSet): First subalgebra
    ///     b (BasicSet): Second subalgebra
    ///
    /// Returns:
    ///     bool: True if a âŠ† b
    fn leq(&self, a: &PyBasicSet, b: &PyBasicSet) -> bool {
        let inner = self.inner.borrow();
        Order::leq(&*inner, a.get_inner(), b.get_inner())
    }

    /// Get the universe of all subalgebras.
    ///
    /// Returns:
    ///     List[BasicSet]: List of all subalgebras
    fn universe(&self) -> Vec<PyBasicSet> {
        let mut inner = self.inner.borrow_mut();
        let univ = inner.universe_mut();
        univ.iter().map(|bs| PyBasicSet::from_inner(bs.clone())).collect()
    }

    /// Get the cardinality (number of subalgebras).
    ///
    /// Returns:
    ///     int: Number of subalgebras in the lattice
    fn cardinality(&self) -> i32 {
        let mut inner = self.inner.borrow_mut();
        inner.universe_mut().len() as i32
    }

    /// Filter subalgebras that are greater than or equal to the given element.
    ///
    /// Args:
    ///     element (BasicSet): The element to filter by
    ///
    /// Returns:
    ///     List[BasicSet]: Subalgebras containing the given element
    fn filter(&self, element: &PyBasicSet) -> Vec<PyBasicSet> {
        let mut inner = self.inner.borrow_mut();
        let filtered = inner.filter(element.get_inner());
        filtered.iter().map(|bs| PyBasicSet::from_inner(bs.clone())).collect()
    }

    /// Find a minimal sized generating set for the algebra.
    ///
    /// Returns:
    ///     BasicSet: A minimal generating set
    fn find_minimal_sized_generating_set(&self) -> PyBasicSet {
        let mut inner = self.inner.borrow_mut();
        let gen_set = inner.find_minimal_sized_generating_set();
        PyBasicSet::from_inner(gen_set)
    }

    /// Get the zero subalgebra (generated by constants).
    ///
    /// Returns:
    ///     BasicSet: The zero subalgebra
    fn zero(&self) -> PyBasicSet {
        let inner = self.inner.borrow();
        PyBasicSet::from_inner(inner.zero().clone())
    }

    /// Get the one subalgebra (entire algebra).
    ///
    /// Returns:
    ///     BasicSet: The one subalgebra (whole algebra)
    fn one(&self) -> PyBasicSet {
        let inner = self.inner.borrow();
        PyBasicSet::from_inner(inner.one().clone())
    }

    /// Remove duplicate elements from a list (static method).
    ///
    /// Args:
    ///     lst (List[int]): List with potential duplicates
    ///
    /// Returns:
    ///     List[int]: List with duplicates removed
    #[staticmethod]
    fn no_duplicates(lst: Vec<i32>) -> Vec<i32> {
        uacalc::alg::sublat::SubalgebraLattice::<i32>::no_duplicates(lst)
    }

    /// Python string representation
    fn __str__(&self) -> String {
        let inner = self.inner.borrow();
        format!("SubalgebraLattice(algebra_size={})", inner.get_algebra().cardinality())
    }

    /// Python repr representation
    fn __repr__(&self) -> String {
        self.__str__()
    }

    /// Get the BasicLattice view of this subalgebra lattice.
    ///
    /// Args:
    ///     make_if_null (bool, optional): Create the BasicLattice if it doesn't exist. Defaults to True.
    ///
    /// Returns:
    ///     BasicLattice: The BasicLattice view, or None if creation fails
    fn get_basic_lattice(&mut self, make_if_null: Option<bool>) -> PyResult<Option<crate::lat::PyBasicLattice>> {
        use uacalc::lat::Lattice;
        use crate::lat::PyBasicLattice;
        use crate::lat::BasicLatticeInner;
        let make = make_if_null.unwrap_or(true);
        
        // Get the inner SubalgebraLattice (mutable borrow to compute universe)
        let mut inner = self.inner.borrow_mut();
        
        // Ensure universe is computed
        let _ = inner.universe_mut();
        
        // Create BasicLattice from the lattice using new_from_lattice
        // SubalgebraLattice implements Lattice<BasicSet>
        // We need to use a reference that outlives the borrow, so we'll create the lattice
        // while still holding the borrow, then release it
        let result = uacalc::lat::BasicLattice::new_from_lattice(
            "SubalgebraLattice".to_string(),
            &*inner as &dyn Lattice<uacalc::alg::sublat::BasicSet>,
        );
        
        // Release the borrow before creating the PyBasicLattice
        drop(inner);
        
        match result {
            Ok(basic_lat) => {
                Ok(Some(PyBasicLattice {
                    inner: BasicLatticeInner::BasicSet(std::sync::Arc::new(std::sync::Mutex::new(basic_lat))),
                }))
            }
            Err(e) => {
                if make {
                    Err(pyo3::exceptions::PyRuntimeError::new_err(format!("Failed to create BasicLattice: {}", e)))
                } else {
                    Ok(None)
                }
            }
        }
    }

    /// Get the BasicLattice view (default: create if null).
    ///
    /// Returns:
    ///     BasicLattice: The BasicLattice view, or None if creation fails
    fn get_basic_lattice_default(&mut self) -> PyResult<Option<crate::lat::PyBasicLattice>> {
        self.get_basic_lattice(Some(true))
    }
}

impl PySubalgebraLattice {
    pub(crate) fn from_inner(inner: uacalc::alg::sublat::SubalgebraLattice<i32>) -> Self {
        PySubalgebraLattice { inner: std::cell::RefCell::new(inner) }
    }
}