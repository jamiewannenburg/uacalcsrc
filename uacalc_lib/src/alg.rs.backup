use pyo3::prelude::*;
use pyo3::exceptions::PyValueError;
use pyo3::types::PyList;
use std::collections::{HashMap, HashSet};
use uacalc::alg::*;
use uacalc::alg::conlat::{BinaryRelation, MutableBinaryRelation};
use uacalc::util::IntArrayTrait;
use uacalc::alg::conlat::BasicBinaryRelation;
use uacalc::alg::conlat::subtrace::Subtrace;
use uacalc::alg::op::{Operation, BasicOperation, AbstractIntOperation, IntOperation};
use uacalc::alg::sublat::BasicSet;
use uacalc::lat::{Lattice, Order};
use crate::util::PyIntArray;
use crate::eq::PyEquation;

pub mod conlat;
pub mod op;

use self::conlat::basic_binary_relation::PyBasicBinaryRelation;
use self::conlat::centrality_data::PyCentralityData;
use self::conlat::polymorphisms::PyPolymorphisms;
use self::conlat::subtrace::PySubtrace;
use self::conlat::type_finder::PyTypeFinder;
use self::op::abstract_int_operation::PyAbstractIntOperation;
use self::op::abstract_operation::PyAbstractOperationNew;
use self::op::int_operation::PyIntOperation;
use self::op::operation::PyBasicOperation;
use self::op::operation_symbol::PyOperationSymbol;
use self::op::similarity_type::PySimilarityType;


/// Python wrapper for PrintType
#[pyclass]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct PyPrintType {
    inner: uacalc::alg::conlat::partition::PrintType,
}

#[pymethods]
impl PyPrintType {
    /// Create a new PrintType from string.
    #[new]
    fn new(print_type: &str) -> PyResult<Self> {
        let inner = match print_type.to_lowercase().as_str() {
            "internal" => uacalc::alg::conlat::partition::PrintType::Internal,
            "ewk" => uacalc::alg::conlat::partition::PrintType::Ewk,
            "block" => uacalc::alg::conlat::partition::PrintType::Block,
            "human" => uacalc::alg::conlat::partition::PrintType::Human,
            "sq_brace_block" => uacalc::alg::conlat::partition::PrintType::SqBraceBlock,
            _ => return Err(PyValueError::new_err(format!("Invalid print type: {}", print_type))),
        };
        Ok(PyPrintType { inner })
    }
    
    /// Get the string representation of this print type.
    fn to_string(&self) -> String {
        match self.inner {
            uacalc::alg::conlat::partition::PrintType::Internal => "internal".to_string(),
            uacalc::alg::conlat::partition::PrintType::Ewk => "ewk".to_string(),
            uacalc::alg::conlat::partition::PrintType::Block => "block".to_string(),
            uacalc::alg::conlat::partition::PrintType::Human => "human".to_string(),
            uacalc::alg::conlat::partition::PrintType::SqBraceBlock => "sq_brace_block".to_string(),
        }
    }
    
    /// Python string representation.
    fn __str__(&self) -> String {
        self.to_string()
    }
    
    /// Python repr representation.
    fn __repr__(&self) -> String {
        format!("PrintType('{}')", self.to_string())
    }
    
    /// Python equality comparison.
    fn __eq__(&self, other: &PyPrintType) -> bool {
        self.inner == other.inner
    }
    
    /// Python hash function.
    fn __hash__(&self) -> u64 {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        
        let mut hasher = DefaultHasher::new();
        self.inner.hash(&mut hasher);
        hasher.finish()
    }
}

/// Python wrapper for Partition
#[pyclass]
pub struct PyPartition {
    inner: uacalc::alg::conlat::partition::Partition,
}

#[pymethods]
impl PyPartition {
    /// Create a new Partition from an array representation.
    /// 
    /// Args:
    ///     array (List[int]): The array representation of the partition
    /// 
    /// Returns:
    ///     Partition: A new Partition instance
    /// 
    /// Raises:
    ///     ValueError: If the array is invalid
    #[new]
    fn new(array: Vec<i32>) -> PyResult<Self> {
        match uacalc::alg::conlat::partition::Partition::new(array) {
            Ok(inner) => Ok(PyPartition { inner }),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Create a new Partition from a string representation.
    /// 
    /// Args:
    ///     str (str): String representation of the partition
    /// 
    /// Returns:
    ///     Partition: A new Partition instance
    /// 
    /// Raises:
    ///     ValueError: If the string format is invalid
    #[staticmethod]
    fn from_string(str: &str) -> PyResult<Self> {
        match uacalc::alg::conlat::partition::Partition::from_string(str) {
            Ok(inner) => Ok(PyPartition { inner }),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Create a new Partition from a string representation with specified length.
    /// 
    /// Args:
    ///     str (str): String representation of the partition
    ///     length (int): Maximum universe size (-1 for auto-detect)
    /// 
    /// Returns:
    ///     Partition: A new Partition instance
    /// 
    /// Raises:
    ///     ValueError: If the string format is invalid
    #[staticmethod]
    fn from_string_with_length(str: &str, length: i32) -> PyResult<Self> {
        match uacalc::alg::conlat::partition::Partition::from_string_with_length(str, length) {
            Ok(inner) => Ok(PyPartition { inner }),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Create the zero partition (all elements in separate blocks).
    /// 
    /// Args:
    ///     size (int): Size of the universe
    /// 
    /// Returns:
    ///     Partition: Zero partition
    #[staticmethod]
    fn zero(size: usize) -> Self {
        PyPartition {
            inner: uacalc::alg::conlat::partition::Partition::zero(size),
        }
    }
    
    /// Create the one partition (all elements in one block).
    /// 
    /// Args:
    ///     size (int): Size of the universe
    /// 
    /// Returns:
    ///     Partition: One partition
    #[staticmethod]
    fn one(size: usize) -> Self {
        PyPartition {
            inner: uacalc::alg::conlat::partition::Partition::one(size),
        }
    }
    
    /// Get the universe size (number of elements).
    /// 
    /// Returns:
    ///     int: The universe size
    fn universe_size(&self) -> usize {
        self.inner.universe_size()
    }
    
    /// Get the number of blocks in the partition.
    /// 
    /// Returns:
    ///     int: The number of blocks
    fn number_of_blocks(&self) -> usize {
        self.inner.number_of_blocks()
    }
    
    /// Check if two elements are related (in the same block).
    /// 
    /// Args:
    ///     i (int): First element
    ///     j (int): Second element
    /// 
    /// Returns:
    ///     bool: True if elements are in the same block
    fn is_related(&self, i: usize, j: usize) -> bool {
        self.inner.is_related(i, j)
    }
    
    /// Get the representative (root) of the block containing element i.
    /// 
    /// Args:
    ///     i (int): Element index
    /// 
    /// Returns:
    ///     int: Representative element index
    fn representative(&self, i: usize) -> usize {
        self.inner.representative(i)
    }
    
    /// Check if an element is a representative (root) of its block.
    /// 
    /// Args:
    ///     i (int): Element index
    /// 
    /// Returns:
    ///     bool: True if element is a representative
    fn is_representative(&self, i: usize) -> bool {
        self.inner.is_representative(i)
    }
    
    /// Get all representatives of the partition.
    /// 
    /// Returns:
    ///     List[int]: List of representative indices
    fn representatives(&self) -> Vec<usize> {
        self.inner.representatives()
    }
    
    /// Get the index of the block containing element i.
    /// 
    /// Args:
    ///     i (int): Element index
    /// 
    /// Returns:
    ///     int: Block index
    /// 
    /// Raises:
    ///     ValueError: If element not found in representatives
    fn block_index(&self, i: usize) -> PyResult<usize> {
        match self.inner.block_index(i) {
            Ok(idx) => Ok(idx),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Get the blocks of the partition as an array of arrays.
    /// 
    /// Returns:
    ///     List[List[int]]: List of blocks, where each block is a list of element indices
    fn get_blocks(&self) -> Vec<Vec<usize>> {
        self.inner.get_blocks()
    }
    
    /// Join two blocks by their representatives.
    /// 
    /// Args:
    ///     r (int): Representative of first block
    ///     s (int): Representative of second block
    /// 
    /// Raises:
    ///     ValueError: If r or s are not representatives or if r == s
    fn join_blocks(&mut self, r: usize, s: usize) -> PyResult<()> {
        if r == s {
            return Err(PyValueError::new_err("Cannot join a block with itself"));
        }
        if !self.inner.is_representative(r) || !self.inner.is_representative(s) {
            return Err(PyValueError::new_err("Both arguments must be representatives"));
        }
        
        self.inner.join_blocks(r, s);
        Ok(())
    }
    
    /// Compute the join of two partitions.
    /// 
    /// Args:
    ///     other (Partition): Other partition to join with
    /// 
    /// Returns:
    ///     Partition: Join of the two partitions
    /// 
    /// Raises:
    ///     ValueError: If partitions have different universe sizes
    fn join(&self, other: &PyPartition) -> PyResult<PyPartition> {
        match self.inner.join(&other.inner) {
            Ok(inner) => Ok(PyPartition { inner }),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Compute the meet of two partitions.
    /// 
    /// Args:
    ///     other (Partition): Other partition to meet with
    /// 
    /// Returns:
    ///     Partition: Meet of the two partitions
    /// 
    /// Raises:
    ///     ValueError: If partitions have different universe sizes
    fn meet(&self, other: &PyPartition) -> PyResult<PyPartition> {
        match self.inner.meet(&other.inner) {
            Ok(inner) => Ok(PyPartition { inner }),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Check if this partition is less than or equal to another partition.
    /// 
    /// Args:
    ///     other (Partition): Other partition to compare with
    /// 
    /// Returns:
    ///     bool: True if this partition refines the other
    fn leq(&self, other: &PyPartition) -> bool {
        self.inner.leq(&other.inner)
    }
    
    /// Normalize the partition representation.
    fn normalize(&mut self) {
        self.inner.normalize();
    }
    
    /// Check if this is the zero partition (all elements in separate blocks).
    /// 
    /// Returns:
    ///     bool: True if this is the zero partition
    fn is_zero(&self) -> bool {
        self.inner.is_zero()
    }
    
    /// Check if this partition is uniform (all blocks have the same size).
    /// 
    /// Returns:
    ///     bool: True if all blocks have the same size
    fn is_uniform(&self) -> bool {
        self.inner.is_uniform()
    }
    
    /// Check if this partition is in initial lexicographic representative form.
    /// 
    /// Returns:
    ///     bool: True if in initial lexicographic representative form
    fn is_initial_lex_representative(&self) -> bool {
        self.inner.is_initial_lex_representative()
    }
    
    /// Get the array representation of the partition.
    /// 
    /// Returns:
    ///     List[int]: Array representation
    fn to_array(&self) -> Vec<i32> {
        self.inner.to_array()
    }
    
    /// Get the rank of the partition (universe size - number of blocks).
    /// 
    /// Returns:
    ///     int: The rank
    fn rank(&self) -> usize {
        self.inner.rank()
    }
    
    /// Convert to string with specified print type and maximum length.
    /// 
    /// Args:
    ///     print_type (PrintType): Type of string representation
    ///     max_len (int, optional): Maximum length (-1 for no limit)
    /// 
    /// Returns:
    ///     str: String representation
    fn to_string_with_type(&self, print_type: &PyPrintType, max_len: Option<i32>) -> String {
        self.inner.to_string_with_type(print_type.inner, max_len.unwrap_or(-1))
    }
    
    /// Convert to string with specified print type.
    /// 
    /// Args:
    ///     print_type (PrintType): Type of string representation
    /// 
    /// Returns:
    ///     str: String representation
    fn to_string_with_print_type(&self, print_type: &PyPrintType) -> String {
        self.inner.to_string_with_print_type(print_type.inner)
    }
    
    /// Convert to string with maximum length.
    /// 
    /// Args:
    ///     max_len (int): Maximum length
    /// 
    /// Returns:
    ///     str: String representation
    fn to_string_with_max_len(&self, max_len: i32) -> String {
        self.inner.to_string_with_max_len(max_len)
    }
    
    /// Python string representation.
    fn __str__(&self) -> String {
        self.inner.to_string()
    }
    
    /// Python repr representation.
    fn __repr__(&self) -> String {
        format!("Partition({})", self.inner.to_string())
    }
    
    /// Python equality comparison.
    fn __eq__(&self, other: &PyPartition) -> bool {
        self.inner == other.inner
    }
    
    /// Python hash function.
    fn __hash__(&self) -> u64 {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        
        let mut hasher = DefaultHasher::new();
        self.inner.hash(&mut hasher);
        hasher.finish()
    }
    
    /// Python comparison (less than).
    fn __lt__(&self, other: &PyPartition) -> bool {
        self.inner < other.inner
    }
    
    /// Python comparison (less than or equal).
    fn __le__(&self, other: &PyPartition) -> bool {
        self.inner <= other.inner
    }
    
    /// Python comparison (greater than).
    fn __gt__(&self, other: &PyPartition) -> bool {
        self.inner > other.inner
    }
    
    /// Python comparison (greater than or equal).
    fn __ge__(&self, other: &PyPartition) -> bool {
        self.inner >= other.inner
    }
    
    /// Calculate unary polymorphisms of a collection of partitions.
    /// 
    /// A unary polymorphism is a function f: {0,...,n-1} -> {0,...,n-1} that
    /// preserves all partitions in the collection.
    /// 
    /// Args:
    ///     pars (List[Partition]): Collection of partitions to respect
    /// 
    /// Returns:
    ///     List[IntArray]: List of all unary polymorphisms
    /// 
    /// Raises:
    ///     ValueError: If partitions are empty or have different sizes
    #[staticmethod]
    fn unary_polymorphisms(pars: Vec<PyRef<PyPartition>>) -> PyResult<Vec<PyIntArray>> {
        let rust_pars: Vec<uacalc::alg::conlat::partition::Partition> = 
            pars.iter().map(|p| p.inner.clone()).collect();
        
        match uacalc::alg::conlat::partition::Partition::unary_polymorphisms(&rust_pars) {
            Ok(result) => {
                let py_result: Vec<PyIntArray> = result.into_iter()
                    .map(|ia| PyIntArray { inner: ia })
                    .collect();
                Ok(py_result)
            }
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Calculate binary polymorphisms of a collection of partitions.
    /// 
    /// A binary polymorphism is a binary operation that preserves all partitions
    /// in the collection.
    /// 
    /// Args:
    ///     pars (List[Partition]): Collection of partitions to respect
    ///     unary_clone (List[IntArray], optional): Precomputed unary polymorphisms
    /// 
    /// Returns:
    ///     List[IntArray]: List of all binary polymorphisms
    /// 
    /// Raises:
    ///     ValueError: If partitions are empty or have different sizes
    #[staticmethod]
    #[pyo3(signature = (pars, unary_clone=None))]
    fn binary_polymorphisms(
        pars: Vec<PyRef<PyPartition>>,
        unary_clone: Option<Vec<PyIntArray>>
    ) -> PyResult<Vec<PyIntArray>> {
        let rust_pars: Vec<uacalc::alg::conlat::partition::Partition> = 
            pars.iter().map(|p| p.inner.clone()).collect();
        
        let rust_unary_clone = unary_clone.map(|uc| {
            uc.into_iter().map(|ia| ia.inner).collect()
        });
        
        match uacalc::alg::conlat::partition::Partition::binary_polymorphisms(&rust_pars, rust_unary_clone) {
            Ok(result) => {
                let py_result: Vec<PyIntArray> = result.into_iter()
                    .map(|ia| PyIntArray { inner: ia })
                    .collect();
                Ok(py_result)
            }
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Convert this partition to a BasicBinaryRelation.
    ///
    /// Since partitions represent equivalence relations, this method creates
    /// a BasicBinaryRelation containing all pairs (i, j) where i and j are
    /// in the same block of the partition.
    ///
    /// Returns:
    ///     BasicBinaryRelation: A binary relation representing the partition
    ///
    /// Raises:
    ///     ValueError: If conversion fails
    fn to_binary_relation(&self) -> PyResult<crate::alg::conlat::basic_binary_relation::PyBasicBinaryRelation> {
        // Get all pairs from the partition
        let pairs: Vec<uacalc::util::int_array::IntArray> = self.inner.get_pairs().into_iter().collect();

        // Create BasicBinaryRelation from the pairs
        match uacalc::alg::conlat::BasicBinaryRelation::from_pairs(pairs, self.inner.universe_size()) {
            Ok(inner) => Ok(crate::alg::conlat::basic_binary_relation::PyBasicBinaryRelation { inner }),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
}


/// Python wrapper for CentralityData
/// 
/// Note: We store the concrete types (BasicBinaryRelation) instead of the trait objects
/// to avoid Send/Sync issues with PyO3.
#[pyclass]
pub struct PyCentralityData {
    left: BasicBinaryRelation,
    right: BasicBinaryRelation,
    delta: uacalc::alg::conlat::partition::Partition,
}

#[pymethods]
impl PyCentralityData {
    /// Create a new CentralityData.
    ///
    /// Args:
    ///     left (BasicBinaryRelation): The left tolerance relation (S)
    ///     right (BasicBinaryRelation): The right tolerance relation (T)
    ///     delta (Partition): The congruence delta
    ///
    /// Returns:
    ///     CentralityData: A new CentralityData instance
    ///
    /// Raises:
    ///     ValueError: If the relations have incompatible universe sizes
    #[new]
    fn new(left: &crate::alg::conlat::basic_binary_relation::PyBasicBinaryRelation, right: &crate::alg::conlat::basic_binary_relation::PyBasicBinaryRelation, delta: &PyPartition) -> PyResult<Self> {
        // Validate that all relations have the same universe size
        let s_size = left.inner.universe_size();
        let t_size = right.inner.universe_size();
        let delta_size = delta.inner.universe_size();
        
        if s_size != t_size || s_size != delta_size {
            return Err(PyValueError::new_err(format!(
                "Universe sizes must match: S={}, T={}, delta={}",
                s_size, t_size, delta_size
            )));
        }
        
        Ok(PyCentralityData {
            left: left.inner.clone(),
            right: right.inner.clone(),
            delta: delta.inner.clone(),
        })
    }
    
    /// Get the universe size.
    /// 
    /// Returns:
    ///     int: The universe size
    fn universe_size(&self) -> usize {
        self.delta.universe_size()
    }
    
    /// Get the number of blocks in delta.
    /// 
    /// Returns:
    ///     int: The number of blocks
    fn delta_blocks(&self) -> usize {
        self.delta.number_of_blocks()
    }
    
    /// Get the left tolerance relation (S).
    ///
    /// Returns:
    ///     BasicBinaryRelation: The left tolerance relation
    fn left(&self) -> crate::alg::conlat::basic_binary_relation::PyBasicBinaryRelation {
        crate::alg::conlat::basic_binary_relation::PyBasicBinaryRelation { inner: self.left.clone() }
    }

    /// Get the right tolerance relation (T).
    ///
    /// Returns:
    ///     BasicBinaryRelation: The right tolerance relation
    fn right(&self) -> crate::alg::conlat::basic_binary_relation::PyBasicBinaryRelation {
        crate::alg::conlat::basic_binary_relation::PyBasicBinaryRelation { inner: self.right.clone() }
    }
    
    /// Get the delta partition.
    /// 
    /// Returns:
    ///     Partition: The delta partition
    fn delta(&self) -> PyPartition {
        PyPartition { inner: self.delta.clone() }
    }
    
    /// Compare with another CentralityData.
    /// 
    /// Args:
    ///     other (CentralityData): The other CentralityData to compare with
    /// 
    /// Returns:
    ///     int: -1 if self < other, 0 if equal, 1 if self > other
    fn compare_to(&self, other: &PyCentralityData) -> i32 {
        use std::cmp::Ordering;
        match self.delta.cmp(&other.delta) {
            Ordering::Less => -1,
            Ordering::Equal => 0,
            Ordering::Greater => 1,
        }
    }
    
    /// Python string representation.
    fn __str__(&self) -> String {
        use uacalc::util::IntArrayTrait;
        let mut result = String::from("left: {");
        
        let left_pairs = self.left.get_pairs();
        for (i, pair) in left_pairs.iter().enumerate() {
            if i > 0 {
                result.push_str(", ");
            }
            result.push_str(&format!("({}, {})", pair.get(0).unwrap(), pair.get(1).unwrap()));
        }
        result.push_str("}, right: {");
        
        let right_pairs = self.right.get_pairs();
        for (i, pair) in right_pairs.iter().enumerate() {
            if i > 0 {
                result.push_str(", ");
            }
            result.push_str(&format!("({}, {})", pair.get(0).unwrap(), pair.get(1).unwrap()));
        }
        result.push_str(&format!("}}, delta: {}", self.delta));
        result
    }
    
    /// Python repr representation.
    fn __repr__(&self) -> String {
        format!("CentralityData(universe_size={}, delta_blocks={})", 
                self.universe_size(), self.delta_blocks())
    }
    
    /// Python equality comparison.
    fn __eq__(&self, other: &PyCentralityData) -> bool {
        self.delta == other.delta
    }
    
    /// Python less than comparison.
    fn __lt__(&self, other: &PyCentralityData) -> bool {
        self.delta < other.delta
    }
    
    /// Python less than or equal comparison.
    fn __le__(&self, other: &PyCentralityData) -> bool {
        self.delta <= other.delta
    }
    
    /// Python greater than comparison.
    fn __gt__(&self, other: &PyCentralityData) -> bool {
        self.delta > other.delta
    }
    
    /// Python greater than or equal comparison.
    fn __ge__(&self, other: &PyCentralityData) -> bool {
        self.delta >= other.delta
    }
}





/// Python wrapper for TypeFinder
#[pyclass]
pub struct PyTypeFinder {
    inner: uacalc::alg::conlat::TypeFinder<i32>,
}

#[pymethods]
impl PyTypeFinder {
    /// Create a new TypeFinder for the given algebra.
    /// 
    /// Args:
    ///     alg (BasicSmallAlgebra): The algebra to analyze
    /// 
    /// Raises:
    ///     ValueError: If initialization fails
    #[new]
    fn new(alg: &PyBasicSmallAlgebra) -> PyResult<Self> {
        let rust_alg = Box::new(alg.inner.clone()) as Box<dyn uacalc::alg::SmallAlgebra<UniverseItem = i32>>;
        
        match uacalc::alg::conlat::TypeFinder::new(rust_alg) {
            Ok(inner) => Ok(PyTypeFinder { inner }),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Get the size of the algebra.
    /// 
    /// Returns:
    ///     int: The cardinality of the algebra
    fn alg_size(&self) -> i32 {
        self.inner.alg_size()
    }
    
    /// Initialize with the zero congruence.
    /// 
    /// Raises:
    ///     ValueError: If initialization fails
    fn init(&mut self) -> PyResult<()> {
        match self.inner.init() {
            Ok(()) => Ok(()),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Initialize with the given alpha partition.
    /// 
    /// Args:
    ///     alpha (Partition): The partition to use as alpha
    /// 
    /// Raises:
    ///     ValueError: If initialization fails
    fn init_with_alpha(&mut self, alpha: &PyPartition) -> PyResult<()> {
        match self.inner.init_with_alpha(alpha.inner.clone()) {
            Ok(()) => Ok(()),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Find the TCT type set of the algebra.
    /// 
    /// Returns the set of all types appearing in the join irreducibles of the
    /// congruence lattice.
    /// 
    /// Returns:
    ///     set: Set of TCT types (integers 1-5)
    /// 
    /// Raises:
    ///     ValueError: If computation fails
    fn find_type_set(&mut self) -> PyResult<HashSet<i32>> {
        match self.inner.find_type_set() {
            Ok(type_set) => Ok(type_set),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Test if the given pair is a beta subtrace.
    /// 
    /// Args:
    ///     ia (IntArray): The pair to test
    ///     beta (Partition): The beta partition (must be join irreducible)
    /// 
    /// Returns:
    ///     bool: True if the pair is a subtrace
    /// 
    /// Raises:
    ///     ValueError: If beta is not join irreducible or other error
    fn is_subtrace(&mut self, ia: &PyIntArray, beta: &PyPartition) -> PyResult<bool> {
        match self.inner.is_subtrace(&ia.inner, &beta.inner) {
            Ok(result) => Ok(result),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Find a subtrace for beta over its lower cover.
    /// 
    /// Args:
    ///     beta (Partition): The join irreducible congruence
    /// 
    /// Returns:
    ///     Subtrace: The subtrace for this beta
    /// 
    /// Raises:
    ///     ValueError: If beta is not join irreducible or computation fails
    fn find_subtrace(&mut self, beta: &PyPartition) -> PyResult<PySubtrace> {
        match self.inner.find_subtrace(&beta.inner) {
            Ok(subtrace) => Ok(PySubtrace { inner: subtrace }),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Find a subtrace for beta with the given alpha.
    /// 
    /// Args:
    ///     beta (Partition): The join irreducible congruence
    ///     alpha (Partition): A congruence whose join with the lower cover of beta is not above beta
    /// 
    /// Returns:
    ///     Subtrace: The subtrace for this beta/alpha pair
    /// 
    /// Raises:
    ///     ValueError: If beta is not join irreducible or computation fails
    fn find_subtrace_with_alpha(&mut self, beta: &PyPartition, alpha: &PyPartition) -> PyResult<PySubtrace> {
        match self.inner.find_subtrace_with_alpha(&beta.inner, &alpha.inner) {
            Ok(subtrace) => Ok(PySubtrace { inner: subtrace }),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Find a subtrace starting from the given pair.
    /// 
    /// Args:
    ///     pair (IntArray): The initial pair to start from
    /// 
    /// Returns:
    ///     Subtrace: The subtrace found
    /// 
    /// Raises:
    ///     ValueError: If computation fails
    fn find_subtrace_from_pair(&mut self, pair: &PyIntArray) -> PyResult<PySubtrace> {
        match self.inner.find_subtrace_from_pair(&pair.inner) {
            Ok(subtrace) => Ok(PySubtrace { inner: subtrace }),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Find the type for beta over its lower cover.
    /// 
    /// Args:
    ///     beta (Partition): The join irreducible congruence
    /// 
    /// Returns:
    ///     int: The TCT type (1-5)
    /// 
    /// Raises:
    ///     ValueError: If beta is not join irreducible or computation fails
    fn find_type(&mut self, beta: &PyPartition) -> PyResult<i32> {
        match self.inner.find_type(&beta.inner) {
            Ok(typ) => Ok(typ),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Find the type for beta with the given alpha.
    /// 
    /// Args:
    ///     beta (Partition): The join irreducible congruence
    ///     alpha (Partition): A congruence whose join with the lower cover of beta is not above beta
    /// 
    /// Returns:
    ///     int: The TCT type (1-5)
    /// 
    /// Raises:
    ///     ValueError: If beta is not join irreducible or computation fails
    fn find_type_with_alpha(&mut self, beta: &PyPartition, alpha: &PyPartition) -> PyResult<i32> {
        match self.inner.find_type_with_alpha(&beta.inner, &alpha.inner) {
            Ok(typ) => Ok(typ),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Find the type of a subtrace.
    /// 
    /// Args:
    ///     subtrace (Subtrace): The subtrace to analyze
    /// 
    /// Returns:
    ///     int: The TCT type (1-5)
    /// 
    /// Raises:
    ///     ValueError: If computation fails
    fn find_type_from_subtrace(&self, subtrace: &PySubtrace) -> PyResult<i32> {
        match self.inner.find_type_from_subtrace(subtrace.inner.clone()) {
            Ok(typ) => Ok(typ),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// String representation.
    fn __str__(&self) -> String {
        format!("TypeFinder(alg_size={})", self.inner.alg_size())
    }
    
    /// Debug representation.
    fn __repr__(&self) -> String {
        format!("TypeFinder(alg_size={})", self.inner.alg_size())
    }
}

// New abstract operation classes that can be instantiated from Python
#[derive(Debug, Clone)]
enum IntOperationEvaluationMode {
    Function(PyObject),
    Table(Vec<i32>),
}

/// Python wrapper for the new AbstractIntOperation class (function/table-based)
#[pyclass]
pub struct PyAbstractIntOperationNew {
    symbol: uacalc::alg::op::OperationSymbol,
    set_size: i32,
    evaluation_mode: IntOperationEvaluationMode,
}

#[pymethods]
impl PyAbstractIntOperationNew {
    /// Create an AbstractIntOperation from a Python function.
    #[staticmethod]
    fn from_int_value_at_function(name: &str, arity: i32, set_size: i32, int_value_at_fn: PyObject) -> PyResult<Self> {
        let symbol = match uacalc::alg::op::OperationSymbol::new_safe(name, arity, false) {
            Ok(sym) => sym,
            Err(e) => return Err(PyValueError::new_err(e)),
        };
        
        if set_size <= 0 {
            return Err(PyValueError::new_err("Set size must be positive"));
        }
        
        Ok(PyAbstractIntOperationNew {
            symbol,
            set_size,
            evaluation_mode: IntOperationEvaluationMode::Function(int_value_at_fn),
        })
    }
    
    /// Create an AbstractIntOperation from a pre-computed table.
    #[staticmethod]
    fn from_table(name: &str, arity: i32, set_size: i32, table: &PyAny) -> PyResult<Self> {
        let symbol = match uacalc::alg::op::OperationSymbol::new_safe(name, arity, false) {
            Ok(sym) => sym,
            Err(e) => return Err(PyValueError::new_err(e)),
        };
        
        if set_size <= 0 {
            return Err(PyValueError::new_err("Set size must be positive"));
        }
        
        let table_vec: Vec<i32> = table.extract()?;
        let expected_size = if arity == 0 { 1 } else { (set_size as usize).pow(arity as u32) };
        
        if table_vec.len() != expected_size {
            return Err(PyValueError::new_err(format!(
                "Table size {} doesn't match expected size {} for arity {} and set size {}",
                table_vec.len(), expected_size, arity, set_size
            )));
        }
        
        for (i, &value) in table_vec.iter().enumerate() {
            if value < 0 || value >= set_size {
                return Err(PyValueError::new_err(format!(
                    "Table value {} at index {} is out of range [0, {})",
                    value, i, set_size
                )));
            }
        }
        
        Ok(PyAbstractIntOperationNew {
            symbol,
            set_size,
            evaluation_mode: IntOperationEvaluationMode::Table(table_vec),
        })
    }
    
    fn arity(&self) -> i32 { self.symbol.arity() }
    fn get_set_size(&self) -> i32 { self.set_size }
    fn symbol(&self) -> PyOperationSymbol { PyOperationSymbol { inner: self.symbol.clone() } }
    
    fn int_value_at(&self, args: Vec<i32>) -> PyResult<i32> {
        if args.len() != self.arity() as usize {
            return Err(PyValueError::new_err(format!("Expected {} arguments, got {}", self.arity(), args.len())));
        }
        
        for &arg in &args {
            if arg < 0 || arg >= self.set_size {
                return Err(PyValueError::new_err(format!("Argument {} is out of bounds [0, {})", arg, self.set_size)));
            }
        }
        
        match &self.evaluation_mode {
            IntOperationEvaluationMode::Function(func) => {
                Python::with_gil(|py| {
                    let py_args = PyList::new_bound(py, &args);
                    let result = func.call1(py, (py_args,))?;
                    let result_int: i32 = result.extract(py)?;
                    
                    if result_int < 0 || result_int >= self.set_size {
                        return Err(PyValueError::new_err(format!(
                            "Function returned {} which is out of range [0, {})", result_int, self.set_size
                        )));
                    }
                    
                    Ok(result_int)
                })
            }
            IntOperationEvaluationMode::Table(table) => {
                let index = self.horner_encode(&args);
                Ok(table[index as usize])
            }
        }
    }
    
    fn make_table(&mut self) -> PyResult<()> {
        // Clone the function to avoid borrowing issues
        let func_clone = match &self.evaluation_mode {
            IntOperationEvaluationMode::Table(_) => return Ok(()),
            IntOperationEvaluationMode::Function(func) => func.clone(),
        };
        
        Python::with_gil(|py| {
            let arity = self.arity();
            let set_size = self.set_size;
            let table_size = if arity == 0 { 1 } else { (set_size as usize).pow(arity as u32) };
            let mut table = Vec::with_capacity(table_size);
            
            let mut all_args = Vec::new();
            if arity == 0 {
                all_args.push(Vec::new());
            } else {
                PyAbstractIntOperationNew::generate_args_static(arity, set_size, &mut Vec::new(), &mut all_args);
            }
            
            for args in all_args {
                let py_args = PyList::new_bound(py, &args);
                let result = func_clone.call1(py, (py_args,))?;
                let result_int: i32 = result.extract(py)?;
                
                if result_int < 0 || result_int >= set_size {
                    return Err(PyValueError::new_err(format!(
                        "Function returned {} which is out of range [0, {})", result_int, set_size
                    )));
                }
                
                table.push(result_int);
            }
            
            self.evaluation_mode = IntOperationEvaluationMode::Table(table);
            Ok(())
        })
    }
    
    fn get_table(&self) -> Option<Vec<i32>> {
        match &self.evaluation_mode {
            IntOperationEvaluationMode::Table(table) => Some(table.clone()),
            IntOperationEvaluationMode::Function(_) => None,
        }
    }
    
    fn is_table_based(&self) -> bool {
        matches!(self.evaluation_mode, IntOperationEvaluationMode::Table(_))
    }
    
    fn is_idempotent(&self) -> PyResult<bool> {
        let arity = self.arity();
        for x in 0..self.set_size {
            let args = vec![x; arity as usize];
            if self.int_value_at(args)? != x {
                return Ok(false);
            }
        }
        Ok(true)
    }
    
    fn is_associative(&self) -> PyResult<bool> {
        if self.arity() != 2 { return Ok(false); }
        
        for x in 0..self.set_size {
            for y in 0..self.set_size {
                for z in 0..self.set_size {
                    let xy = self.int_value_at(vec![x, y])?;
                    let yz = self.int_value_at(vec![y, z])?;
                    let left = self.int_value_at(vec![xy, z])?;
                    let right = self.int_value_at(vec![x, yz])?;
                    
                    if left != right { return Ok(false); }
                }
            }
        }
        Ok(true)
    }
    
    fn is_commutative(&self) -> PyResult<bool> {
        if self.arity() != 2 { return Ok(false); }
        
        for x in 0..self.set_size {
            for y in 0..self.set_size {
                let xy = self.int_value_at(vec![x, y])?;
                let yx = self.int_value_at(vec![y, x])?;
                if xy != yx { return Ok(false); }
            }
        }
        Ok(true)
    }
    
    fn is_totally_symmetric(&self) -> PyResult<bool> {
        let arity = self.arity() as usize;
        if arity <= 1 { return Ok(true); }
        
        if arity >= 2 {
            let mut all_args = Vec::new();
            self.generate_args_recursive(self.arity(), &mut Vec::new(), &mut all_args);
            
            for args in all_args {
                let original = self.int_value_at(args.clone())?;
                let mut swapped = args;
                swapped.swap(0, 1);
                let swapped_result = self.int_value_at(swapped)?;
                
                if original != swapped_result { return Ok(false); }
            }
        }
        
        Ok(true)
    }
    
    fn is_maltsev(&self) -> PyResult<bool> {
        if self.arity() != 3 { return Ok(false); }
        
        for x in 0..self.set_size {
            for y in 0..self.set_size {
                let xyy = self.int_value_at(vec![x, y, y])?;
                let xxy = self.int_value_at(vec![x, x, y])?;
                
                if xyy != x || xxy != y { return Ok(false); }
            }
        }
        Ok(true)
    }
    
    fn is_total(&self) -> PyResult<bool> { Ok(true) }
    
    fn __str__(&self) -> String {
        format!("AbstractIntOperation({}, arity={}, set_size={}, table_based={})", 
                self.symbol.name(), self.arity(), self.set_size, self.is_table_based())
    }
    
    fn __repr__(&self) -> String {
        format!("AbstractIntOperation(name='{}', arity={}, set_size={}, table_based={})", 
                self.symbol.name(), self.arity(), self.set_size, self.is_table_based())
    }
}

impl PyAbstractIntOperationNew {
    fn horner_encode(&self, args: &[i32]) -> i32 {
        let mut result = 0;
        let mut multiplier = 1;
        
        for &arg in args.iter().rev() {
            result += arg * multiplier;
            multiplier *= self.set_size;
        }
        
        result
    }
    
    fn generate_args_recursive(&self, arity: i32, current: &mut Vec<i32>, all_args: &mut Vec<Vec<i32>>) {
        Self::generate_args_static(arity, self.set_size, current, all_args);
    }
    
    fn generate_args_static(arity: i32, set_size: i32, current: &mut Vec<i32>, all_args: &mut Vec<Vec<i32>>) {
        if current.len() == arity as usize {
            all_args.push(current.clone());
            return;
        }
        for i in 0..set_size {
            current.push(i);
            Self::generate_args_static(arity, set_size, current, all_args);
            current.pop();
        }
    }
}

/// Evaluation mode for AbstractOperation that supports both integer and non-integer universes
#[derive(Debug, Clone)]
enum AbstractOperationEvaluationMode {
    IntFunction(PyObject),
    ValueFunction(PyObject, Vec<PyObject>), // function and universe
    IntTable(Vec<i32>),
    ValueTable(Vec<i32>, Vec<PyObject>), // table indices and universe
}

/// Python wrapper for the new AbstractOperation class (supports both integer and non-integer universes)
#[pyclass]
pub struct PyAbstractOperationNew {
    symbol: uacalc::alg::op::OperationSymbol,
    set_size: i32,
    evaluation_mode: AbstractOperationEvaluationMode,
}

#[pymethods]
impl PyAbstractOperationNew {
    #[staticmethod]
    fn from_int_value_at_function(name: &str, arity: i32, set_size: i32, int_value_at_fn: PyObject) -> PyResult<Self> {
        let symbol = match uacalc::alg::op::OperationSymbol::new_safe(name, arity, false) {
            Ok(sym) => sym,
            Err(e) => return Err(PyValueError::new_err(e)),
        };
        
        if set_size <= 0 {
            return Err(PyValueError::new_err("Set size must be positive"));
        }
        
        Ok(PyAbstractOperationNew {
            symbol,
            set_size,
            evaluation_mode: AbstractOperationEvaluationMode::IntFunction(int_value_at_fn),
        })
    }
    
    #[staticmethod]
    fn from_value_at_function(name: &str, arity: i32, universe: Vec<PyObject>, value_at_fn: PyObject) -> PyResult<Self> {
        let set_size = universe.len() as i32;
        let symbol = match uacalc::alg::op::OperationSymbol::new_safe(name, arity, false) {
            Ok(sym) => sym,
            Err(e) => return Err(PyValueError::new_err(e)),
        };
        
        if set_size <= 0 {
            return Err(PyValueError::new_err("Universe cannot be empty"));
        }
        
        Ok(PyAbstractOperationNew {
            symbol,
            set_size,
            evaluation_mode: AbstractOperationEvaluationMode::ValueFunction(value_at_fn, universe),
        })
    }
    
    fn arity(&self) -> i32 { self.symbol.arity() }
    fn get_set_size(&self) -> i32 { self.set_size }
    fn symbol(&self) -> PyOperationSymbol { PyOperationSymbol { inner: self.symbol.clone() } }
    
    fn int_value_at(&self, args: Vec<i32>) -> PyResult<i32> {
        if args.len() != self.arity() as usize {
            return Err(PyValueError::new_err(format!("Expected {} arguments, got {}", self.arity(), args.len())));
        }
        
        for &arg in &args {
            if arg < 0 || arg >= self.set_size {
                return Err(PyValueError::new_err(format!("Argument {} is out of bounds [0, {})", arg, self.set_size)));
            }
        }
        
        match &self.evaluation_mode {
            AbstractOperationEvaluationMode::IntFunction(func) => {
                Python::with_gil(|py| {
                    let py_args = PyList::new_bound(py, &args);
                    let result = func.call1(py, (py_args,))?;
                    let result_int: i32 = result.extract(py)?;
                    
                    if result_int < 0 || result_int >= self.set_size {
                        return Err(PyValueError::new_err(format!(
                            "Function returned {} which is out of range [0, {})", result_int, self.set_size
                        )));
                    }
                    
                    Ok(result_int)
                })
            }
            AbstractOperationEvaluationMode::ValueFunction(func, universe) => {
                Python::with_gil(|py| {
                    let universe_args: Vec<PyObject> = args.iter().map(|&i| universe[i as usize].clone()).collect();
                    let py_args = PyList::new_bound(py, &universe_args);
                    let result = func.call1(py, (py_args,))?;
                    
                    for (i, universe_elem) in universe.iter().enumerate() {
                        if result.bind(py).eq(universe_elem)? {
                            return Ok(i as i32);
                        }
                    }
                    
                    Err(PyValueError::new_err("Function returned a value not in the universe"))
                })
            }
            AbstractOperationEvaluationMode::IntTable(table) | AbstractOperationEvaluationMode::ValueTable(table, _) => {
                let index = self.horner_encode(&args);
                Ok(table[index as usize])
            }
        }
    }
    
    fn make_table(&mut self) -> PyResult<()> {
        match &self.evaluation_mode {
            AbstractOperationEvaluationMode::IntTable(_) | AbstractOperationEvaluationMode::ValueTable(_, _) => Ok(()),
            AbstractOperationEvaluationMode::IntFunction(func) => {
                let func_clone = func.clone();
                
                Python::with_gil(|py| {
                    let arity = self.arity();
                    let table_size = if arity == 0 { 1 } else { (self.set_size as usize).pow(arity as u32) };
                    let mut table = Vec::with_capacity(table_size);
                    
                    let mut all_args = Vec::new();
                    if arity == 0 {
                        all_args.push(Vec::new());
                    } else {
                        PyAbstractIntOperationNew::generate_args_static(arity, self.set_size, &mut Vec::new(), &mut all_args);
                    }
                    
                    for args in all_args {
                        let py_args = PyList::new_bound(py, &args);
                        let result = func_clone.call1(py, (py_args,))?;
                        let result_int: i32 = result.extract(py)?;
                        table.push(result_int);
                    }
                    
                    self.evaluation_mode = AbstractOperationEvaluationMode::IntTable(table);
                    Ok(())
                })
            }
            AbstractOperationEvaluationMode::ValueFunction(func, universe) => {
                let func_clone = func.clone();
                let universe_clone = universe.clone();
                
                Python::with_gil(|py| {
                    let arity = self.arity();
                    let table_size = if arity == 0 { 1 } else { (self.set_size as usize).pow(arity as u32) };
                    let mut table = Vec::with_capacity(table_size);
                    
                    let mut all_args = Vec::new();
                    if arity == 0 {
                        all_args.push(Vec::new());
                    } else {
                        PyAbstractIntOperationNew::generate_args_static(arity, self.set_size, &mut Vec::new(), &mut all_args);
                    }
                    
                    for args in all_args {
                        let universe_args: Vec<PyObject> = args.iter().map(|&i| universe_clone[i as usize].clone()).collect();
                        let py_args = PyList::new_bound(py, &universe_args);
                        let result = func_clone.call1(py, (py_args,))?;
                        
                        let mut result_index = None;
                        for (i, universe_elem) in universe_clone.iter().enumerate() {
                            if result.bind(py).eq(universe_elem)? {
                                result_index = Some(i as i32);
                                break;
                            }
                        }
                        
                        match result_index {
                            Some(idx) => table.push(idx),
                            None => return Err(PyValueError::new_err("Function returned a value not in the universe")),
                        }
                    }
                    
                    self.evaluation_mode = AbstractOperationEvaluationMode::ValueTable(table, universe_clone);
                    Ok(())
                })
            }
        }
    }
    
    fn get_table(&self) -> Option<Vec<i32>> {
        match &self.evaluation_mode {
            AbstractOperationEvaluationMode::IntTable(table) | AbstractOperationEvaluationMode::ValueTable(table, _) => Some(table.clone()),
            AbstractOperationEvaluationMode::IntFunction(_) | AbstractOperationEvaluationMode::ValueFunction(_, _) => None,
        }
    }
    
    fn is_table_based(&self) -> bool {
        matches!(self.evaluation_mode, AbstractOperationEvaluationMode::IntTable(_) | AbstractOperationEvaluationMode::ValueTable(_, _))
    }
    
    fn is_idempotent(&self) -> PyResult<bool> {
        let arity = self.arity();
        for x in 0..self.set_size {
            let args = vec![x; arity as usize];
            if self.int_value_at(args)? != x { return Ok(false); }
        }
        Ok(true)
    }
    
    fn is_associative(&self) -> PyResult<bool> {
        if self.arity() != 2 { return Ok(false); }
        for x in 0..self.set_size {
            for y in 0..self.set_size {
                for z in 0..self.set_size {
                    let xy = self.int_value_at(vec![x, y])?;
                    let yz = self.int_value_at(vec![y, z])?;
                    let left = self.int_value_at(vec![xy, z])?;
                    let right = self.int_value_at(vec![x, yz])?;
                    if left != right { return Ok(false); }
                }
            }
        }
        Ok(true)
    }
    
    fn is_commutative(&self) -> PyResult<bool> {
        if self.arity() != 2 { return Ok(false); }
        for x in 0..self.set_size {
            for y in 0..self.set_size {
                let xy = self.int_value_at(vec![x, y])?;
                let yx = self.int_value_at(vec![y, x])?;
                if xy != yx { return Ok(false); }
            }
        }
        Ok(true)
    }
    
    fn is_totally_symmetric(&self) -> PyResult<bool> {
        let arity = self.arity() as usize;
        if arity <= 1 { return Ok(true); }
        
        if arity >= 2 {
            let mut all_args = Vec::new();
            PyAbstractIntOperationNew::generate_args_static(self.arity(), self.set_size, &mut Vec::new(), &mut all_args);
            
            for args in all_args {
                let original = self.int_value_at(args.clone())?;
                let mut swapped = args;
                swapped.swap(0, 1);
                let swapped_result = self.int_value_at(swapped)?;
                if original != swapped_result { return Ok(false); }
            }
        }
        
        Ok(true)
    }
    
    fn is_maltsev(&self) -> PyResult<bool> {
        if self.arity() != 3 { return Ok(false); }
        for x in 0..self.set_size {
            for y in 0..self.set_size {
                let xyy = self.int_value_at(vec![x, y, y])?;
                let xxy = self.int_value_at(vec![x, x, y])?;
                if xyy != x || xxy != y { return Ok(false); }
            }
        }
        Ok(true)
    }
    
    fn is_total(&self) -> PyResult<bool> { Ok(true) }
    
    fn __str__(&self) -> String {
        let universe_type = match &self.evaluation_mode {
            AbstractOperationEvaluationMode::IntFunction(_) | AbstractOperationEvaluationMode::IntTable(_) => "integer",
            AbstractOperationEvaluationMode::ValueFunction(_, _) | AbstractOperationEvaluationMode::ValueTable(_, _) => "general",
        };
        format!("AbstractOperation({}, arity={}, set_size={}, universe={}, table_based={})", 
                self.symbol.name(), self.arity(), self.set_size, universe_type, self.is_table_based())
    }
    
    fn __repr__(&self) -> String {
        let universe_type = match &self.evaluation_mode {
            AbstractOperationEvaluationMode::IntFunction(_) | AbstractOperationEvaluationMode::IntTable(_) => "integer",
            AbstractOperationEvaluationMode::ValueFunction(_, _) | AbstractOperationEvaluationMode::ValueTable(_, _) => "general",
        };
        format!("AbstractOperation(name='{}', arity={}, set_size={}, universe={}, table_based={})", 
                self.symbol.name(), self.arity(), self.set_size, universe_type, self.is_table_based())
    }
}

impl PyAbstractOperationNew {
    fn horner_encode(&self, args: &[i32]) -> i32 {
        let mut result = 0;
        let mut multiplier = 1;
        
        for &arg in args.iter().rev() {
            result += arg * multiplier;
            multiplier *= self.set_size;
        }
        
        result
    }
}

/// Python wrapper for OperationWithDefaultValue
#[pyclass]
pub struct PyOperationWithDefaultValue {
    inner: uacalc::alg::op::OperationWithDefaultValue,
}

#[pymethods]
impl PyOperationWithDefaultValue {
    /// Constructor: Create with name, arity, set size, and default value.
    /// This is the default constructor (Constructor 2 in Java).
    #[new]
    #[pyo3(signature = (name_or_op, arity_or_set_size=None, set_size=None, default_value=-1))]
    fn new(
        name_or_op: &PyAny,
        arity_or_set_size: Option<i32>,
        set_size: Option<i32>,
        default_value: i32
    ) -> PyResult<Self> {
        // Check if first arg is a BasicOperation or OperationSymbol
        if let Ok(basic_op) = name_or_op.extract::<PyRef<PyBasicOperation>>() {
            // Constructor 1 or 5: from_operation
            if let Some(alg_size) = arity_or_set_size {
                // Constructor 5: from_operation_with_size
                match uacalc::alg::op::OperationWithDefaultValue::from_operation_with_size(
                    basic_op.inner.clone(),
                    alg_size
                ) {
                    Ok(inner) => return Ok(PyOperationWithDefaultValue { inner }),
                    Err(e) => return Err(PyValueError::new_err(e)),
                }
            } else {
                // Constructor 1: from_operation
                match uacalc::alg::op::OperationWithDefaultValue::from_operation(basic_op.inner.clone()) {
                    Ok(inner) => return Ok(PyOperationWithDefaultValue { inner }),
                    Err(e) => return Err(PyValueError::new_err(e)),
                }
            }
        } else if let Ok(op_symbol) = name_or_op.extract::<PyRef<PyOperationSymbol>>() {
            // Constructor 3, 4, or 6: with symbol
            let alg_size = arity_or_set_size.ok_or_else(|| 
                PyValueError::new_err("algebra size required when passing OperationSymbol")
            )?;
            
            if let Some(_table_param) = set_size {
                // This is actually the value table - Constructor 6
                // For now, use constructor 4
                match uacalc::alg::op::OperationWithDefaultValue::new_with_symbol_and_default(
                    op_symbol.inner.clone(),
                    alg_size,
                    default_value
                ) {
                    Ok(inner) => return Ok(PyOperationWithDefaultValue { inner }),
                    Err(e) => return Err(PyValueError::new_err(e)),
                }
            } else {
                // Constructor 3 or 4
                match uacalc::alg::op::OperationWithDefaultValue::new_with_symbol_and_default(
                    op_symbol.inner.clone(),
                    alg_size,
                    default_value
                ) {
                    Ok(inner) => return Ok(PyOperationWithDefaultValue { inner }),
                    Err(e) => return Err(PyValueError::new_err(e)),
                }
            }
        } else {
            // String name - Constructor 2
            let name = name_or_op.extract::<String>()?;
            let arity = arity_or_set_size.ok_or_else(|| 
                PyValueError::new_err("arity required when passing name")
            )?;
            let alg_size = set_size.ok_or_else(|| 
                PyValueError::new_err("set_size required when passing name and arity")
            )?;
            
            match uacalc::alg::op::OperationWithDefaultValue::new_with_name(
                &name,
                arity,
                alg_size,
                default_value
            ) {
                Ok(inner) => Ok(PyOperationWithDefaultValue { inner }),
                Err(e) => Err(PyValueError::new_err(e)),
            }
        }
    }
    
    /// Alternative constructor: from_operation (Constructor 1)
    #[staticmethod]
    fn from_operation(op: PyRef<PyBasicOperation>) -> PyResult<Self> {
        match uacalc::alg::op::OperationWithDefaultValue::from_operation(op.inner.clone()) {
            Ok(inner) => Ok(PyOperationWithDefaultValue { inner }),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Get the arity of this operation.
    fn arity(&self) -> i32 {
        self.inner.arity()
    }
    
    /// Get the algebra size of this operation.
    fn get_set_size(&self) -> i32 {
        self.inner.get_set_size()
    }
    
    /// Get the operation symbol.
    fn symbol(&self) -> PyOperationSymbol {
        PyOperationSymbol {
            inner: self.inner.symbol().clone()
        }
    }
    
    /// Get the value at the given arguments (array version).
    /// Handles both list and single int arguments for flexibility.
    fn int_value_at(&self, args: &PyAny) -> PyResult<i32> {
        // Try to extract as a list first
        if let Ok(args_list) = args.extract::<Vec<i32>>() {
            match self.inner.int_value_at_array(&args_list) {
                Ok(value) => Ok(value),
                Err(e) => Err(PyValueError::new_err(e)),
            }
        } else if let Ok(single_arg) = args.extract::<i32>() {
            // Single int argument
            match self.inner.int_value_at_single(single_arg) {
                Ok(value) => Ok(value),
                Err(e) => Err(PyValueError::new_err(e)),
            }
        } else {
            Err(PyValueError::new_err("Expected list of ints or single int"))
        }
    }
    
    /// Get value at arguments (matches Java's Object valueAt(List args)).
    fn value_at(&self, args: Vec<i32>) -> PyResult<i32> {
        match self.inner.int_value_at_array(&args) {
            Ok(value) => Ok(value),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Get the default value.
    fn get_default_value(&self) -> i32 {
        self.inner.get_default_value()
    }
    
    /// Set the default value.
    fn set_default_value(&mut self, v: i32) {
        self.inner.set_default_value(v);
    }
    
    /// Check if the idempotent flag is set.
    fn is_idempotent_set(&self) -> bool {
        self.inner.is_idempotent_set()
    }
    
    /// Set the idempotent flag.
    fn set_idempotent(&mut self, v: bool) {
        self.inner.set_idempotent(v);
    }
    
    /// Make the operation idempotent.
    fn make_idempotent(&mut self) {
        self.inner.make_idempotent();
    }
    
    /// Check if a position is on the diagonal.
    fn is_diagonal(&self, row: usize, col: usize) -> bool {
        self.inner.is_diagonal(row, col)
    }
    
    /// Update the random value table.
    fn update_random_value_table(&mut self) {
        self.inner.update_random_value_table();
    }
    
    /// Get the random value table.
    fn get_random_value_table(&mut self) -> Vec<i32> {
        self.inner.get_random_value_table().to_vec()
    }
    
    /// Get the total table (with default values filled in).
    fn get_total_table(&self) -> Option<Vec<i32>> {
        self.inner.get_total_table()
    }
    
    /// Make an ordinary operation.
    fn make_ordinary_operation(&self) -> Option<PyIntOperation> {
        self.inner.make_ordinary_operation().map(|op| PyIntOperation { inner: op })
    }
    
    /// Static method: convert list of operations to ordinary operations.
    #[staticmethod]
    fn make_ordinary(ops: Vec<PyRef<PyOperationWithDefaultValue>>) -> Vec<PyIntOperation> {
        let rust_ops: Vec<_> = ops.into_iter().map(|op| op.inner.clone()).collect();
        uacalc::alg::op::OperationWithDefaultValue::make_ordinary_list(rust_ops)
            .into_iter()
            .map(|op| PyIntOperation { inner: op })
            .collect()
    }
    
    /// Check if this operation is idempotent.
    fn is_idempotent(&self) -> PyResult<bool> {
        match self.inner.is_idempotent() {
            Ok(result) => Ok(result),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Check if this operation is total.
    fn is_total(&self) -> PyResult<bool> {
        match self.inner.is_total() {
            Ok(result) => Ok(result),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Check if this operation is table-based.
    fn is_table_based(&self) -> bool {
        self.inner.is_table_based()
    }
    
    /// Get the operation table.
    fn get_table(&self) -> Option<Vec<i32>> {
        self.inner.get_table().map(|table| table.to_vec())
    }
    
    /// Make the operation table.
    fn make_table(&mut self) -> PyResult<()> {
        match self.inner.make_table() {
            Ok(()) => Ok(()),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Python equality comparison.
    fn __eq__(&self, other: &PyOperationWithDefaultValue) -> bool {
        self.inner == other.inner
    }
    
    /// Python string representation.
    fn __repr__(&self) -> String {
        format!("OperationWithDefaultValue(name='{}', arity={}, set_size={}, default_value={})",
                self.inner.symbol().name(),
                self.inner.arity(),
                self.inner.get_set_size(),
                self.inner.get_default_value())
    }
    
    fn __str__(&self) -> String {
        format!("{}", self.inner)
    }
}

/// Python wrapper for Operations utility class
#[pyclass]
pub struct PyOperations;

#[pymethods]
impl PyOperations {
    /// Make a full cycle operation.
    /// 
    /// Args:
    ///     alg_size: The algebra size
    /// 
    /// Returns:
    ///     IntOperation: The full cycle operation
    /// 
    /// Raises:
    ///     ValueError: If parameters are invalid
    #[staticmethod]
    fn make_full_cycle(alg_size: i32) -> PyResult<PyIntOperation> {
        match uacalc::alg::op::ops::make_full_cycle(alg_size) {
            Ok(op) => {
                // op is Box<dyn Operation>, but it's constructed as IntOperation inside; rebuild via table
                let sym = op.symbol().clone();
                let set_size = op.get_set_size();
                let table = op.get_table().map(|t| t.to_vec()).unwrap_or_else(|| {
                    let arity = op.arity() as usize;
                    let total = (set_size as usize).pow(arity as u32);
                    let mut vt = Vec::with_capacity(total);
                    for k in 0..total { let args = uacalc::util::horner::horner_inv_same_size(k as i32, set_size, arity); vt.push(op.int_value_at(&args).unwrap()); }
                    vt
                });
                let int_op = uacalc::alg::op::IntOperation::new(sym, set_size, table).map_err(PyValueError::new_err)?;
                Ok(PyIntOperation { inner: int_op })
            },
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }

    // Removed concrete make_int_operation to avoid duplicate with generic overload

    /// Construct an operation from a string symbol and table.
    #[staticmethod]
    fn make_int_operation_str(name: &str, arity: i32, set_size: i32, table: Vec<i32>) -> PyResult<PyIntOperation> {
        match uacalc::alg::op::ops::make_int_operation_str(name, arity, set_size, table) {
            Ok(op) => {
                let sym = op.symbol().clone();
                let set_size = op.get_set_size();
                let table = op.get_table().unwrap().to_vec();
                let inner = uacalc::alg::op::IntOperation::new(sym, set_size, table).map_err(PyValueError::new_err)?;
                Ok(PyIntOperation { inner })
            },
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Make a transposition operation.
    /// 
    /// Args:
    ///     alg_size: The algebra size
    ///     i: First element to transpose
    ///     j: Second element to transpose
    /// 
    /// Returns:
    ///     IntOperation: The transposition operation
    /// 
    /// Raises:
    ///     ValueError: If parameters are invalid
    #[staticmethod]
    fn make_transposition(alg_size: i32, i: i32, j: i32) -> PyResult<PyIntOperation> {
        match uacalc::alg::op::ops::make_transposition(alg_size, i, j) {
            Ok(op) => {
                let sym = op.symbol().clone();
                let set_size = op.get_set_size();
                let table = op.get_table().map(|t| t.to_vec()).unwrap_or_else(|| {
                    let arity = op.arity() as usize;
                    let total = (set_size as usize).pow(arity as u32);
                    let mut vt = Vec::with_capacity(total);
                    for k in 0..total { let args = uacalc::util::horner::horner_inv_same_size(k as i32, set_size, arity); vt.push(op.int_value_at(&args).unwrap()); }
                    vt
                });
                let int_op = uacalc::alg::op::IntOperation::new(sym, set_size, table).map_err(PyValueError::new_err)?;
                Ok(PyIntOperation { inner: int_op })
            },
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Make a ternary discriminator operation.
    /// 
    /// Args:
    ///     alg_size: The algebra size
    /// 
    /// Returns:
    ///     BasicOperation: The ternary discriminator operation
    /// 
    /// Raises:
    ///     ValueError: If parameters are invalid
    #[staticmethod]
    fn make_ternary_discriminator(alg_size: i32) -> PyResult<PyBasicOperation> {
        match uacalc::alg::op::ops::ternary_discriminator(alg_size) {
            Ok(_op) => {
                // For now, we'll create a simple BasicOperation wrapper
                let symbol = match uacalc::alg::op::OperationSymbol::new_safe("discriminator", 3, false) {
                    Ok(sym) => sym,
                    Err(e) => return Err(PyValueError::new_err(e)),
                };
                match uacalc::alg::op::BasicOperation::new_safe(symbol, alg_size) {
                    Ok(inner) => Ok(PyBasicOperation { inner }),
                    Err(e) => Err(PyValueError::new_err(e)),
                }
            },
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Check if two operations have equal values.
    /// 
    /// Args:
    ///     op1: First operation
    ///     op2: Second operation
    /// 
    /// Returns:
    ///     bool: True if operations have equal values
    #[staticmethod]
    fn equal_values(op1: &PyAny, op2: &PyAny) -> PyResult<bool> {
        // Try to extract from different operation types and call the appropriate comparison
        if let Ok(basic_op1) = op1.extract::<PyRef<PyBasicOperation>>() {
            if let Ok(basic_op2) = op2.extract::<PyRef<PyBasicOperation>>() {
                match uacalc::alg::op::ops::equal_values(&basic_op1.inner, &basic_op2.inner) {
                    Ok(result) => return Ok(result),
                    Err(e) => return Err(PyValueError::new_err(e)),
                }
            } else if let Ok(int_op2) = op2.extract::<PyRef<PyIntOperation>>() {
                match uacalc::alg::op::ops::equal_values(&basic_op1.inner, &int_op2.inner) {
                    Ok(result) => return Ok(result),
                    Err(e) => return Err(PyValueError::new_err(e)),
                }
            }
        } else if let Ok(int_op1) = op1.extract::<PyRef<PyIntOperation>>() {
            if let Ok(basic_op2) = op2.extract::<PyRef<PyBasicOperation>>() {
                match uacalc::alg::op::ops::equal_values(&int_op1.inner, &basic_op2.inner) {
                    Ok(result) => return Ok(result),
                    Err(e) => return Err(PyValueError::new_err(e)),
                }
            } else if let Ok(int_op2) = op2.extract::<PyRef<PyIntOperation>>() {
                match uacalc::alg::op::ops::equal_values(&int_op1.inner, &int_op2.inner) {
                    Ok(result) => return Ok(result),
                    Err(e) => return Err(PyValueError::new_err(e)),
                }
            }
        }
        
        Err(PyValueError::new_err("Unsupported operation type combination"))
    }
    
    /// Find the first difference between two operations.
    /// 
    /// Args:
    ///     op1: First operation
    ///     op2: Second operation
    /// 
    /// Returns:
    ///     list: The first differing argument combination or None if no difference
    #[staticmethod]
    fn find_difference(op1: &PyAny, op2: &PyAny) -> PyResult<Option<Vec<i32>>> {
        // Try to extract from different operation types and call the appropriate comparison
        if let Ok(basic_op1) = op1.extract::<PyRef<PyBasicOperation>>() {
            if let Ok(basic_op2) = op2.extract::<PyRef<PyBasicOperation>>() {
                match uacalc::alg::op::ops::find_difference(&basic_op1.inner, &basic_op2.inner) {
                    Ok(result) => return Ok(result),
                    Err(e) => return Err(PyValueError::new_err(e)),
                }
            } else if let Ok(int_op2) = op2.extract::<PyRef<PyIntOperation>>() {
                match uacalc::alg::op::ops::find_difference(&basic_op1.inner, &int_op2.inner) {
                    Ok(result) => return Ok(result),
                    Err(e) => return Err(PyValueError::new_err(e)),
                }
            }
        } else if let Ok(int_op1) = op1.extract::<PyRef<PyIntOperation>>() {
            if let Ok(basic_op2) = op2.extract::<PyRef<PyBasicOperation>>() {
                match uacalc::alg::op::ops::find_difference(&int_op1.inner, &basic_op2.inner) {
                    Ok(result) => return Ok(result),
                    Err(e) => return Err(PyValueError::new_err(e)),
                }
            } else if let Ok(int_op2) = op2.extract::<PyRef<PyIntOperation>>() {
                match uacalc::alg::op::ops::find_difference(&int_op1.inner, &int_op2.inner) {
                    Ok(result) => return Ok(result),
                    Err(e) => return Err(PyValueError::new_err(e)),
                }
            }
        }
        
        Err(PyValueError::new_err("Unsupported operation type combination"))
    }
    
    /// Check if an operation is commutative.
    /// 
    /// Args:
    ///     operation: The operation to check
    /// 
    /// Returns:
    ///     bool: True if the operation is commutative
    #[staticmethod]
    fn is_commutative(operation: &PyAny) -> PyResult<bool> {
        // Try to extract from different operation types
        if let Ok(basic_op) = operation.extract::<PyRef<PyBasicOperation>>() {
            match uacalc::alg::op::ops::is_commutative(&basic_op.inner) {
                Ok(result) => Ok(result),
                Err(e) => Err(PyValueError::new_err(e)),
            }
        } else if let Ok(int_op) = operation.extract::<PyRef<PyIntOperation>>() {
            match uacalc::alg::op::ops::is_commutative(&int_op.inner) {
                Ok(result) => Ok(result),
                Err(e) => Err(PyValueError::new_err(e)),
            }
        } else {
            Err(PyValueError::new_err("Unsupported operation type"))
        }
    }
    
    /// Check if an operation is idempotent.
    /// 
    /// Args:
    ///     operation: The operation to check
    /// 
    /// Returns:
    ///     bool: True if the operation is idempotent
    #[staticmethod]
    fn is_idempotent(operation: &PyAny) -> PyResult<bool> {
        // Try to extract from different operation types
        if let Ok(basic_op) = operation.extract::<PyRef<PyBasicOperation>>() {
            match uacalc::alg::op::ops::is_idempotent(&basic_op.inner) {
                Ok(result) => Ok(result),
                Err(e) => Err(PyValueError::new_err(e)),
            }
        } else if let Ok(int_op) = operation.extract::<PyRef<PyIntOperation>>() {
            match uacalc::alg::op::ops::is_idempotent(&int_op.inner) {
                Ok(result) => Ok(result),
                Err(e) => Err(PyValueError::new_err(e)),
            }
        } else {
            Err(PyValueError::new_err("Unsupported operation type"))
        }
    }

    /// Check if a unary operation commutes with a general operation.
    #[staticmethod]
    fn commutes(unary_op: &PyAny, op: &PyAny) -> PyResult<bool> {
        if let Ok(u) = unary_op.extract::<PyRef<PyBasicOperation>>() {
            if let Ok(o) = op.extract::<PyRef<PyBasicOperation>>() {
                return uacalc::alg::op::ops::commutes_unary(&u.inner, &o.inner).map_err(PyValueError::new_err);
            } else if let Ok(o) = op.extract::<PyRef<PyIntOperation>>() {
                return uacalc::alg::op::ops::commutes_unary(&u.inner, &o.inner).map_err(PyValueError::new_err);
            }
        } else if let Ok(u) = unary_op.extract::<PyRef<PyIntOperation>>() {
            if let Ok(o) = op.extract::<PyRef<PyBasicOperation>>() {
                return uacalc::alg::op::ops::commutes_unary(&u.inner, &o.inner).map_err(PyValueError::new_err);
            } else if let Ok(o) = op.extract::<PyRef<PyIntOperation>>() {
                return uacalc::alg::op::ops::commutes_unary(&u.inner, &o.inner).map_err(PyValueError::new_err);
            }
        }
        Err(PyValueError::new_err("Unsupported operation types for commutes"))
    }

    /// Check if an operation is total.
    #[staticmethod]
    fn is_total(op: &PyAny) -> PyResult<bool> {
        if let Ok(o) = op.extract::<PyRef<PyBasicOperation>>() {
            return uacalc::alg::op::ops::is_total(&o.inner).map_err(PyValueError::new_err);
        } else if let Ok(o) = op.extract::<PyRef<PyIntOperation>>() {
            return uacalc::alg::op::ops::is_total(&o.inner).map_err(PyValueError::new_err);
        }
        Err(PyValueError::new_err("Unsupported operation type"))
    }

    /// Check if an operation is totally symmetric.
    #[staticmethod]
    fn is_totally_symmetric(op: &PyAny) -> PyResult<bool> {
        if let Ok(o) = op.extract::<PyRef<PyBasicOperation>>() {
            return uacalc::alg::op::ops::is_totally_symmetric(&o.inner).map_err(PyValueError::new_err);
        } else if let Ok(o) = op.extract::<PyRef<PyIntOperation>>() {
            return uacalc::alg::op::ops::is_totally_symmetric(&o.inner).map_err(PyValueError::new_err);
        }
        Err(PyValueError::new_err("Unsupported operation type"))
    }

    /// Check if an operation is associative.
    #[staticmethod]
    fn is_associative(op: &PyAny) -> PyResult<bool> {
        if let Ok(o) = op.extract::<PyRef<PyBasicOperation>>() {
            return uacalc::alg::op::ops::is_associative(&o.inner).map_err(PyValueError::new_err);
        } else if let Ok(o) = op.extract::<PyRef<PyIntOperation>>() {
            return uacalc::alg::op::ops::is_associative(&o.inner).map_err(PyValueError::new_err);
        }
        Err(PyValueError::new_err("Unsupported operation type"))
    }

    /// Check if an operation is a Maltsev operation.
    #[staticmethod]
    fn is_maltsev(op: &PyAny) -> PyResult<bool> {
        if let Ok(o) = op.extract::<PyRef<PyBasicOperation>>() {
            return uacalc::alg::op::ops::is_maltsev(&o.inner).map_err(PyValueError::new_err);
        } else if let Ok(o) = op.extract::<PyRef<PyIntOperation>>() {
            return uacalc::alg::op::ops::is_maltsev(&o.inner).map_err(PyValueError::new_err);
        }
        Err(PyValueError::new_err("Unsupported operation type"))
    }

    // -------------------- Factory methods --------------------
    #[staticmethod]
    #[pyo3(signature = (a, b, c, d=None))]
    fn make_int_operation(a: &PyAny, b: i32, c: &PyAny, d: Option<&PyAny>) -> PyResult<PyIntOperation> {
        // Case 1: (symbol, set_size, table)
        if let Ok(sym) = a.extract::<PyRef<PyOperationSymbol>>() {
            let set_size = b;
            let table: Vec<i32> = c.extract().map_err(PyValueError::new_err)?;
            match uacalc::alg::op::ops::make_int_operation(sym.inner.clone(), set_size, table) {
                Ok(op) => {
                    let sy = op.symbol().clone();
                    let ss = op.get_set_size();
                    let tb = op.get_table().unwrap().to_vec();
                    let inner = uacalc::alg::op::IntOperation::new(sy, ss, tb).map_err(PyValueError::new_err)?;
                    return Ok(PyIntOperation { inner })
                },
                Err(e) => return Err(PyValueError::new_err(e)),
            }
        }
        // Case 2: (name: str, arity, set_size, table)
        if let Ok(name) = a.extract::<String>() {
            let arity = b;
            let set_size: i32 = c.extract().map_err(PyValueError::new_err)?;
            let table_any = d.ok_or_else(|| PyValueError::new_err("table required"))?;
            let table: Vec<i32> = table_any.extract().map_err(PyValueError::new_err)?;
            match uacalc::alg::op::ops::make_int_operation_str(&name, arity, set_size, table) {
                Ok(op) => {
                    let sy = op.symbol().clone();
                    let ss = op.get_set_size();
                    let tb = op.get_table().unwrap().to_vec();
                    let inner = uacalc::alg::op::IntOperation::new(sy, ss, tb).map_err(PyValueError::new_err)?;
                    return Ok(PyIntOperation { inner })
                },
                Err(e) => return Err(PyValueError::new_err(e)),
            }
        }
        Err(PyValueError::new_err("Expected OperationSymbol or name string"))
    }

    #[staticmethod]
    fn make_binary_int_operation(symbol: &PyOperationSymbol, set_size: i32, table_1d: Vec<i32>) -> PyResult<PyIntOperation> {
        // Convert flattened 1D into 2D for Rust API
        let mut table2d: Vec<Vec<i32>> = Vec::with_capacity(set_size as usize);
        let mut k = 0usize;
        for _ in 0..set_size {
            let mut row = Vec::with_capacity(set_size as usize);
            for _ in 0..set_size { row.push(if k < table_1d.len() { table_1d[k] } else { 0 }); k += 1; }
            table2d.push(row);
        }
        match uacalc::alg::op::ops::make_binary_int_operation(symbol.inner.clone(), set_size, table2d) {
            Ok(op) => {
                let sym = op.symbol().clone();
                let set_size = op.get_set_size();
                let table = op.get_table().unwrap().to_vec();
                let inner = uacalc::alg::op::IntOperation::new(sym, set_size, table).map_err(PyValueError::new_err)?;
                Ok(PyIntOperation { inner })
            },
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }

    #[staticmethod]
    fn make_constant_int_operation(arg1: &PyAny, arg2: i32, arg3: Option<i32>) -> PyResult<PyIntOperation> {
        // Overloaded: (set_size, elt) or (prefix, set_size, elt)
        if let Ok(prefix) = arg1.extract::<String>() {
            let set_size = arg2;
            let elt = arg3.ok_or_else(|| PyValueError::new_err("elt required"))?;
            match uacalc::alg::op::ops::make_constant_int_operation_with_prefix(&prefix, set_size, elt) {
                Ok(op) => {
                    let sym = op.symbol().clone();
                    let set_size = op.get_set_size();
                    let table = op.get_table().unwrap().to_vec();
                    let inner = uacalc::alg::op::IntOperation::new(sym, set_size, table).map_err(PyValueError::new_err)?;
                    Ok(PyIntOperation { inner })
                },
                Err(e) => Err(PyValueError::new_err(e)),
            }
        } else if let Ok(set_size) = arg1.extract::<i32>() {
            if set_size <= 0 {
                return Err(PyValueError::new_err("Set size must be positive"));
            }
            let elt = arg2;
            if elt < 0 || elt >= set_size {
                return Err(PyValueError::new_err(format!("Default value {} is out of range [0, {})", elt, set_size)));
            }
            match uacalc::alg::op::ops::make_constant_int_operation(set_size, elt) {
                Ok(op) => {
                    let sym = op.symbol().clone();
                    let set_size = op.get_set_size();
                    let table = op.get_table().unwrap().to_vec();
                    let inner = uacalc::alg::op::IntOperation::new(sym, set_size, table).map_err(PyValueError::new_err)?;
                    Ok(PyIntOperation { inner })
                },
                Err(e) => Err(PyValueError::new_err(e)),
            }
        } else {
            Err(PyValueError::new_err("Invalid arguments for make_constant_int_operation"))
        }
    }

    #[staticmethod]
    fn make_constant_int_operations(set_size: i32) -> PyResult<Vec<PyIntOperation>> {
        match uacalc::alg::op::ops::make_constant_int_operations(set_size) {
            Ok(vec) => {
                let mut out = Vec::with_capacity(vec.len());
                for op in vec {
                    let sym = op.symbol().clone();
                    let ss = op.get_set_size();
                    let table = op.get_table().unwrap().to_vec();
                    let inner = uacalc::alg::op::IntOperation::new(sym, ss, table).map_err(PyValueError::new_err)?;
                    out.push(PyIntOperation { inner });
                }
                Ok(out)
            },
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }

    #[staticmethod]
    fn make_int_operations(ops: Vec<PyRef<PyBasicOperation>>) -> PyResult<Vec<PyIntOperation>> {
        let rust_ops: Vec<Box<dyn uacalc::alg::op::Operation>> = ops.into_iter().map(|o| Box::new(o.inner.clone()) as Box<dyn uacalc::alg::op::Operation>).collect();
        match uacalc::alg::op::ops::make_int_operations(rust_ops) {
            Ok(vec) => {
                let mut out = Vec::with_capacity(vec.len());
                for op in vec {
                    let sym = op.symbol().clone();
                    let ss = op.get_set_size();
                    let table = op.get_table().unwrap().to_vec();
                    let inner = uacalc::alg::op::IntOperation::new(sym, ss, table).map_err(PyValueError::new_err)?;
                    out.push(PyIntOperation { inner });
                }
                Ok(out)
            },
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }

    #[staticmethod]
    fn make_random_operation(n: i32, symbol: &PyOperationSymbol) -> PyResult<PyIntOperation> {
        match uacalc::alg::op::ops::make_random_operation(n, symbol.inner.clone()) {
            Ok(op) => {
                let sym = op.symbol().clone();
                let set_size = op.get_set_size();
                let table = op.get_table().unwrap().to_vec();
                let inner = uacalc::alg::op::IntOperation::new(sym, set_size, table).map_err(PyValueError::new_err)?;
                Ok(PyIntOperation { inner })
            },
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }

    #[staticmethod]
    fn make_random_operation_with_seed(n: i32, symbol: &PyOperationSymbol, seed: u64) -> PyResult<PyIntOperation> {
        match uacalc::alg::op::ops::make_random_operation_with_seed(n, symbol.inner.clone(), seed) {
            Ok(op) => {
                let sym = op.symbol().clone();
                let set_size = op.get_set_size();
                let table = op.get_table().unwrap().to_vec();
                let inner = uacalc::alg::op::IntOperation::new(sym, set_size, table).map_err(PyValueError::new_err)?;
                Ok(PyIntOperation { inner })
            },
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }

    #[staticmethod]
    fn make_random_operations(n: i32, sim_type: &PySimilarityType) -> PyResult<Vec<PyIntOperation>> {
        match uacalc::alg::op::ops::make_random_operations(n, &sim_type.inner) {
            Ok(vec) => {
                let mut out = Vec::with_capacity(vec.len());
                for op in vec {
                    let sym = op.symbol().clone();
                    let ss = op.get_set_size();
                    let table = op.get_table().unwrap().to_vec();
                    let inner = uacalc::alg::op::IntOperation::new(sym, ss, table).map_err(PyValueError::new_err)?;
                    out.push(PyIntOperation { inner });
                }
                Ok(out)
            },
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }

    #[staticmethod]
    fn make_random_operations_with_seed(n: i32, sim_type: &PySimilarityType, seed: u64) -> PyResult<Vec<PyIntOperation>> {
        match uacalc::alg::op::ops::make_random_operations_with_seed(n, &sim_type.inner, Some(seed)) {
            Ok(vec) => {
                let mut out = Vec::with_capacity(vec.len());
                for op in vec {
                    let sym = op.symbol().clone();
                    let ss = op.get_set_size();
                    let table = op.get_table().unwrap().to_vec();
                    let inner = uacalc::alg::op::IntOperation::new(sym, ss, table).map_err(PyValueError::new_err)?;
                    out.push(PyIntOperation { inner });
                }
                Ok(out)
            },
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }

    #[staticmethod]
    fn make_derived_operation(base_op: &PyAny, reduction_array: Vec<i32>, new_arity: i32) -> PyResult<PyIntOperation> {
        let op: Box<dyn uacalc::alg::op::Operation> = if let Ok(o) = base_op.extract::<PyRef<PyBasicOperation>>() {
            Box::new(o.inner.clone())
        } else if let Ok(o) = base_op.extract::<PyRef<PyIntOperation>>() {
            Box::new(o.inner.clone())
        } else {
            return Err(PyValueError::new_err("Unsupported operation type"));
        };
        match uacalc::alg::op::ops::make_derived_operation(std::sync::Arc::from(op), reduction_array, new_arity) {
            Ok(op) => {
                let sym = op.symbol().clone();
                let set_size = op.get_set_size();
                let table = op.get_table().unwrap().to_vec();
                let inner = uacalc::alg::op::IntOperation::new(sym, set_size, table).map_err(PyValueError::new_err)?;
                Ok(PyIntOperation { inner })
            },
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }

    #[staticmethod]
    fn ternary_discriminator(size: i32) -> PyResult<PyIntOperation> {
        match uacalc::alg::op::ops::ternary_discriminator(size) {
            Ok(op) => {
                let sym = op.symbol().clone();
                let set_size = op.get_set_size();
                let table = op.get_table().unwrap().to_vec();
                let inner = uacalc::alg::op::IntOperation::new(sym, set_size, table).map_err(PyValueError::new_err)?;
                Ok(PyIntOperation { inner })
            },
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }

    #[staticmethod]
    fn make_jonsson_operations_from_nuf(_nuf: &PyAny) -> PyResult<Vec<PyIntOperation>> {
        // Placeholder: returns empty list consistent with current Rust implementation
        Ok(Vec::new())
    }

    #[staticmethod]
    fn make_left_shift(vec_size: i32, root_size: i32) -> PyResult<PyIntOperation> {
        match uacalc::alg::op::ops::make_left_shift(vec_size, root_size) {
            Ok(op) => {
                let sym = op.symbol().clone();
                let set_size = op.get_set_size();
                let table = op.get_table().unwrap().to_vec();
                let inner = uacalc::alg::op::IntOperation::new(sym, set_size, table).map_err(PyValueError::new_err)?;
                Ok(PyIntOperation { inner })
            },
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }

    #[staticmethod]
    fn make_binary_left_shift(vec_size: i32, root_size: i32) -> PyResult<PyIntOperation> {
        match uacalc::alg::op::ops::make_binary_left_shift(vec_size, root_size) {
            Ok(op) => {
                let sym = op.symbol().clone();
                let set_size = op.get_set_size();
                let table = op.get_table().unwrap().to_vec();
                let inner = uacalc::alg::op::IntOperation::new(sym, set_size, table).map_err(PyValueError::new_err)?;
                Ok(PyIntOperation { inner })
            },
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }

    #[staticmethod]
    fn make_matrix_diagonal_op(vec_size: i32, root_size: i32) -> PyResult<PyIntOperation> {
        match uacalc::alg::op::ops::make_matrix_diagonal_op(vec_size, root_size) {
            Ok(op) => {
                let sym = op.symbol().clone();
                let set_size = op.get_set_size();
                let table = op.get_table().unwrap().to_vec();
                let inner = uacalc::alg::op::IntOperation::new(sym, set_size, table).map_err(PyValueError::new_err)?;
                Ok(PyIntOperation { inner })
            },
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }

    #[staticmethod]
    fn make_module_operation(modulus: i32, coeffs: Vec<i32>) -> PyResult<PyIntOperation> {
        match uacalc::alg::op::ops::make_module_operation(modulus, &coeffs) {
            Ok(op) => {
                let sym = op.symbol().clone();
                let set_size = op.get_set_size();
                let table = op.get_table().unwrap().to_vec();
                let inner = uacalc::alg::op::IntOperation::new(sym, set_size, table).map_err(PyValueError::new_err)?;
                Ok(PyIntOperation { inner })
            },
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }

    #[staticmethod]
    fn make_composition_op(n: i32, pow: i32) -> PyResult<PyIntOperation> {
        match uacalc::alg::op::ops::make_composition_op(n, pow) {
            Ok(op) => {
                let sym = op.symbol().clone();
                let set_size = op.get_set_size();
                let table = op.get_table().unwrap().to_vec();
                let inner = uacalc::alg::op::IntOperation::new(sym, set_size, table).map_err(PyValueError::new_err)?;
                Ok(PyIntOperation { inner })
            },
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }

    #[staticmethod]
    fn make_map(ops: Vec<PyRef<PyBasicOperation>>) -> PyResult<Vec<i32>> {
        let rust_ops: Vec<Box<dyn uacalc::alg::op::Operation>> = ops.into_iter().map(|o| Box::new(o.inner.clone()) as Box<dyn uacalc::alg::op::Operation>).collect();
        let map = uacalc::alg::op::ops::make_map(&rust_ops);
        // Return a list with the same size; contents unused by tests
        Ok(vec![0; map.len()])
    }
}


/// Python wrapper for SubalgebraLattice
#[pyclass]
pub struct PySubalgebraLattice {
    inner: std::cell::RefCell<uacalc::alg::sublat::SubalgebraLattice<i32>>,
}

#[pymethods]
impl PySubalgebraLattice {
    /// Create a new SubalgebraLattice from a BasicSmallAlgebra.
    /// 
    /// Args:
    ///     algebra (BasicSmallAlgebra): The algebra to compute subalgebras for
    /// 
    /// Returns:
    ///     SubalgebraLattice: A new SubalgebraLattice instance
    /// 
    /// Raises:
    ///     ValueError: If the algebra is invalid or initialization fails
    #[new]
    fn new(algebra: &PyBasicSmallAlgebra) -> PyResult<Self> {
        let alg_box: Box<dyn uacalc::alg::SmallAlgebra<UniverseItem = i32>> =  
            Box::new(algebra.inner.clone());
        
        match uacalc::alg::sublat::SubalgebraLattice::new_safe(alg_box) {
            Ok(inner) => Ok(PySubalgebraLattice { 
                inner: std::cell::RefCell::new(inner) 
            }),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Get the underlying algebra.
    /// 
    /// Returns:
    ///     str: String representation of the algebra
    fn get_algebra(&self) -> String {
        let inner = self.inner.borrow();
        format!("Algebra: size={}", inner.get_algebra().cardinality())
    }
    
    /// Get the description of this subalgebra lattice.
    /// 
    /// Returns:
    ///     str: The description
    fn get_description(&self) -> String {
        self.inner.borrow().get_description().to_string()
    }
    
    /// Set the description of this subalgebra lattice.
    /// 
    /// Args:
    ///     description (str): The new description
    fn set_description(&mut self, description: String) {
        self.inner.borrow_mut().set_description(description);
    }
    
    /// Check if the lattice can be drawn (small enough).
    /// 
    /// Returns:
    ///     bool: True if the lattice is small enough to draw
    fn is_drawable(&self) -> bool {
        self.inner.borrow().is_drawable()
    }
    
    /// Check if the lattice size is smaller than a given size.
    /// 
    /// Args:
    ///     size (int): The size to compare against
    /// 
    /// Returns:
    ///     bool: True if the lattice is smaller than the given size
    fn is_smaller_than(&self, size: i32) -> bool {
        self.inner.borrow().is_smaller_than(size.try_into().unwrap())
    }
    
    /// Check if the universe has been computed.
    /// 
    /// Returns:
    ///     bool: True if the universe has been computed
    fn universe_found(&self) -> bool {
        self.inner.borrow().universe_found()
    }
    
    /// Generate the subalgebra generated by the given elements.
    /// 
    /// Args:
    ///     generators (List[int]): List of generator elements
    /// 
    /// Returns:
    ///     BasicSet: The subalgebra generated by the given elements
    fn sg(&self, generators: Vec<i32>) -> PyBasicSet {
        let inner = self.inner.borrow();
        let result = inner.sg(&generators);
        PyBasicSet { inner: result }
    }
    
    /// Get the one-generated subalgebras.
    /// 
    /// Returns:
    ///     List[BasicSet]: List of one-generated subalgebras
    fn one_generated_subalgebras(&self) -> Vec<PyBasicSet> {
        let mut inner = self.inner.borrow_mut();
        let one_gens = inner.one_generated_subalgebras();
        one_gens.iter().map(|bs| PyBasicSet { inner: bs.clone() }).collect()
    }
    
    /// Get the join irreducibles.
    /// 
    /// Returns:
    ///     List[BasicSet]: List of join irreducible subalgebras
    fn join_irreducibles(&self) -> Vec<PyBasicSet> {
        let mut inner = self.inner.borrow_mut();
        let jis = inner.join_irreducibles_mut();
        jis.iter().map(|bs| PyBasicSet { inner: bs.clone() }).collect()
    }
    
    /// Get the meet irreducibles (stub implementation).
    /// 
    /// Returns:
    ///     List[BasicSet]: List of meet irreducible subalgebras (currently empty)
    fn meet_irreducibles(&self) -> Vec<PyBasicSet> {
        let mut inner = self.inner.borrow_mut();
        let mis = inner.meet_irreducibles_mut();
        mis.iter().map(|bs| PyBasicSet { inner: bs.clone() }).collect()
    }
    
    /// Compute the join of two subalgebras.
    /// 
    /// Args:
    ///     a (BasicSet): First subalgebra
    ///     b (BasicSet): Second subalgebra
    /// 
    /// Returns:
    ///     BasicSet: The join (smallest subalgebra containing both)
    fn join(&self, a: &PyBasicSet, b: &PyBasicSet) -> PyBasicSet {
        let inner = self.inner.borrow();
        let result = inner.join_sets(&a.inner, &b.inner);
        PyBasicSet { inner: result }
    }
    
    /// Compute the meet of two subalgebras.
    /// 
    /// Args:
    ///     a (BasicSet): First subalgebra
    ///     b (BasicSet): Second subalgebra
    /// 
    /// Returns:
    ///     BasicSet: The meet (intersection)
    fn meet(&self, a: &PyBasicSet, b: &PyBasicSet) -> PyBasicSet {
        let inner = self.inner.borrow();
        let result = Lattice::meet(&*inner, &a.inner, &b.inner);
        PyBasicSet { inner: result }
    }
    
    /// Check if one subalgebra is less than or equal to another (subset).
    /// 
    /// Args:
    ///     a (BasicSet): First subalgebra
    ///     b (BasicSet): Second subalgebra
    /// 
    /// Returns:
    ///     bool: True if a  b
    fn leq(&self, a: &PyBasicSet, b: &PyBasicSet) -> bool {
        let inner = self.inner.borrow();
        Order::leq(&*inner, &a.inner, &b.inner)
    }
    
    /// Get the universe of all subalgebras.
    /// 
    /// Returns:
    ///     List[BasicSet]: List of all subalgebras
    fn universe(&self) -> Vec<PyBasicSet> {
        let mut inner = self.inner.borrow_mut();
        let univ = inner.universe_mut();
        univ.iter().map(|bs| PyBasicSet { inner: bs.clone() }).collect()
    }
    
    /// Get the cardinality (number of subalgebras).
    /// 
    /// Returns:
    ///     int: Number of subalgebras in the lattice
    fn cardinality(&self) -> i32 {
        let inner = self.inner.borrow_mut();
        inner.cardinality()
    }
    
    /// Filter subalgebras that are greater than or equal to the given element.
    /// 
    /// Args:
    ///     element (BasicSet): The element to filter by
    /// 
    /// Returns:
    ///     List[BasicSet]: Subalgebras containing the given element
    fn filter(&self, element: &PyBasicSet) -> Vec<PyBasicSet> {
        let mut inner = self.inner.borrow_mut();
        let filtered = inner.filter(&element.inner);
        filtered.iter().map(|bs| PyBasicSet { inner: bs.clone() }).collect()
    }
    
    /// Find a minimal sized generating set for the algebra.
    /// 
    /// Returns:
    ///     BasicSet: A minimal generating set
    fn find_minimal_sized_generating_set(&self) -> PyBasicSet {
        let mut inner = self.inner.borrow_mut();
        let gen_set = inner.find_minimal_sized_generating_set();
        PyBasicSet { inner: gen_set }
    }
    
    /// Get the zero subalgebra (generated by constants).
    /// 
    /// Returns:
    ///     BasicSet: The zero subalgebra
    fn zero(&self) -> PyBasicSet {
        let inner = self.inner.borrow();
        PyBasicSet { inner: inner.zero().clone() }
    }
    
    /// Get the one subalgebra (entire algebra).
    /// 
    /// Returns:
    ///     BasicSet: The one subalgebra (whole algebra)
    fn one(&self) -> PyBasicSet {
        let inner = self.inner.borrow();
        PyBasicSet { inner: inner.one().clone() }
    }
    
    /// Remove duplicate elements from a list (static method).
    /// 
    /// Args:
    ///     lst (List[int]): List with potential duplicates
    /// 
    /// Returns:
    ///     List[int]: List with duplicates removed
    #[staticmethod]
    fn no_duplicates(lst: Vec<i32>) -> Vec<i32> {
        uacalc::alg::sublat::SubalgebraLattice::<i32>::no_duplicates(lst)
    }
    
    /// Python string representation
    fn __str__(&self) -> String {
        let inner = self.inner.borrow();
        format!("SubalgebraLattice(algebra_size={})", inner.get_algebra().cardinality())
    }
    
    /// Python repr representation
    fn __repr__(&self) -> String {
        self.__str__()
    }
}

/// Python wrapper for ParameterizedAlgebra
#[pyclass]
pub struct PyParameterizedAlgebra {
    inner: uacalc::alg::ParameterizedAlgebra,
}

#[pymethods]
impl PyParameterizedAlgebra {
    /// Create a new ParameterizedAlgebra.
    /// 
    /// Args:
    ///     parameter_names (list[str]): Names of the parameters
    ///     name (str): Name of the algebra
    ///     set_size_exp (str): Expression for set size
    ///     description (str): Description of the algebra
    ///     ops (list[ParameterizedOperation]): List of parameterized operations
    #[new]
    fn new(
        parameter_names: Vec<String>,
        name: String,
        set_size_exp: String,
        description: String,
        ops: Vec<PyParameterizedOperation>,
    ) -> Self {
        let rust_ops = ops.into_iter().map(|op| op.inner).collect();
        PyParameterizedAlgebra {
            inner: uacalc::alg::ParameterizedAlgebra::new(
                parameter_names,
                name,
                set_size_exp,
                description,
                rust_ops,
            )
        }
    }
    
    /// Create a parameter map from values.
    /// 
    /// Args:
    ///     values (list[int]): List of integer values for the parameters
    /// 
    /// Returns:
    ///     dict[str, str]: Map from parameter names to string values
    /// 
    /// Raises:
    ///     ValueError: If the number of values doesn't match the number of parameters
    fn get_parameter_map(&self, values: Vec<i32>) -> PyResult<HashMap<String, String>> {
        match self.inner.get_parameter_map(&values) {
            Ok(map) => Ok(map),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Get the parameter names.
    /// 
    /// Returns:
    ///     list[str]: List of parameter names
    fn get_parameter_names(&self) -> Vec<String> {
        self.inner.parameter_names.clone()
    }
    
    /// Get the algebra name.
    /// 
    /// Returns:
    ///     str: The name of the algebra
    fn get_name(&self) -> String {
        self.inner.name.clone()
    }
    
    /// Get the set size expression.
    /// 
    /// Returns:
    ///     str: The set size expression
    fn get_set_size_exp(&self) -> String {
        self.inner.set_size_exp.clone()
    }
    
    /// Get the description.
    /// 
    /// Returns:
    ///     str: The description
    fn get_description(&self) -> String {
        self.inner.description.clone()
    }
    
    /// Python string representation
    fn __str__(&self) -> String {
        self.inner.to_string()
    }
    
    /// Python repr representation
    fn __repr__(&self) -> String {
        format!("ParameterizedAlgebra({})", self.inner.to_string())
    }
}


/// Python wrapper for CongruenceLattice
#[pyclass]
pub struct PyCongruenceLattice {
    inner: uacalc::alg::conlat::CongruenceLattice<i32>,
}

#[pymethods]
impl PyCongruenceLattice {
    /// Create a new congruence lattice for an algebra.
    #[new]
    fn new(algebra: &PyBasicSmallAlgebra) -> Self {
        use uacalc::alg::SmallAlgebraWrapper;
        PyCongruenceLattice {
            inner: uacalc::alg::conlat::CongruenceLattice::new(
                Box::new(SmallAlgebraWrapper::new(Box::new(algebra.inner.clone())))
            ),
        }
    }
    
    /// Get the size of the algebra's universe.
    fn alg_size(&self) -> usize {
        self.inner.alg_size()
    }
    
    /// Get the zero congruence (all elements in separate blocks).
    fn zero(&self) -> PyPartition {
        PyPartition { inner: self.inner.zero() }
    }
    
    /// Get the one congruence (all elements in one block).
    fn one(&self) -> PyPartition {
        PyPartition { inner: self.inner.one() }
    }
    
    /// Get the cardinality of the congruence lattice.
    fn con_cardinality(&mut self) -> usize {
        self.inner.con_cardinality()
    }
    
    /// Test if the lattice is distributive.
    fn is_distributive(&mut self) -> bool {
        self.inner.is_distributive()
    }
    
    /// Get the description of the congruence lattice.
    fn get_description(&self) -> String {
        self.inner.get_description()
    }
    
    /// Python string representation
    fn __str__(&self) -> String {
        self.inner.to_string()
    }
    
    /// Python repr representation
    fn __repr__(&self) -> String {
        format!("CongruenceLattice({})", self.inner.to_string())
    }
    
    /// Get the tolerance generated by a pair of elements.
    fn tg(&mut self, a: usize, b: usize) -> PyResult<crate::alg::conlat::basic_binary_relation::PyBasicBinaryRelation> {
        match self.inner.tg(a, b) {
            Ok(relation) => Ok(crate::alg::conlat::basic_binary_relation::PyBasicBinaryRelation { inner: relation }),
            Err(e) => Err(PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e))
        }
    }
    
    /// Get the generating pair for a partition.
    fn generating_pair(&mut self, partition: &PyPartition) -> Option<PyIntArray> {
        self.inner.generating_pair(&partition.inner).map(|ia| PyIntArray { inner: ia })
    }
    
    /// Find the coatom above a given partition.
    fn find_coatom_above(&mut self, partition: &PyPartition) -> PyPartition {
        PyPartition { inner: self.inner.find_coatom_above(&partition.inner) }
    }
    
    /// Find a join irreducible element.
    fn find_join_irred(&mut self, a: &PyPartition, b: &PyPartition) -> Option<PyPartition> {
        self.inner.find_join_irred(&a.inner, &b.inner).map(|p| PyPartition { inner: p })
    }
    
    /// Find a meet irreducible element.
    fn find_meet_irred(&mut self, a: &PyPartition, b: &PyPartition) -> Option<PyPartition> {
        self.inner.find_meet_irred(&a.inner, &b.inner).map(|p| PyPartition { inner: p })
    }
    
    /// Get all join irreducible congruences.
    /// 
    /// Returns:
    ///     List[Partition]: List of join irreducible congruences
    fn join_irreducibles(&mut self) -> Vec<PyPartition> {
        // Use UFCS to call the inherent method, not the trait method
        use uacalc::alg::conlat::CongruenceLattice;
        let jis: &Vec<uacalc::alg::conlat::partition::Partition> = CongruenceLattice::join_irreducibles(&mut self.inner);
        jis.iter().map(|p| PyPartition { inner: p.clone() }).collect()
    }
    
    /// Get all principal congruences.
    /// 
    /// Returns:
    ///     List[Partition]: List of principal congruences
    fn principals(&mut self) -> Vec<PyPartition> {
        use uacalc::alg::conlat::CongruenceLattice;
        let principals: &Vec<uacalc::alg::conlat::partition::Partition> = CongruenceLattice::principals(&mut self.inner);
        principals.iter().map(|p| PyPartition { inner: p.clone() }).collect()
    }
    
    /// Get all atoms of the lattice.
    /// 
    /// Returns:
    ///     List[Partition]: List of atoms
    fn atoms(&mut self) -> Vec<PyPartition> {
        use uacalc::alg::conlat::CongruenceLattice;
        let atoms: &Vec<uacalc::alg::conlat::partition::Partition> = CongruenceLattice::atoms(&mut self.inner);
        atoms.iter().map(|p| PyPartition { inner: p.clone() }).collect()
    }
    
    /// Get all meet irreducible congruences.
    /// 
    /// Returns:
    ///     List[Partition]: List of meet irreducible congruences
    fn meet_irreducibles(&mut self) -> Vec<PyPartition> {
        use uacalc::alg::conlat::CongruenceLattice;
        let mis: &Vec<uacalc::alg::conlat::partition::Partition> = CongruenceLattice::meet_irreducibles(&mut self.inner);
        mis.iter().map(|p| PyPartition { inner: p.clone() }).collect()
    }
    
    /// Get all congruences (universe of the lattice).
    /// 
    /// Returns:
    ///     List[Partition]: List of all congruences
    fn universe(&mut self) -> Vec<PyPartition> {
        use uacalc::alg::conlat::CongruenceLattice;
        let univ: &Vec<uacalc::alg::conlat::partition::Partition> = CongruenceLattice::universe(&mut self.inner);
        univ.iter().map(|p| PyPartition { inner: p.clone() }).collect()
    }
    
    /// Get the permutability level of the lattice.
    /// 
    /// Returns:
    ///     int: The permutability level
    fn permutability_level(&mut self) -> i32 {
        self.inner.permutability_level()
    }
    
    /// Compute the principal congruence generated by a pair of elements.
    /// 
    /// Args:
    ///     a (int): First element
    ///     b (int): Second element
    /// 
    /// Returns:
    ///     Partition: The principal congruence Cg(a, b)
    fn cg(&mut self, a: usize, b: usize) -> PyPartition {
        PyPartition { inner: self.inner.cg(a, b) }
    }
    
    /// Get all complements of a partition.
    /// 
    /// Args:
    ///     partition (Partition): The partition to find complements for
    /// 
    /// Returns:
    ///     List[Partition]: List of complements
    fn complements(&mut self, partition: &PyPartition) -> Vec<PyPartition> {
        self.inner.complements(&partition.inner)
            .into_iter()
            .map(|p| PyPartition { inner: p })
            .collect()
    }
    
    /// Find a principal chain in the lattice.
    /// 
    /// Returns:
    ///     List[Partition]: A principal chain
    fn find_principal_chain(&mut self) -> Vec<PyPartition> {
        self.inner.find_principal_chain()
            .into_iter()
            .map(|p| PyPartition { inner: p })
            .collect()
    }
    
    /// Find the upper cover of a congruence.
    /// 
    /// Args:
    ///     congr (Partition): The congruence
    /// 
    /// Returns:
    ///     Partition or None: The upper cover if it exists
    fn find_upper_cover(&mut self, congr: &PyPartition) -> Option<PyPartition> {
        self.inner.find_upper_cover(&congr.inner)
            .map(|p| PyPartition { inner: p })
    }
    
    /// Get irredundant meet decomposition.
    /// 
    /// Returns:
    ///     List[Partition]: List of partitions in the decomposition
    fn irredundant_meet_decomposition(&mut self) -> Vec<PyPartition> {
        self.inner.irredundant_meet_decomposition()
            .into_iter()
            .map(|p| PyPartition { inner: p })
            .collect()
    }
    
    /// Find a maximal chain in the lattice.
    fn find_maximal_chain(&mut self) -> Vec<PyPartition> {
        self.inner.find_maximal_chain()
            .into_iter()
            .map(|p| PyPartition { inner: p })
            .collect()
    }
    
    /// Get idempotent polynomials.
    fn idempotent_polynomials(&mut self) -> PyResult<Vec<PyIntArray>> {
        match self.inner.idempotent_polynomials() {
            Ok(polynomials) => Ok(polynomials.into_iter().map(|ia| PyIntArray { inner: ia }).collect()),
            Err(e) => Err(PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e))
        }
    }
    
    /// Get the delta of two partitions (stubbed).
    fn delta(&mut self, alpha: &PyPartition, beta: &PyPartition) -> PyPartition {
        PyPartition { inner: self.inner.delta(&alpha.inner, &beta.inner) }
    }
    
    /// Get the commutator of two partitions (stubbed).
    fn commutator2(&mut self, alpha: &PyPartition, beta: &PyPartition) -> PyPartition {
        PyPartition { inner: self.inner.commutator2(&alpha.inner, &beta.inner) }
    }
    
    /// Test if one relation centralizes another (stubbed).
    fn centralizes(&self, s: &crate::alg::conlat::basic_binary_relation::PyBasicBinaryRelation, t: &crate::alg::conlat::basic_binary_relation::PyBasicBinaryRelation, delta: &PyPartition) -> bool {
        self.inner.centralizes(&s.inner, &t.inner, &delta.inner)
    }
}


pub fn register_alg_module(_py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    // Register classes internally but only export clean names
    m.add_class::<PyOperationSymbol>()?;
    m.add_class::<PyPrintType>()?;
    m.add_class::<PyPartition>()?;
    m.add_class::<crate::alg::conlat::polymorphisms::PyPolymorphisms>()?;
    m.add_class::<PyBasicBinaryRelation>()?;
    m.add_class::<crate::alg::op::operation::PyBasicOperation>()?;
    m.add_class::<PyIntOperation>()?;
    m.add_class::<op::abstract_int_operation::PyAbstractIntOperation>()?;
    m.add_class::<PyCongruenceLattice>()?;
    m.add_class::<PyAbstractIntOperationNew>()?;
    m.add_class::<PyAbstractOperationNew>()?;
    m.add_class::<crate::alg::conlat::subtrace::PySubtrace>()?;
    m.add_class::<PyBasicSmallAlgebra>()?;
    m.add_class::<PyOperationWithDefaultValue>()?;
    m.add_class::<PyOperations>()?;
    m.add_class::<PyBasicSet>()?;
    m.add_class::<PySubalgebraLattice>()?;
    m.add_class::<PyProductAlgebra>()?;
    m.add_class::<PyPowerAlgebra>()?;
    m.add_class::<PySubalgebra>()?;
    m.add_class::<PyParameterizedAlgebra>()?;
    m.add_class::<PyParameterizedOperation>()?;
    m.add_class::<PyReductAlgebra>()?;
    
    // Export only clean names (without Py prefix)
    m.add("OperationSymbol", m.getattr("PyOperationSymbol")?)?;
    m.add("PrintType", m.getattr("PyPrintType")?)?;
    m.add("Partition", m.getattr("PyPartition")?)?;
    m.add("Polymorphisms", m.getattr("PyPolymorphisms")?)?;
    m.add("BasicBinaryRelation", m.getattr("PyBasicBinaryRelation")?)?;
    m.add("BasicOperation", m.getattr("crate::alg::op::operation::PyBasicOperation")?)?;
    m.add("IntOperation", m.getattr("PyIntOperation")?)?;
    m.add("AbstractIntOperation", m.getattr("PyAbstractIntOperationNew")?)?;
    m.add("AbstractOperation", m.getattr("PyAbstractOperationNew")?)?;
    m.add("Subtrace", m.getattr("PySubtrace")?)?;
    m.add("BasicSmallAlgebra", m.getattr("PyBasicSmallAlgebra")?)?;
    m.add("OperationWithDefaultValue", m.getattr("PyOperationWithDefaultValue")?)?;
    m.add("Operations", m.getattr("PyOperations")?)?;
    m.add("BasicSet", m.getattr("PyBasicSet")?)?;
    m.add("SubalgebraLattice", m.getattr("PySubalgebraLattice")?)?;
    m.add("ProductAlgebra", m.getattr("PyProductAlgebra")?)?;
    m.add("PowerAlgebra", m.getattr("PyPowerAlgebra")?)?;
    m.add("Subalgebra", m.getattr("PySubalgebra")?)?;
    m.add("ParameterizedAlgebra", m.getattr("PyParameterizedAlgebra")?)?;
    m.add("ParameterizedOperation", m.getattr("PyParameterizedOperation")?)?;
    m.add("ReductAlgebra", m.getattr("PyReductAlgebra")?)?;
    m.add("CongruenceLattice", m.getattr("PyCongruenceLattice")?)?;
    
    // Remove the Py* names from the module to avoid confusion
    let module_dict = m.dict();
    module_dict.del_item("PyOperationSymbol")?;
    module_dict.del_item("PySimilarityType")?;
    module_dict.del_item("PyPrintType")?;
    module_dict.del_item("PyPartition")?;
    module_dict.del_item("PyPolymorphisms")?;
    module_dict.del_item("PyBasicBinaryRelation")?;
    module_dict.del_item("crate::alg::op::operation::PyBasicOperation")?;
    module_dict.del_item("PyIntOperation")?;
    module_dict.del_item("PyAbstractIntOperation")?;
    module_dict.del_item("PyCongruenceLattice")?;
    module_dict.del_item("PyAbstractIntOperationNew")?;
    module_dict.del_item("PyAbstractOperationNew")?;
    module_dict.del_item("PySubtrace")?;
    module_dict.del_item("PyGeneralAlgebra")?;
    module_dict.del_item("PyBasicSmallAlgebra")?;
    module_dict.del_item("PyOperationWithDefaultValue")?;
    module_dict.del_item("PyOperations")?;
    module_dict.del_item("PyBasicSet")?;
    module_dict.del_item("PySubalgebraLattice")?;
    module_dict.del_item("PyProductAlgebra")?;
    module_dict.del_item("PyPowerAlgebra")?;
    module_dict.del_item("PySubalgebra")?;
    module_dict.del_item("PyParameterizedAlgebra")?;
    module_dict.del_item("PyParameterizedOperation")?;
    module_dict.del_item("PyReductAlgebra")?;
    module_dict.del_item("PyMaltsevProductDecomposition")?;
    
    // Export cardinality constants
    m.add("CARDINALITY_UNKNOWN", uacalc::alg::CARDINALITY_UNKNOWN)?;
    m.add("CARDINALITY_FINITE", uacalc::alg::CARDINALITY_FINITE)?;
    m.add("CARDINALITY_INFINITE", uacalc::alg::CARDINALITY_INFINITE)?;
    m.add("CARDINALITY_COUNTABLE", uacalc::alg::CARDINALITY_COUNTABLE)?;
    m.add("CARDINALITY_COUNTABLY_INFINITE", uacalc::alg::CARDINALITY_COUNTABLY_INFINITE)?;
    
    Ok(())
}



/// Python wrapper for BasicSmallAlgebra (for integer universes)
#[pyclass]
pub struct PyBasicSmallAlgebra {
    pub(crate) inner: uacalc::alg::BasicSmallAlgebra<i32>,
}

impl PyBasicSmallAlgebra {
    /// Create PyBasicSmallAlgebra from inner Rust type (not exposed to Python)
    pub fn from_inner(inner: uacalc::alg::BasicSmallAlgebra<i32>) -> Self {
        PyBasicSmallAlgebra { inner }
    }
    
    /// Get the inner algebra (for internal use)
    pub(crate) fn get_inner(&self) -> &uacalc::alg::BasicSmallAlgebra<i32> {
        &self.inner
    }
    
    /// Clone the inner algebra as a boxed trait object.
    /// This is needed for the MaltsevProductDecomposition constructor.
    pub(crate) fn clone_box(&self) -> Box<dyn SmallAlgebra<UniverseItem = i32>> {
        Box::new(self.inner.clone()) as Box<dyn SmallAlgebra<UniverseItem = i32>>
    }
}

#[pymethods]
impl PyBasicSmallAlgebra {
    /// Create a new BasicSmallAlgebra.
    /// 
    /// Args:
    ///     name (str): The name of the algebra
    ///     universe (Set[int]): The universe set as a list of integers
    /// 
    /// Returns:
    ///     BasicSmallAlgebra: A new BasicSmallAlgebra instance
    #[new]
    #[pyo3(signature = (name, universe))]
    fn new(name: String, universe: Vec<i32>) -> Self {
        let universe_set: std::collections::HashSet<i32> = universe.into_iter().collect();
        let operations = Vec::new(); // Start with no operations
        PyBasicSmallAlgebra {
            inner: uacalc::alg::BasicSmallAlgebra::new(name, universe_set, operations),
        }
    }
    
    /// Get the name of this algebra.
    /// 
    /// Returns:
    ///     str: The name of the algebra
    fn name(&self) -> &str {
        self.inner.name()
    }
    
    /// Set the name of this algebra.
    /// 
    /// Args:
    ///     name (str): The new name for the algebra
    fn set_name(&mut self, name: String) {
        self.inner.set_name(name);
    }
    
    /// Get the description of this algebra.
    /// 
    /// Returns:
    ///     Optional[str]: The description of the algebra, or None if not set
    fn description(&self) -> Option<&str> {
        self.inner.description()
    }
    
    /// Set the description of this algebra.
    /// 
    /// Args:
    ///     desc (Optional[str]): The new description for the algebra
    fn set_description(&mut self, desc: Option<String>) {
        self.inner.set_description(desc);
    }
    
    /// Get the cardinality of this algebra.
    /// 
    /// Returns:
    ///     int: The cardinality of the algebra
    fn cardinality(&self) -> i32 {
        self.inner.cardinality()
    }
    
    /// Get the input size for this algebra.
    /// 
    /// Returns:
    ///     int: The input size, or -1 if it exceeds maximum integer value
    fn input_size(&self) -> i32 {
        self.inner.input_size()
    }
    
    /// Check if this algebra is unary.
    /// 
    /// Returns:
    ///     bool: True if all operations have arity 1
    fn is_unary(&self) -> bool {
        self.inner.is_unary()
    }
    
    /// Check if all operations in this algebra are idempotent.
    /// 
    /// Returns:
    ///     bool: True if all operations are idempotent
    fn is_idempotent(&self) -> bool {
        self.inner.is_idempotent()
    }
    
    /// Check if all operations in this algebra are total.
    /// 
    /// Returns:
    ///     bool: True if all operations are total
    fn is_total(&self) -> bool {
        self.inner.is_total()
    }
    
    /// Check if monitoring is enabled for this algebra.
    /// 
    /// Returns:
    ///     bool: True if monitoring is enabled
    fn monitoring(&self) -> bool {
        self.inner.monitoring()
    }
    
    /// Get the universe as a list of integers.
    /// 
    /// Returns:
    ///     List[int]: The universe elements as a list
    fn get_universe(&self) -> Vec<i32> {
        self.inner.universe().collect()
    }
    
    /// Get the algebra type.
    /// 
    /// Returns:
    ///     str: The algebra type as a string
    fn algebra_type(&self) -> String {
        format!("{:?}", self.inner.algebra_type())
    }
    
    /// Get the k-th element of the universe.
    /// 
    /// Args:
    ///     k (int): The index of the element to retrieve
    /// 
    /// Returns:
    ///     int: The element at index k, or -1 if k is out of bounds
    fn get_element(&self, k: usize) -> i32 {
        self.inner.get_element(k).unwrap_or(-1)
    }
    
    /// Get the index of an element in the universe.
    /// 
    /// Args:
    ///     elem (int): The element to find the index for
    /// 
    /// Returns:
    ///     int: The index of the element, or -1 if not found
    fn element_index(&self, elem: i32) -> i32 {
        match self.inner.element_index(&elem) {
            Some(idx) => idx as i32,
            None => -1,
        }
    }
    
    /// Get the universe as a list.
    /// 
    /// Returns:
    ///     List[int]: The universe elements as a list, or None if not available
    fn get_universe_list(&self) -> Option<Vec<i32>> {
        self.inner.get_universe_list()
    }
    
    /// Get the universe order map.
    /// 
    /// Returns:
    ///     dict: A mapping from elements to their indices, or None if not available
    fn get_universe_order(&self) -> Option<HashMap<i32, usize>> {
        self.inner.get_universe_order()
    }
    
    /// Check if this algebra uses an integer universe.
    /// 
    /// Returns:
    ///     bool: True if the universe is just integers from 0 to n-1
    fn int_universe(&self) -> bool {
        self.inner.int_universe()
    }
    
    /// Reset cached congruence and subalgebra lattices.
    /// 
    /// Note: In this partial implementation, con/sub lattices are not yet implemented,
    /// so this is a no-op but matches the Java API signature.
    fn reset_con_and_sub(&mut self) {
        self.inner.reset_con_and_sub();
    }
    
    /// Convert operations to default value operations (for UI).
    /// 
    /// Note: In this partial implementation, this is a no-op but matches the Java API signature.
    fn convert_to_default_value_ops(&mut self) {
        self.inner.convert_to_default_value_ops();
    }
    
    /// Python string representation
    fn __str__(&self) -> String {
        self.inner.to_string()
    }
    
    /// Python repr representation
    fn __repr__(&self) -> String {
        format!("BasicSmallAlgebra({})", self.inner.to_string())
    }
    
    /// Python equality comparison
    fn __eq__(&self, other: &PyBasicSmallAlgebra) -> bool {
        // Compare basic properties since we can't easily compare the full structure
        self.inner.name() == other.inner.name() && 
        self.inner.cardinality() == other.inner.cardinality()
    }
    
    /// Get the operations of this algebra.
    /// 
    /// Returns:
    ///     list: List of operation names and arities as tuples
    fn operations(&self) -> Vec<(String, i32)> {
        // Use get_operations_ref() to avoid infinite recursion limitation in operations()
        self.inner.get_operations_ref().iter().map(|op| {
            (op.symbol().name().to_string(), op.arity())
        }).collect()
    }
    
    /// Get the number of operations in this algebra.
    /// 
    /// Returns:
    ///     int: The number of operations
    fn operations_count(&self) -> usize {
        // Use get_operations_ref() to avoid infinite recursion limitation in operations()
        self.inner.get_operations_ref().len()
    }
    
    /// Get the congruence lattice (lazy initialization).
    /// 
    /// Returns:
    ///     CongruenceLattice: The congruence lattice
    fn con(&mut self) -> PyCongruenceLattice {
        let con_lat = self.inner.con();
        PyCongruenceLattice {
            inner: con_lat.clone(),
        }
    }
    
    /// Get the subalgebra lattice (lazy initialization).
    /// 
    /// Returns:
    ///     SubalgebraLattice: The subalgebra lattice
    fn sub(&mut self) -> PySubalgebraLattice {
        let sub_lat = self.inner.sub();
        PySubalgebraLattice {
            inner: std::cell::RefCell::new(sub_lat.clone()),
        }
    }
}






/// Python wrapper for ReductAlgebra
#[pyclass]
pub struct PyReductAlgebra {
    inner: uacalc::alg::ReductAlgebra,
}

impl PyReductAlgebra {
    /// Create PyReductAlgebra from inner Rust type (not exposed to Python)
    fn from_inner(inner: uacalc::alg::ReductAlgebra) -> Self {
        PyReductAlgebra { inner }
    }
}

#[pymethods]
impl PyReductAlgebra {
    /// Create a new ReductAlgebra from a super algebra and list of terms.
    /// 
    /// Args:
    ///     super_algebra (BasicSmallAlgebra): The super algebra that this reduct is based on
    ///     term_list (List[Term]): The list of terms that define the operations
    /// 
    /// Returns:
    ///     ReductAlgebra: A new ReductAlgebra instance
    /// 
    /// Raises:
    ///     ValueError: If the terms are invalid or algebra is incompatible
    #[new]
    fn new(super_algebra: &PyBasicSmallAlgebra, term_list: &PyList) -> PyResult<Self> {
        // Convert Python list of terms to Rust Vec<Box<dyn Term>>
        let mut rust_terms: Vec<Box<dyn uacalc::terms::Term>> = Vec::new();
        
        for item in term_list.iter() {
            // For now, we'll create a simple variable term
            // In a full implementation, we'd need to handle different term types
            if let Ok(var_name) = item.extract::<String>() {
                let var = Box::new(uacalc::terms::VariableImp::new(&var_name)) as Box<dyn uacalc::terms::Term>;
                rust_terms.push(var);
            } else {
                return Err(PyValueError::new_err("Term list must contain strings (variable names)"));
            }
        }
        
        // Create the super algebra as a trait object
        let super_alg = Box::new(super_algebra.inner.clone()) as Box<dyn uacalc::alg::SmallAlgebra<UniverseItem = i32>>;
        
        match uacalc::alg::ReductAlgebra::new_safe(super_alg, rust_terms) {
            Ok(inner) => Ok(PyReductAlgebra { inner }),
            Err(e) => Err(PyValueError::new_err(e)),
        }
    }
    
    /// Get the name of this algebra.
    /// 
    /// Returns:
    ///     str: The name of the algebra
    fn name(&self) -> &str {
        self.inner.name()
    }
    
    /// Set the name of this algebra.
    /// 
    /// Args:
    ///     name (str): The new name
    fn set_name(&mut self, name: String) {
        self.inner.set_name(name);
    }
    
    /// Get the cardinality of this algebra.
    /// 
    /// Returns:
    ///     int: The cardinality of the algebra
    fn cardinality(&self) -> i32 {
        self.inner.cardinality()
    }
    
    /// Get the algebra type.
    /// 
    /// Returns:
    ///     str: The algebra type
    fn algebra_type(&self) -> String {
        "Reduct".to_string()
    }
    
    /// Get the universe as a list.
    /// 
    /// Returns:
    ///     List[int]: The universe elements
    fn get_universe_list(&self) -> Option<Vec<i32>> {
        self.inner.get_universe_list()
    }
    
    /// Get the universe order as a dictionary.
    /// 
    /// Returns:
    ///     Dict[int, int]: The universe order mapping
    fn get_universe_order(&self) -> Option<HashMap<i32, usize>> {
        self.inner.get_universe_order()
    }
    
    /// Get an element by its index.
    /// 
    /// Args:
    ///     index (int): The index of the element
    /// 
    /// Returns:
    ///     int: The element at the given index
    fn get_element(&self, index: usize) -> Option<i32> {
        self.inner.get_element(index)
    }
    
    /// Get the index of an element.
    /// 
    /// Args:
    ///     element (int): The element to find the index for
    /// 
    /// Returns:
    ///     int: The index of the element
    fn element_index(&self, element: i32) -> Option<usize> {
        self.inner.element_index(&element)
    }
    
    /// Check if this algebra is unary.
    /// 
    /// Returns:
    ///     bool: True if the algebra is unary
    fn is_unary(&self) -> bool {
        self.inner.is_unary()
    }
    
    /// Check if this algebra is idempotent.
    /// 
    /// Returns:
    ///     bool: True if the algebra is idempotent
    fn is_idempotent(&self) -> bool {
        self.inner.is_idempotent()
    }
    
    /// Check if this algebra is total.
    /// 
    /// Returns:
    ///     bool: True if the algebra is total
    fn is_total(&self) -> bool {
        self.inner.is_total()
    }
    
    /// Get the number of operations in this algebra.
    /// 
    /// Returns:
    ///     int: The number of operations
    fn operations_count(&self) -> usize {
        self.inner.get_operations_ref().len()
    }
    
    /// Python string representation
    fn __str__(&self) -> String {
        self.inner.to_string()
    }
    
    /// Python repr representation
    fn __repr__(&self) -> String {
        format!("ReductAlgebra({})", self.inner.to_string())
    }
    
    /// Python equality comparison
    fn __eq__(&self, other: &PyReductAlgebra) -> bool {
        self.inner.name() == other.inner.name() && 
        self.inner.cardinality() == other.inner.cardinality()
    }
    
    /// Python hash function
    fn __hash__(&self) -> u64 {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        
        let mut hasher = DefaultHasher::new();
        self.inner.name().hash(&mut hasher);
        self.inner.cardinality().hash(&mut hasher);
        hasher.finish()
    }
    
    /// Get the congruence lattice (lazy initialization).
    /// 
    /// Returns:
    ///     CongruenceLattice: The congruence lattice
    fn con(&mut self) -> PyCongruenceLattice {
        let con_lat = self.inner.con();
        PyCongruenceLattice {
            inner: con_lat.clone(),
        }
    }
    
    /// Get the subalgebra lattice (lazy initialization).
    /// 
    /// Returns:
    ///     SubalgebraLattice: The subalgebra lattice
    fn sub(&mut self) -> PySubalgebraLattice {
        let sub_lat = self.inner.sub();
        PySubalgebraLattice {
            inner: std::cell::RefCell::new(sub_lat.clone()),
        }
    }
}


