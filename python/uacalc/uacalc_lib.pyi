"""
Type stubs for uacalc_lib module.
This file provides type information for Python IDEs and type checkers.
"""

from typing import Any, List, Dict, Optional, Union, Tuple
from typing_extensions import Protocol

# Type aliases for common UACalc types
Element = Union[int, str, Tuple[Any, ...]]

# ============================================================================
# PROTOCOL DEFINITIONS
# ============================================================================

class Operation(Protocol):
    """Protocol for operation types in universal algebra.
    
    This protocol defines the interface that all operations must implement.
    Operations are maps from the direct product of some number (arity) of a set
    to the set itself.
    """
    def arity(self) -> int: ...
    """Returns the arity (number of arguments) of this operation."""
    
    def get_set_size(self) -> int: ...
    """Returns the size of the set upon which the operation is defined."""
    
    def symbol(self) -> "alg.OperationSymbol": ...
    """Returns the operation symbol for this operation."""
    
    def int_value_at(self, args: List[int]) -> int: ...
    """Evaluates the operation at the given integer arguments.
    
    Args:
        args: List of integer arguments
        
    Returns:
        The result of the operation as an integer
    """
    
    def get_table(self) -> Optional[List[int]]: ...
    """Returns the operation table if available, None otherwise.
    
    Returns:
        The operation table as a list of integers, or None if not available
    """

class Algebra(Protocol):
    """Protocol for algebra types in universal algebra.
    
    An algebra consists of a universe (set) and a collection of operations
    defined on that set. This protocol defines the interface that all algebras
    must implement.
    """
    def cardinality(self) -> int: ...
    """Returns the cardinality of the algebra.
    
    For finite algebras, returns the actual size. For infinite or unknown
    cardinalities, returns a negative constant.
    
    Returns:
        Positive integer for finite algebras, negative constant otherwise
    """
    
    def input_size(self) -> int: ...
    """Returns the input size of the algebra.
    
    This is the sum of the cardinality raised to the power of each
    operation's arity. Returns -1 if the size exceeds maximum integer value.
    
    Returns:
        The input size or -1 if it exceeds maximum integer value
    """
    
    def is_unary(self) -> bool: ...
    """Checks if this algebra is unary (has only unary operations).
    
    Returns:
        True if all operations have arity 1, False otherwise
    """
    
    def name(self) -> str: ...
    """Returns the name of this algebra."""
    
    def operations(self) -> List[Operation]: ...
    """Returns a list of all operations in this algebra.
    
    Returns:
        List of Operation instances
    """

class Lattice(Protocol):
    """Protocol for lattice types.
    
    A lattice is a partially ordered set with join and meet operations.
    This protocol extends Algebra and defines the fundamental operations
    of lattice theory.
    """
    def join_irreducibles(self) -> Optional[List[Any]]: ...
    """Returns the list of join irreducible elements, if available.
    
    A join irreducible element is one that cannot be expressed as the join
    of two strictly smaller elements.
    
    Returns:
        List of join irreducible elements, or None if not available
    """
    
    def meet_irreducibles(self) -> Optional[List[Any]]: ...
    """Returns the list of meet irreducible elements, if available.
    
    A meet irreducible element is one that cannot be expressed as the meet
    of two strictly larger elements.
    
    Returns:
        List of meet irreducible elements, or None if not available
    """
    
    def atoms(self) -> Optional[List[Any]]: ...
    """Returns the list of atoms (minimal non-zero elements), if available.
    
    An atom is an element that covers only the bottom element (if it exists).
    
    Returns:
        List of atoms, or None if not available
    """
    
    def coatoms(self) -> Optional[List[Any]]: ...
    """Returns the list of coatoms (maximal non-one elements), if available.
    
    A coatom is an element that is covered only by the top element (if it exists).
    
    Returns:
        List of coatoms, or None if not available
    """
    
    def join(self, a: Any, b: Any) -> Any: ...
    """Returns the join (least upper bound) of two elements.
    
    The join operation finds the smallest element that is greater than
    or equal to both a and b.
    
    Args:
        a: First element
        b: Second element
        
    Returns:
        The join of a and b
    """
    
    def meet(self, a: Any, b: Any) -> Any: ...
    """Returns the meet (greatest lower bound) of two elements.
    
    The meet operation finds the largest element that is less than
    or equal to both a and b.
    
    Args:
        a: First element
        b: Second element
        
    Returns:
        The meet of a and b
    """

# Module-level exports
__version__: str
__author__: str
__license__: str

# ============================================================================
# ELEMENT MODULE
# ============================================================================

class element:
    """Element module - currently empty, trait-based implementations."""
    pass

# ============================================================================
# TYPES MODULE
# ============================================================================

class types:
    """Types module - currently empty."""
    pass

# ============================================================================
# EXAMPLE MODULE
# ============================================================================

class example:
    """Example module - currently empty."""
    pass

# ============================================================================
# TERMS MODULE
# ============================================================================

class terms:
    """Terms module for term structures and operations."""
    
    class VariableImp:
        """Python wrapper for VariableImp."""
        def __init__(self, name: str) -> None: ...
        @staticmethod
        def x() -> "terms.VariableImp": ...
        @staticmethod
        def y() -> "terms.VariableImp": ...
        @staticmethod
        def z() -> "terms.VariableImp": ...
        def get_name(self) -> str: ...
        def isa_variable(self) -> bool: ...
        def depth(self) -> int: ...
        def length(self) -> int: ...
        def get_variable_list(self) -> List[str]: ...
        def eval(self, algebra: "alg.BasicAlgebra", var_map: Dict[str, int]) -> int: ...
        def int_eval(self, algebra: "alg.BasicAlgebra", var_map: Dict[str, int]) -> int: ...
        def interpretation(
            self,
            algebra: "alg.BasicAlgebra",
            varlist: List[str],
            use_all: bool,
        ) -> "alg.IntOperation": ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
    
    class NonVariableTerm:
        """Python wrapper for NonVariableTerm."""
        def __init__(
            self,
            op_sym: "alg.OperationSymbol",
            children: List[Union["terms.VariableImp", "terms.NonVariableTerm"]],
        ) -> None: ...
        @staticmethod
        def make_constant_term(sym: "alg.OperationSymbol") -> "terms.NonVariableTerm": ...
        def isa_variable(self) -> bool: ...
        def depth(self) -> int: ...
        def length(self) -> int: ...
        def get_variable_list(self) -> List[str]: ...
        def eval(self, algebra: "alg.BasicAlgebra", var_map: Dict[str, int]) -> int: ...
        def int_eval(self, algebra: "alg.BasicAlgebra", var_map: Dict[str, int]) -> int: ...
        def interpretation(
            self,
            algebra: "alg.BasicAlgebra",
            varlist: List[str],
            use_all: bool,
        ) -> "alg.IntOperation": ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class Taylor:
        """Python wrapper for Taylor term analyzer."""
        def __init__(
            self,
            op_sym: "alg.OperationSymbol",
            inteqs: List[List["util.IntArray"]],
        ) -> None: ...
        @staticmethod
        def new_with_arity(
            arity: int,
            inteqs: List[List["util.IntArray"]],
        ) -> "terms.Taylor": ...
        @staticmethod
        def markovic_mckenzie_term() -> "terms.Taylor": ...
        @staticmethod
        def siggers_term() -> "terms.Taylor": ...
        def canonical_form(self, term: Union["terms.VariableImp", "terms.NonVariableTerm"]) -> Union["terms.VariableImp", "terms.NonVariableTerm"]: ...
        def term_from_array(self, arr: List[int]) -> Union["terms.VariableImp", "terms.NonVariableTerm"]: ...
        @staticmethod
        def lexicographically_compare_int_arrays(
            a: "util.IntArray",
            b: "util.IntArray",
        ) -> int: ...
        @staticmethod
        def lexicographically_compare_arrays(a: List[int], b: List[int]) -> int: ...
        def arity(self) -> int: ...
        def inteqs(self) -> List[List["util.IntArray"]]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class TermOperationImp:
        """Python wrapper for TermOperationImp."""
        def __init__(
            self,
            term: Union["terms.VariableImp", "terms.NonVariableTerm"],
            variables: List[Union["terms.VariableImp", str]],
            algebra: "alg.BasicAlgebra",
            name: Optional[str] = None,
        ) -> None: ...
        def get_term(self) -> str: ...
        def get_ordered_variables(self) -> List[str]: ...
        def arity(self) -> int: ...
        def get_set_size(self) -> int: ...
        def int_value_at(self, args: List[int]) -> int: ...
        def get_table(self) -> Optional[List[int]]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    @staticmethod
    def string_to_term(s: str) -> Union["terms.VariableImp", "terms.NonVariableTerm"]: ...
    @staticmethod
    def is_valid_var_string(s: str) -> bool: ...
    @staticmethod
    def is_valid_op_name_string(s: str) -> bool: ...
    @staticmethod
    def flatten(term: Union["terms.VariableImp", "terms.NonVariableTerm"]) -> Union["terms.VariableImp", "terms.NonVariableTerm"]: ...

# ============================================================================
# LATTICE MODULE
# ============================================================================

class lat:
    """Lattice module for lattice structures and operations."""
    
    class DivisibilityOrder:
        """Divisibility order for integers."""
        def __init__(self) -> None: ...
        def leq(self, a: int, b: int) -> bool: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class PrefixOrder:
        """Prefix order for strings."""
        def __init__(self) -> None: ...
        def leq(self, a: str, b: str) -> bool: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class NaturalOrder:
        """Natural order for various types."""
        def __init__(self) -> None: ...
        def leq_i32(self, a: int, b: int) -> bool: ...
        def leq_u32(self, a: int, b: int) -> bool: ...
        def leq_string(self, a: str, b: str) -> bool: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class DiamondLattice:
        """Diamond lattice implementation."""
        def __init__(self) -> None: ...
        def get_element(self, index: int) -> Optional[int]: ...
        def size(self) -> int: ...
        def universe(self) -> List[int]: ...
        def cardinality(self) -> int: ...
        def leq(self, a: int, b: int) -> bool: ...
        def join_irreducibles(self) -> Optional[List[int]]: ...
        def meet_irreducibles(self) -> Optional[List[int]]: ...
        def atoms(self) -> Optional[List[int]]: ...
        def coatoms(self) -> Optional[List[int]]: ...
        def join(self, a: int, b: int) -> int: ...
        def join_list(self, args: List[int]) -> int: ...
        def meet(self, a: int, b: int) -> int: ...
        def meet_list(self, args: List[int]) -> int: ...
        def upper_covers_indices(self, index: int) -> List[int]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class BooleanLattice:
        """Boolean lattice implementation."""
        def __init__(self) -> None: ...
        def get_element(self, index: int) -> Optional[int]: ...
        def size(self) -> int: ...
        def universe(self) -> List[int]: ...
        def cardinality(self) -> int: ...
        def leq(self, a: int, b: int) -> bool: ...
        def join_irreducibles(self) -> Optional[List[int]]: ...
        def meet_irreducibles(self) -> Optional[List[int]]: ...
        def atoms(self) -> Optional[List[int]]: ...
        def coatoms(self) -> Optional[List[int]]: ...
        def join(self, a: int, b: int) -> int: ...
        def join_list(self, args: List[int]) -> int: ...
        def meet(self, a: int, b: int) -> int: ...
        def meet_list(self, args: List[int]) -> int: ...
        def upper_covers_indices(self, index: int) -> List[int]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class MeetLattice:
        """Meet lattice implementation."""
        def name(self) -> str: ...
        def universe(self) -> List[int]: ...
        def join_irreducibles(self) -> List[int]: ...
        def meet_irreducibles(self) -> List[int]: ...
        def atoms(self) -> List[int]: ...
        def coatoms(self) -> List[int]: ...
        def join(self, a: int, b: int) -> int: ...
        def join_list(self, args: List[int]) -> int: ...
        def meet(self, a: int, b: int) -> int: ...
        def meet_list(self, args: List[int]) -> int: ...
        def leq(self, a: int, b: int) -> bool: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class JoinLattice:
        """Join lattice implementation."""
        def name(self) -> str: ...
        def universe(self) -> List[int]: ...
        def join_irreducibles(self) -> List[int]: ...
        def meet_irreducibles(self) -> List[int]: ...
        def atoms(self) -> List[int]: ...
        def coatoms(self) -> List[int]: ...
        def join(self, a: int, b: int) -> int: ...
        def join_list(self, args: List[int]) -> int: ...
        def meet(self, a: int, b: int) -> int: ...
        def meet_list(self, args: List[int]) -> int: ...
        def leq(self, a: int, b: int) -> bool: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    # Module-level functions
    @staticmethod
    def maximals_divisibility(elems: List[int]) -> List[int]: ...
    @staticmethod
    def maximals_prefix(elems: List[str]) -> List[str]: ...
    @staticmethod
    def maximals_natural_i32(elems: List[int]) -> List[int]: ...
    @staticmethod
    def maximals_natural_string(elems: List[str]) -> List[str]: ...
    @staticmethod
    def ordered_sets_main() -> str: ...
    @staticmethod
    def lattice_from_meet(name: str, meet: Any) -> "lat.MeetLattice": ...
    @staticmethod
    def lattice_from_join(name: str, join: Any) -> "lat.JoinLattice": ...
    @staticmethod
    def lattice_from_meet_with_universe(name: str, univ: List[int], meet: Any) -> "lat.MeetLattice": ...
    @staticmethod
    def lattice_from_join_with_universe(name: str, univ: List[int], join: Any) -> "lat.JoinLattice": ...
    @staticmethod
    def con_to_small_lattice(con: Any) -> Any: ...
    @staticmethod
    def dual(lat: Any) -> Any: ...
    # Internal function names (also exported for compatibility)
    @staticmethod
    def py_lattice_from_meet(name: str, meet: Any) -> "lat.MeetLattice": ...
    @staticmethod
    def py_lattice_from_join(name: str, join: Any) -> "lat.JoinLattice": ...
    @staticmethod
    def py_lattice_from_meet_with_universe(name: str, univ: List[int], meet: Any) -> "lat.MeetLattice": ...
    @staticmethod
    def py_lattice_from_join_with_universe(name: str, univ: List[int], join: Any) -> "lat.JoinLattice": ...
    @staticmethod
    def py_con_to_small_lattice(con: Any) -> Any: ...
    @staticmethod
    def py_dual(lat: Any) -> Any: ...

# ============================================================================
# IO MODULE
# ============================================================================

class io:
    """IO module for algebra file I/O operations."""
    
    class Mace4Reader:
        """Reader for Mace4 format algebra files."""
        @staticmethod
        def new_from_file(file_path: str) -> "io.Mace4Reader": ...
        @staticmethod
        def new_from_stream(data: List[int]) -> "io.Mace4Reader": ...
        @staticmethod
        def parse_algebra_from_file(file_path: str) -> Optional["alg.BasicAlgebra"]: ...
        def parse_algebra_from_stream(self, data: List[int]) -> Optional["alg.BasicAlgebra"]: ...
        @staticmethod
        def parse_algebra_list_from_file(file_path: str) -> Any: ...  # Returns iterator
        def parse_algebra_list_from_stream(self, data: List[int]) -> List["alg.BasicAlgebra"]: ...
        @staticmethod
        def is_ordinary_character(c: str) -> bool: ...
        @staticmethod
        def is_special_character(c: str) -> bool: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class AlgebraReader:
        """Reader for algebra files."""
        @staticmethod
        def new_from_file(file_path: str) -> "io.AlgebraReader": ...
        @staticmethod
        def new_from_stream(data: List[int]) -> "io.AlgebraReader": ...
        def read_algebra_file(self) -> Optional["alg.BasicAlgebra"]: ...
        @staticmethod
        def read_algebra_from_file(file_path: str) -> Optional["alg.BasicAlgebra"]: ...
        def read_algebra_from_stream(self, data: List[int]) -> Optional["alg.BasicAlgebra"]: ...
        def read_algebra_list_from_file(self, file_path: str) -> List["alg.BasicAlgebra"]: ...
        def read_algebra_list_from_stream(self, data: List[int]) -> List["alg.BasicAlgebra"]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class AlgebraWriter:
        """Writer for algebra files."""
        @staticmethod
        def new_with_file(algebra: "alg.BasicAlgebra", file_path: str) -> "io.AlgebraWriter": ...
        @staticmethod
        def new_with_writer(algebra: "alg.BasicAlgebra") -> "io.AlgebraWriter": ...
        @staticmethod
        def write_algebra_xml_to_file(algebra: "alg.BasicAlgebra", file_path: str) -> None: ...
        @staticmethod
        def write_algebra_to_file(algebra: "alg.BasicAlgebra", file_path: str) -> None: ...
        @staticmethod
        def write_basic_algebra_to_file(algebra: "alg.BasicAlgebra", file_path: str) -> None: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class BadAlgebraFileException:
        """Exception for bad algebra file format."""
        def __init__(self, message: str) -> None: ...
        @staticmethod
        def new_safe(message: str) -> "io.BadAlgebraFileException": ...
        def message(self) -> str: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
    
    class ExtFileFilter:
        """File filter based on extensions."""
        def __init__(self, description: str, exts: List[str]) -> None: ...
        @staticmethod
        def new_single(description: str, ext: str) -> "io.ExtFileFilter": ...
        @staticmethod
        def new_safe(description: str, exts: List[str]) -> "io.ExtFileFilter": ...
        @staticmethod
        def new_single_safe(description: str, ext: str) -> "io.ExtFileFilter": ...
        def accept(self, path: str) -> bool: ...
        def get_description(self) -> str: ...
        def get_extensions(self) -> List[str]: ...
        @staticmethod
        def split_off_extension(path: str) -> Tuple[Optional[str], Optional[str]]: ...
        @staticmethod
        def get_extension(path: str) -> Optional[str]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
    
    @staticmethod
    def parse_line(line: str) -> int: ...
    @staticmethod
    def read_algebra_file(path: str) -> "alg.BasicAlgebra": ...
    @staticmethod
    def read_algebra_from_stream(data: List[int]) -> "alg.BasicAlgebra": ...
    @staticmethod
    def read_algebra_list_file(path: str) -> List["alg.BasicAlgebra"]: ...
    @staticmethod
    def read_algebra_list_from_stream(data: List[int]) -> "alg.BasicAlgebra": ...
    @staticmethod
    def convert_to_xml(path: str) -> None: ...
    @staticmethod
    def write_algebra_file(algebra: "alg.BasicAlgebra", path: str) -> None: ...
    @staticmethod
    def write_algebra_file_with_style(algebra: "alg.BasicAlgebra", path: str, old_style: bool) -> None: ...
    @staticmethod
    def read_projective_plane(path: str) -> "alg.BasicAlgebra": ...
    @staticmethod
    def read_projective_plane_from_stream(data: List[int]) -> "alg.BasicAlgebra": ...

# ============================================================================
# EQUATION MODULE
# ============================================================================

class eq:
    """Equation module for equation handling."""
    
    class Equation:
        """Python wrapper for Equation."""
        def __init__(
            self,
            left: Union["terms.VariableImp", "terms.NonVariableTerm"],
            right: Union["terms.VariableImp", "terms.NonVariableTerm"],
            vars: Optional[List[str]] = None,
        ) -> None: ...
        def left_side(self) -> str: ...
        def right_side(self) -> str: ...
        def get_variable_list(self) -> List[str]: ...
        def get_operation_symbols(self) -> List[str]: ...
        def find_failure(self, algebra: "alg.BasicAlgebra") -> Optional[List[int]]: ...
        def find_failure_map(self, algebra: "alg.BasicAlgebra") -> Optional[Dict[str, int]]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class Presentation:
        """Python wrapper for Presentation."""
        def __init__(self, variables: List[str], relations: List["eq.Equation"]) -> None: ...
        def get_variables(self) -> List[str]: ...
        def get_relations(self) -> List[str]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    @staticmethod
    def associative_law(op_symbol: "alg.OperationSymbol") -> "eq.Equation": ...
    @staticmethod
    def cyclic_law(op_symbol: "alg.OperationSymbol") -> "eq.Equation": ...
    @staticmethod
    def first_second_symmetric_law(op_symbol: "alg.OperationSymbol") -> "eq.Equation": ...

# ============================================================================
# GROUP MODULE
# ============================================================================

class group:
    """Group module for group theory operations."""
    pass

# ============================================================================
# PARALLEL MODULE
# ============================================================================

class parallel:
    """Parallel module for parallel processing utilities."""
    
    class Pool:
        """Python wrapper for Pool."""
        @staticmethod
        def fj_pool() -> str: ...
        @staticmethod
        def is_initialized() -> bool: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...

# ============================================================================
# FPLAT MODULE
# ============================================================================

class fplat:
    """Fplat module for partially defined lattices."""
    
    class PartiallyDefinedLattice:
        """Python wrapper for PartiallyDefinedLattice."""
        def __init__(
            self,
            name: str,
            joins: List[List["terms.VariableImp"]],
            meets: List[List["terms.VariableImp"]],
        ) -> None: ...
        def name(self) -> str: ...
        def get_defined_joins(self) -> List[List["terms.VariableImp"]]: ...
        def get_defined_meets(self) -> List[List["terms.VariableImp"]]: ...
        def leq(self, a: "terms.VariableImp", b: "terms.VariableImp") -> bool: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...

# ============================================================================
# GENERAL_ALGEBRA MODULE
# ============================================================================

class general_algebra:
    """General algebra module for algebras with arbitrary universe elements."""
    
    class GeneralAlgebra:
        """Python wrapper for GeneralAlgebra."""
        def __init__(
            self,
            name: str,
            universe: List[Any],
            operations: Optional[List[Any]] = None,
        ) -> None: ...
        @staticmethod
        def with_name(name: str) -> "general_algebra.GeneralAlgebra": ...
        def name(self) -> str: ...
        def set_name(self, name: str) -> None: ...
        def description(self) -> Optional[str]: ...
        def set_description(self, desc: Optional[str]) -> None: ...
        def cardinality(self) -> int: ...
        def input_size(self) -> int: ...
        def is_unary(self) -> bool: ...
        def is_idempotent(self) -> bool: ...
        def is_total(self) -> bool: ...
        def monitoring(self) -> bool: ...
        def get_universe(self) -> List[Any]: ...
        def get_operations(self) -> List[Any]: ...
        def add_operation(self, operation: Any) -> None: ...
        def get_operation(self, index: int) -> Any: ...
        def operations_count(self) -> int: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...

# ============================================================================
# ALG MODULE
# ============================================================================

class alg:
    """Algebra module - main algebra structures and operations."""
    
    class BasicAlgebra:
        """Python wrapper for BasicAlgebra."""
        def __init__(
            self,
            name: str,
            universe: List[int],
            operations: Optional[List[Any]] = None,
        ) -> None: ...
        @staticmethod
        def new_with_constant_op(name: str, universe: List[int]) -> "alg.BasicAlgebra": ...
        @staticmethod
        def from_general_algebra(general_algebra: "alg.GeneralAlgebra") -> "alg.BasicAlgebra": ...
        def name(self) -> str: ...
        def set_name(self, name: str) -> None: ...
        def description(self) -> Optional[str]: ...
        def set_description(self, desc: Optional[str]) -> None: ...
        def cardinality(self) -> int: ...
        def input_size(self) -> int: ...
        def is_unary(self) -> bool: ...
        def is_idempotent(self) -> bool: ...
        def is_total(self) -> bool: ...
        def monitoring(self) -> bool: ...
        def get_universe(self) -> List[int]: ...
        def algebra_type(self) -> str: ...
        def get_element(self, k: int) -> int: ...
        def element_index(self, elem: int) -> int: ...
        def get_universe_list(self) -> Optional[List[int]]: ...
        def get_universe_order(self) -> Optional[Dict[int, int]]: ...
        def int_universe(self) -> bool: ...
        def reset_con_and_sub(self) -> None: ...
        def convert_to_default_value_ops(self) -> None: ...
        def operations(self) -> List[Any]: ...
        def operations_count(self) -> int: ...
        def con(self) -> "alg.CongruenceLattice": ...
        def sub(self) -> "alg.SubalgebraLattice": ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
        def __eq__(self, other: object) -> bool: ...
    
    class BasicOperation:
        """Python wrapper for BasicOperation."""
        def __init__(
            self,
            symbol: "alg.OperationSymbol",
            set_size: int,
            table: Optional[List[int]] = None,
        ) -> None: ...
        @staticmethod
        def simple_binary_op(name: str, set_size: int) -> "alg.BasicOperation": ...
        @staticmethod
        def simple_unary_op(name: str, set_size: int) -> "alg.BasicOperation": ...
        @staticmethod
        def simple_nullary_op(name: str, set_size: int) -> "alg.BasicOperation": ...
        def arity(self) -> int: ...
        def get_set_size(self) -> int: ...
        def symbol(self) -> "alg.OperationSymbol": ...
        def value_at(self, args: List[int]) -> int: ...
        def get_table(self) -> Optional[List[int]]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class OperationSymbol:
        """Python wrapper for OperationSymbol."""
        def __init__(self, name: str, arity: int, associative: bool = False) -> None: ...
        def arity(self) -> int: ...
        def name(self) -> str: ...
        def is_associative(self) -> bool: ...
        def set_associative(self, assoc: bool) -> None: ...
        def to_string_with_arity(self, show_arity: Optional[bool] = None) -> str: ...
        @staticmethod
        def get_operation_symbol(arity: int) -> "alg.OperationSymbol": ...
        @staticmethod
        def join() -> "alg.OperationSymbol": ...
        @staticmethod
        def meet() -> "alg.OperationSymbol": ...
        @staticmethod
        def product() -> "alg.OperationSymbol": ...
        @staticmethod
        def inverse() -> "alg.OperationSymbol": ...
        @staticmethod
        def identity() -> "alg.OperationSymbol": ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
    
    class IntOperation:
        """Python wrapper for IntOperation."""
        def __init__(
            self,
            symbol: "alg.OperationSymbol",
            set_size: int,
            table: List[int],
        ) -> None: ...
        def arity(self) -> int: ...
        def get_set_size(self) -> int: ...
        def symbol(self) -> "alg.OperationSymbol": ...
        def int_value_at(self, args: List[int]) -> int: ...
        def get_table(self) -> Optional[List[int]]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class AbstractIntOperation:
        """Python wrapper for AbstractIntOperation."""
        def __init__(self, name: str, arity: int, alg_size: int) -> None: ...
        @staticmethod
        def with_symbol(symbol: "alg.OperationSymbol", alg_size: int) -> "alg.AbstractIntOperation": ...
        def arity(self) -> int: ...
        def get_set_size(self) -> int: ...
        def symbol(self) -> "alg.OperationSymbol": ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class AbstractOperation: ...
    
    class Operations: ...
    
    class OperationWithDefaultValue: ...
    
    class SimilarityType:
        """Python wrapper for SimilarityType."""
        def __init__(
            self,
            operation_symbols: List["alg.OperationSymbol"],
            sort: bool = False,
        ) -> None: ...
        def get_operation_symbols(self) -> List["alg.OperationSymbol"]: ...
        def get_sorted_operation_symbols(self) -> List["alg.OperationSymbol"]: ...
        def input_size(self, alg_size: int) -> int: ...
        def get_arities_map(self) -> Dict[int, int]: ...
        def get_max_arity(self) -> int: ...
        @staticmethod
        def lattice_similarity_type() -> "alg.SimilarityType": ...
        @staticmethod
        def group_similarity_type() -> "alg.SimilarityType": ...
        def arities_string(self) -> str: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
    
    class ParameterizedOperation: ...
    
    # Advanced algebra types
    class Homomorphism: ...
    class SubalgebraLattice: ...
    class BasicBinaryRelation: ...
    class CentralityData: ...
    class Partition: ...
    class PrintType: ...
    class CongruenceLattice: ...
    class BasicSet: ...
    class FreeAlgebra: ...
    class ProductAlgebra: ...
    class PowerAlgebra: ...
    class MatrixPowerAlgebra: ...
    
    class PolinLikeAlgebra:
        """Python wrapper for PolinLikeAlgebra.
        
        A Polin-like algebra constructed from a homomorphism between two algebras.
        The universe is the disjoint union of the bottom algebra and top algebra,
        with elements ordered as botAlg elements first, then topAlg elements.
        """
        def __init__(
            self,
            name: str,
            top_alg: "alg.BasicAlgebra",
            bot_alg: "alg.BasicAlgebra",
            map: Optional["alg.BasicOperation"] = None,
            top_const_index: int = 0,
            bot_const_index: int = 0,
        ) -> None: ...
        """Create a new PolinLikeAlgebra from two algebras and an optional homomorphism map.
        
        Args:
            name: Name of the algebra
            top_alg: The top algebra (A in f: A → B)
            bot_alg: The bottom algebra (B in f: A → B)
            map: Optional homomorphism map from topAlg to botAlg (None = identity)
            top_const_index: Index of the top constant
            bot_const_index: Index of the bottom constant
            
        Raises:
            ValueError: If construction fails
        """
        def cardinality(self) -> int: ...
        """Get the cardinality of this algebra.
        
        Returns:
            The cardinality (size of the universe)
        """
        def get_element(self, k: int) -> int: ...
        """Get the element at the given index.
        
        Args:
            k: Index of the element
            
        Returns:
            The element at index k, or -1 if out of bounds
        """
        def element_index(self, elem: int) -> int: ...
        """Get the index of an element in the universe.
        
        Args:
            elem: The element to find
            
        Returns:
            The index of the element, or -1 if not found
        """
        def algebra_type(self) -> str: ...
        """Get the algebra type.
        
        Returns:
            The algebra type ("PolinLike")
        """
        def name(self) -> str: ...
        """Get the name of this algebra.
        
        Returns:
            The name of the algebra
        """
        def set_name(self, name: str) -> None: ...
        """Set the name of this algebra.
        
        Args:
            name: The new name
        """
        def top_algebra_name(self) -> str: ...
        """Get the top algebra name.
        
        Returns:
            Name of the top algebra
        """
        def bottom_algebra_name(self) -> str: ...
        """Get the bottom algebra name.
        
        Returns:
            Name of the bottom algebra
        """
        def con(self) -> "alg.CongruenceLattice": ...
        """Get the congruence lattice (lazy initialization).
        
        Returns:
            The congruence lattice
        """
        def sub(self) -> "alg.SubalgebraLattice": ...
        """Get the subalgebra lattice (lazy initialization).
        
        Returns:
            The subalgebra lattice
        """
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class AlgebraFromMinimalSets:
        """Python wrapper for AlgebraFromMinimalSets.
        
        An algebra constructed from a minimal algebra (permutational algebra B).
        The algebra is built by extending the minimal algebra with additional
        elements and operations based on maps and connecting points.
        """
        def __init__(self, min_algebra: "alg.BasicAlgebra") -> None: ...
        """Create a new AlgebraFromMinimalSets with default size (3 * minAlgSize - 2).
        
        Args:
            min_algebra: The minimal algebra B
            
        Raises:
            ValueError: If there's an error creating the algebra
        """
        @staticmethod
        def new_with_size(
            min_algebra: "alg.BasicAlgebra",
            alg_size: int,
            maps: Optional[List[List[int]]] = None,
        ) -> "alg.AlgebraFromMinimalSets": ...
        """Create a new AlgebraFromMinimalSets with explicit size and maps.
        
        Args:
            min_algebra: The minimal algebra B
            alg_size: The size of the constructed algebra
            maps: Optional list of maps (if None, default maps are created)
            
        Returns:
            AlgebraFromMinimalSets: A new AlgebraFromMinimalSets instance
            
        Raises:
            ValueError: If there's an error creating the algebra
        """
        @staticmethod
        def new_with_name(
            min_algebra: "alg.BasicAlgebra",
            name: Optional[str] = None,
        ) -> "alg.AlgebraFromMinimalSets": ...
        """Create a new AlgebraFromMinimalSets with a name.
        
        Args:
            min_algebra: The minimal algebra B
            name: Optional name for the algebra
            
        Returns:
            AlgebraFromMinimalSets: A new AlgebraFromMinimalSets instance
            
        Raises:
            ValueError: If there's an error creating the algebra
        """
        @staticmethod
        def new_with_connecting_pts(
            min_algebra: "alg.BasicAlgebra",
            name: Optional[str] = None,
            connect_pts: Optional[List[int]] = None,
        ) -> "alg.AlgebraFromMinimalSets": ...
        """Create a new AlgebraFromMinimalSets with connecting points.
        
        Args:
            min_algebra: The minimal algebra B
            name: Optional name for the algebra
            connect_pts: Optional connecting points [a, b]
            
        Returns:
            AlgebraFromMinimalSets: A new AlgebraFromMinimalSets instance
            
        Raises:
            ValueError: If there's an error creating the algebra
        """
        @staticmethod
        def new_full(
            min_algebra: "alg.BasicAlgebra",
            alg_size: int,
            name: Optional[str] = None,
            maps: Optional[List[List[int]]] = None,
            connect_pts: Optional[List[int]] = None,
        ) -> "alg.AlgebraFromMinimalSets": ...
        """Create a new AlgebraFromMinimalSets with all parameters.
        
        Args:
            min_algebra: A permutational algebra (the minimal algebra B)
            alg_size: The size of the constructed algebra
            name: Optional name for the algebra
            maps: Optional list of maps (if None, default maps are created)
            connect_pts: Optional connecting points [a, b]
            
        Returns:
            AlgebraFromMinimalSets: A new AlgebraFromMinimalSets instance
            
        Raises:
            ValueError: If there's an error creating the algebra
        """
        def name(self) -> str: ...
        """Get the name of this algebra.
        
        Returns:
            The name of the algebra
        """
        def set_name(self, name: str) -> None: ...
        """Set the name of this algebra.
        
        Args:
            name: The new name for the algebra
        """
        def cardinality(self) -> int: ...
        """Get the cardinality of this algebra.
        
        Returns:
            The cardinality of the algebra
        """
        def get_element(self, k: int) -> int: ...
        """Get the k-th element of the universe.
        
        Args:
            k: The index of the element to retrieve
            
        Returns:
            The element at index k, or -1 if k is out of bounds
        """
        def element_index(self, elem: int) -> int: ...
        """Get the index of an element in the universe.
        
        Args:
            elem: The element to find the index for
            
        Returns:
            The index of the element, or -1 if not found
        """
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
        def __eq__(self, other: object) -> bool: ...
    
    class Subalgebra: ...
    class ReductAlgebra: ...
    
    class UnaryTermsMonoid:
        """Python wrapper for UnaryTermsMonoid.
        
        The monoid or semigroup of unary terms constructed from a generating algebra.
        This creates a monoid where the elements are unary terms and the operation
        is composition of term operations.
        """
        def __init__(self, algebra: "alg.BasicAlgebra") -> None: ...
        """Create a new UnaryTermsMonoid from a generating algebra.
        
        Args:
            algebra: The generating algebra
            
        Raises:
            ValueError: If construction fails
        """
        @staticmethod
        def new_with_id(algebra: "alg.BasicAlgebra", include_id: bool) -> "alg.UnaryTermsMonoid": ...
        """Create a new UnaryTermsMonoid with optional identity inclusion.
        
        Args:
            algebra: The generating algebra
            include_id: Whether to include the identity term
            
        Returns:
            UnaryTermsMonoid: A new UnaryTermsMonoid instance
            
        Raises:
            ValueError: If construction fails
        """
        def algebra_type(self) -> str: ...
        """Get the algebra type.
        
        Returns:
            The algebra type ("UNARY_TERMS_MONOID")
        """
        def cardinality(self) -> int: ...
        """Get the cardinality of this monoid.
        
        Returns:
            The cardinality (number of unary terms)
        """
        def name(self) -> str: ...
        """Get the name of this monoid.
        
        Returns:
            The name of the monoid
        """
        def set_name(self, name: str) -> None: ...
        """Set the name of this monoid.
        
        Args:
            name: The new name
        """
        def is_unary(self) -> bool: ...
        """Check if this algebra is unary.
        
        Returns:
            True if the algebra is unary, False otherwise
        """
        def is_idempotent(self) -> bool: ...
        """Check if this algebra is idempotent.
        
        Returns:
            True if the algebra is idempotent, False otherwise
        """
        def is_total(self) -> bool: ...
        """Check if this algebra is total.
        
        Returns:
            True if the algebra is total, False otherwise
        """
        def operations_count(self) -> int: ...
        """Get the number of operations.
        
        Returns:
            The number of operations (1 for the product operation)
        """
        def get_universe_list(self) -> List["util.IntArray"]: ...
        """Get the universe as a list of elements.
        
        Returns:
            List of IntArray elements representing the unary terms
        """
        def get_element(self, index: int) -> Optional["util.IntArray"]: ...
        """Get an element by its index.
        
        Args:
            index: The index of the element
            
        Returns:
            The element at the given index, or None if out of bounds
        """
        def element_index(self, element: "util.IntArray") -> Optional[int]: ...
        """Get the index of an element in the universe.
        
        Args:
            element: The element to find the index for
            
        Returns:
            The index of the element, or None if not found
        """
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
        def __len__(self) -> int: ...
        """Get the cardinality of the monoid (for use with len()).
        
        Returns:
            The cardinality of the monoid
        """
    
    class ParameterizedAlgebra: ...
    class MaltsevProductDecomposition: ...
    
    class MaltsevDecompositionIterator:
        """Python wrapper for MaltsevDecompositionIterator.
        
        An iterator over sections (quotients of subalgebras) of an idempotent algebra.
        This iterator is used in variety analysis to decompose algebras into their
        Maltsev decomposition components.
        """
        def __init__(self, algebra: "alg.BasicAlgebra") -> None: ...
        """Create a new MaltsevDecompositionIterator for an idempotent algebra.
        
        Args:
            algebra: An idempotent algebra to decompose
            
        Raises:
            ValueError: If the algebra is not idempotent
        """
        def has_next(self) -> bool: ...
        """Check if there are more elements in the iterator.
        
        Returns:
            True if there are more elements, False otherwise
        """
        def __iter__(self) -> "alg.MaltsevDecompositionIterator": ...
        """Python iterator protocol - returns self."""
        def __next__(self) -> Optional[Dict[str, int]]: ...
        """Python iterator protocol - get next element.
        
        Returns a dictionary with the algebra's cardinality (matching Java behavior).
        The dictionary has the form: {"cardinality": <int>}
        
        Returns:
            A dictionary with "cardinality" key containing the algebra's cardinality,
            or None if the iterator is exhausted
        """
        def remove(self) -> None: ...
        """Remove the last element (not supported).
        
        Raises:
            ValueError: Always raises this exception (UnsupportedOperationException)
        """
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class GeneralAlgebra: ...
    class Polymorphisms: ...
    class Subtrace: ...
    class TypeFinder: ...
    
    class Pool:
        """Python wrapper for Pool."""
        @staticmethod
        def fj_pool() -> str: ...
        @staticmethod
        def is_initialized() -> bool: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class Closer: ...
    class CloserTiming: ...

# ============================================================================
# UTIL MODULE (Partial - will be expanded)
# ============================================================================

class util:
    """Utility module for utility functions and classes."""
    
    class IntArray:
        """Python wrapper for IntArray."""
        def __init__(self, size: int) -> None: ...
        @staticmethod
        def from_array(array: List[int]) -> "util.IntArray": ...
        def size(self) -> int: ...
        def get(self, index: int) -> int: ...
        def set(self, index: int, value: int) -> None: ...
        def as_slice(self) -> List[int]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    class Horner: ...
    class SimpleList: ...
    class ArrayString: ...
    class PermutationGenerator: ...
    class ArrayIncrementorImpl: ...
    class SimpleArrayIncrementor: ...
    class IntTuples: ...
    class IntTuplesWithMin: ...
    class TupleWithMin: ...
    class FixedSizedSubsets: ...
    class Subsets: ...
    class Permutations: ...
    class LongListUtils: ...
    class SequenceGenerator: ...
    class NondecreasingSequenceIncrementor: ...
    class IncreasingSequenceIncrementor: ...
    class SequenceIncrementor: ...
    class LeftSequenceIncrementor: ...
    class PartitionArrayIncrementor: ...
    class VirtualLists: ...
