"""
Type stubs for uacalc_lib module.
This file provides type information for Python IDEs and type checkers.
"""

from typing import Any, List, Dict, Optional, Union, Tuple
from typing_extensions import Protocol

# Type aliases for common UACalc types
Element = Union[int, str, Tuple[Any, ...]]
Operation = Any  # TODO: Define proper Operation type
Algebra = Any    # TODO: Define proper Algebra type
Lattice = Any    # TODO: Define proper Lattice type

# Module-level exports
__version__: str
__author__: str
__license__: str

# ============================================================================
# ELEMENT MODULE
# ============================================================================

class element:
    """Element module - currently empty, trait-based implementations."""
    pass

# ============================================================================
# TYPES MODULE
# ============================================================================

class types:
    """Types module - currently empty."""
    pass

# ============================================================================
# EXAMPLE MODULE
# ============================================================================

class example:
    """Example module - currently empty."""
    pass

# ============================================================================
# TERMS MODULE
# ============================================================================

class terms:
    """Terms module for term structures and operations."""
    
    class VariableImp:
        """Python wrapper for VariableImp."""
        def __init__(self, name: str) -> None: ...
        @staticmethod
        def x() -> "terms.VariableImp": ...
        @staticmethod
        def y() -> "terms.VariableImp": ...
        @staticmethod
        def z() -> "terms.VariableImp": ...
        def get_name(self) -> str: ...
        def isa_variable(self) -> bool: ...
        def depth(self) -> int: ...
        def length(self) -> int: ...
        def get_variable_list(self) -> List[str]: ...
        def eval(self, algebra: "alg.BasicAlgebra", var_map: Dict[str, int]) -> int: ...
        def int_eval(self, algebra: "alg.BasicAlgebra", var_map: Dict[str, int]) -> int: ...
        def interpretation(
            self,
            algebra: "alg.BasicAlgebra",
            varlist: List[str],
            use_all: bool,
        ) -> "alg.IntOperation": ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
    
    class NonVariableTerm:
        """Python wrapper for NonVariableTerm."""
        def __init__(
            self,
            op_sym: "alg.OperationSymbol",
            children: List[Union["terms.VariableImp", "terms.NonVariableTerm"]],
        ) -> None: ...
        @staticmethod
        def make_constant_term(sym: "alg.OperationSymbol") -> "terms.NonVariableTerm": ...
        def isa_variable(self) -> bool: ...
        def depth(self) -> int: ...
        def length(self) -> int: ...
        def get_variable_list(self) -> List[str]: ...
        def eval(self, algebra: "alg.BasicAlgebra", var_map: Dict[str, int]) -> int: ...
        def int_eval(self, algebra: "alg.BasicAlgebra", var_map: Dict[str, int]) -> int: ...
        def interpretation(
            self,
            algebra: "alg.BasicAlgebra",
            varlist: List[str],
            use_all: bool,
        ) -> "alg.IntOperation": ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class Taylor:
        """Python wrapper for Taylor term analyzer."""
        def __init__(
            self,
            op_sym: "alg.OperationSymbol",
            inteqs: List[List["util.IntArray"]],
        ) -> None: ...
        @staticmethod
        def new_with_arity(
            arity: int,
            inteqs: List[List["util.IntArray"]],
        ) -> "terms.Taylor": ...
        @staticmethod
        def markovic_mckenzie_term() -> "terms.Taylor": ...
        @staticmethod
        def siggers_term() -> "terms.Taylor": ...
        def canonical_form(self, term: Union["terms.VariableImp", "terms.NonVariableTerm"]) -> Union["terms.VariableImp", "terms.NonVariableTerm"]: ...
        def term_from_array(self, arr: List[int]) -> Union["terms.VariableImp", "terms.NonVariableTerm"]: ...
        @staticmethod
        def lexicographically_compare_int_arrays(
            a: "util.IntArray",
            b: "util.IntArray",
        ) -> int: ...
        @staticmethod
        def lexicographically_compare_arrays(a: List[int], b: List[int]) -> int: ...
        def arity(self) -> int: ...
        def inteqs(self) -> List[List["util.IntArray"]]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class TermOperationImp:
        """Python wrapper for TermOperationImp."""
        def __init__(
            self,
            term: Union["terms.VariableImp", "terms.NonVariableTerm"],
            variables: List[Union["terms.VariableImp", str]],
            algebra: "alg.BasicAlgebra",
            name: Optional[str] = None,
        ) -> None: ...
        def get_term(self) -> str: ...
        def get_ordered_variables(self) -> List[str]: ...
        def arity(self) -> int: ...
        def get_set_size(self) -> int: ...
        def int_value_at(self, args: List[int]) -> int: ...
        def get_table(self) -> Optional[List[int]]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    @staticmethod
    def string_to_term(s: str) -> Union["terms.VariableImp", "terms.NonVariableTerm"]: ...
    @staticmethod
    def is_valid_var_string(s: str) -> bool: ...
    @staticmethod
    def is_valid_op_name_string(s: str) -> bool: ...
    @staticmethod
    def flatten(term: Union["terms.VariableImp", "terms.NonVariableTerm"]) -> Union["terms.VariableImp", "terms.NonVariableTerm"]: ...

# ============================================================================
# LATTICE MODULE
# ============================================================================

class lat:
    """Lattice module for lattice structures and operations."""
    
    class DivisibilityOrder:
        """Divisibility order for integers."""
        def __init__(self) -> None: ...
        def leq(self, a: int, b: int) -> bool: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class PrefixOrder:
        """Prefix order for strings."""
        def __init__(self) -> None: ...
        def leq(self, a: str, b: str) -> bool: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class NaturalOrder:
        """Natural order for various types."""
        def __init__(self) -> None: ...
        def leq_i32(self, a: int, b: int) -> bool: ...
        def leq_u32(self, a: int, b: int) -> bool: ...
        def leq_string(self, a: str, b: str) -> bool: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class DiamondLattice:
        """Diamond lattice implementation."""
        def __init__(self) -> None: ...
        def get_element(self, index: int) -> Optional[int]: ...
        def size(self) -> int: ...
        def universe(self) -> List[int]: ...
        def cardinality(self) -> int: ...
        def leq(self, a: int, b: int) -> bool: ...
        def join_irreducibles(self) -> Optional[List[int]]: ...
        def meet_irreducibles(self) -> Optional[List[int]]: ...
        def atoms(self) -> Optional[List[int]]: ...
        def coatoms(self) -> Optional[List[int]]: ...
        def join(self, a: int, b: int) -> int: ...
        def join_list(self, args: List[int]) -> int: ...
        def meet(self, a: int, b: int) -> int: ...
        def meet_list(self, args: List[int]) -> int: ...
        def upper_covers_indices(self, index: int) -> List[int]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class BooleanLattice:
        """Boolean lattice implementation."""
        def __init__(self) -> None: ...
        def get_element(self, index: int) -> Optional[int]: ...
        def size(self) -> int: ...
        def universe(self) -> List[int]: ...
        def cardinality(self) -> int: ...
        def leq(self, a: int, b: int) -> bool: ...
        def join_irreducibles(self) -> Optional[List[int]]: ...
        def meet_irreducibles(self) -> Optional[List[int]]: ...
        def atoms(self) -> Optional[List[int]]: ...
        def coatoms(self) -> Optional[List[int]]: ...
        def join(self, a: int, b: int) -> int: ...
        def join_list(self, args: List[int]) -> int: ...
        def meet(self, a: int, b: int) -> int: ...
        def meet_list(self, args: List[int]) -> int: ...
        def upper_covers_indices(self, index: int) -> List[int]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class MeetLattice:
        """Meet lattice implementation."""
        def name(self) -> str: ...
        def universe(self) -> List[int]: ...
        def join_irreducibles(self) -> List[int]: ...
        def meet_irreducibles(self) -> List[int]: ...
        def atoms(self) -> List[int]: ...
        def coatoms(self) -> List[int]: ...
        def join(self, a: int, b: int) -> int: ...
        def join_list(self, args: List[int]) -> int: ...
        def meet(self, a: int, b: int) -> int: ...
        def meet_list(self, args: List[int]) -> int: ...
        def leq(self, a: int, b: int) -> bool: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class JoinLattice:
        """Join lattice implementation."""
        def name(self) -> str: ...
        def universe(self) -> List[int]: ...
        def join_irreducibles(self) -> List[int]: ...
        def meet_irreducibles(self) -> List[int]: ...
        def atoms(self) -> List[int]: ...
        def coatoms(self) -> List[int]: ...
        def join(self, a: int, b: int) -> int: ...
        def join_list(self, args: List[int]) -> int: ...
        def meet(self, a: int, b: int) -> int: ...
        def meet_list(self, args: List[int]) -> int: ...
        def leq(self, a: int, b: int) -> bool: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    # Module-level functions
    @staticmethod
    def maximals_divisibility(elems: List[int]) -> List[int]: ...
    @staticmethod
    def maximals_prefix(elems: List[str]) -> List[str]: ...
    @staticmethod
    def maximals_natural_i32(elems: List[int]) -> List[int]: ...
    @staticmethod
    def maximals_natural_string(elems: List[str]) -> List[str]: ...
    @staticmethod
    def ordered_sets_main() -> str: ...
    @staticmethod
    def lattice_from_meet(name: str, meet: Any) -> "lat.MeetLattice": ...
    @staticmethod
    def lattice_from_join(name: str, join: Any) -> "lat.JoinLattice": ...
    @staticmethod
    def lattice_from_meet_with_universe(name: str, univ: List[int], meet: Any) -> "lat.MeetLattice": ...
    @staticmethod
    def lattice_from_join_with_universe(name: str, univ: List[int], join: Any) -> "lat.JoinLattice": ...
    @staticmethod
    def con_to_small_lattice(con: Any) -> Any: ...
    @staticmethod
    def dual(lat: Any) -> Any: ...
    # Internal function names (also exported for compatibility)
    @staticmethod
    def py_lattice_from_meet(name: str, meet: Any) -> "lat.MeetLattice": ...
    @staticmethod
    def py_lattice_from_join(name: str, join: Any) -> "lat.JoinLattice": ...
    @staticmethod
    def py_lattice_from_meet_with_universe(name: str, univ: List[int], meet: Any) -> "lat.MeetLattice": ...
    @staticmethod
    def py_lattice_from_join_with_universe(name: str, univ: List[int], join: Any) -> "lat.JoinLattice": ...
    @staticmethod
    def py_con_to_small_lattice(con: Any) -> Any: ...
    @staticmethod
    def py_dual(lat: Any) -> Any: ...

# ============================================================================
# IO MODULE
# ============================================================================

class io:
    """IO module for algebra file I/O operations."""
    
    class Mace4Reader:
        """Reader for Mace4 format algebra files."""
        @staticmethod
        def new_from_file(file_path: str) -> "io.Mace4Reader": ...
        @staticmethod
        def new_from_stream(data: List[int]) -> "io.Mace4Reader": ...
        @staticmethod
        def parse_algebra_from_file(file_path: str) -> Optional["alg.BasicAlgebra"]: ...
        def parse_algebra_from_stream(self, data: List[int]) -> Optional["alg.BasicAlgebra"]: ...
        @staticmethod
        def parse_algebra_list_from_file(file_path: str) -> Any: ...  # Returns iterator
        def parse_algebra_list_from_stream(self, data: List[int]) -> List["alg.BasicAlgebra"]: ...
        @staticmethod
        def is_ordinary_character(c: str) -> bool: ...
        @staticmethod
        def is_special_character(c: str) -> bool: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class AlgebraReader:
        """Reader for algebra files."""
        @staticmethod
        def new_from_file(file_path: str) -> "io.AlgebraReader": ...
        @staticmethod
        def new_from_stream(data: List[int]) -> "io.AlgebraReader": ...
        def read_algebra_file(self) -> Optional["alg.BasicAlgebra"]: ...
        @staticmethod
        def read_algebra_from_file(file_path: str) -> Optional["alg.BasicAlgebra"]: ...
        def read_algebra_from_stream(self, data: List[int]) -> Optional["alg.BasicAlgebra"]: ...
        def read_algebra_list_from_file(self, file_path: str) -> List["alg.BasicAlgebra"]: ...
        def read_algebra_list_from_stream(self, data: List[int]) -> List["alg.BasicAlgebra"]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class AlgebraWriter:
        """Writer for algebra files."""
        @staticmethod
        def new_with_file(algebra: "alg.BasicAlgebra", file_path: str) -> "io.AlgebraWriter": ...
        @staticmethod
        def new_with_writer(algebra: "alg.BasicAlgebra") -> "io.AlgebraWriter": ...
        @staticmethod
        def write_algebra_xml_to_file(algebra: "alg.BasicAlgebra", file_path: str) -> None: ...
        @staticmethod
        def write_algebra_to_file(algebra: "alg.BasicAlgebra", file_path: str) -> None: ...
        @staticmethod
        def write_basic_algebra_to_file(algebra: "alg.BasicAlgebra", file_path: str) -> None: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class BadAlgebraFileException:
        """Exception for bad algebra file format."""
        def __init__(self, message: str) -> None: ...
        @staticmethod
        def new_safe(message: str) -> "io.BadAlgebraFileException": ...
        def message(self) -> str: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
    
    class ExtFileFilter:
        """File filter based on extensions."""
        def __init__(self, description: str, exts: List[str]) -> None: ...
        @staticmethod
        def new_single(description: str, ext: str) -> "io.ExtFileFilter": ...
        @staticmethod
        def new_safe(description: str, exts: List[str]) -> "io.ExtFileFilter": ...
        @staticmethod
        def new_single_safe(description: str, ext: str) -> "io.ExtFileFilter": ...
        def accept(self, path: str) -> bool: ...
        def get_description(self) -> str: ...
        def get_extensions(self) -> List[str]: ...
        @staticmethod
        def split_off_extension(path: str) -> Tuple[Optional[str], Optional[str]]: ...
        @staticmethod
        def get_extension(path: str) -> Optional[str]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
    
    @staticmethod
    def parse_line(line: str) -> int: ...
    @staticmethod
    def read_algebra_file(path: str) -> "alg.BasicAlgebra": ...
    @staticmethod
    def read_algebra_from_stream(data: List[int]) -> "alg.BasicAlgebra": ...
    @staticmethod
    def read_algebra_list_file(path: str) -> List["alg.BasicAlgebra"]: ...
    @staticmethod
    def read_algebra_list_from_stream(data: List[int]) -> "alg.BasicAlgebra": ...
    @staticmethod
    def convert_to_xml(path: str) -> None: ...
    @staticmethod
    def write_algebra_file(algebra: "alg.BasicAlgebra", path: str) -> None: ...
    @staticmethod
    def write_algebra_file_with_style(algebra: "alg.BasicAlgebra", path: str, old_style: bool) -> None: ...
    @staticmethod
    def read_projective_plane(path: str) -> "alg.BasicAlgebra": ...
    @staticmethod
    def read_projective_plane_from_stream(data: List[int]) -> "alg.BasicAlgebra": ...

# ============================================================================
# EQUATION MODULE
# ============================================================================

class eq:
    """Equation module for equation handling."""
    
    class Equation:
        """Python wrapper for Equation."""
        def __init__(
            self,
            left: Union["terms.VariableImp", "terms.NonVariableTerm"],
            right: Union["terms.VariableImp", "terms.NonVariableTerm"],
            vars: Optional[List[str]] = None,
        ) -> None: ...
        def left_side(self) -> str: ...
        def right_side(self) -> str: ...
        def get_variable_list(self) -> List[str]: ...
        def get_operation_symbols(self) -> List[str]: ...
        def find_failure(self, algebra: "alg.BasicAlgebra") -> Optional[List[int]]: ...
        def find_failure_map(self, algebra: "alg.BasicAlgebra") -> Optional[Dict[str, int]]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class Presentation:
        """Python wrapper for Presentation."""
        def __init__(self, variables: List[str], relations: List["eq.Equation"]) -> None: ...
        def get_variables(self) -> List[str]: ...
        def get_relations(self) -> List[str]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    @staticmethod
    def associative_law(op_symbol: "alg.OperationSymbol") -> "eq.Equation": ...
    @staticmethod
    def cyclic_law(op_symbol: "alg.OperationSymbol") -> "eq.Equation": ...
    @staticmethod
    def first_second_symmetric_law(op_symbol: "alg.OperationSymbol") -> "eq.Equation": ...

# ============================================================================
# GROUP MODULE
# ============================================================================

class group:
    """Group module for group theory operations."""
    
    class PermutationGroup:
        """Python wrapper for PermutationGroup."""
        def __init__(self, name: str, generators: List[List[int]]) -> None: ...
        @staticmethod
        def new_with_universe(
            name: str,
            generators: List[List[int]],
            universe: List[List[int]],
        ) -> "group.PermutationGroup": ...
        @staticmethod
        def new_safe(name: str, generators: List[List[int]]) -> "group.PermutationGroup": ...
        @staticmethod
        def new_with_universe_safe(
            name: str,
            generators: List[List[int]],
            universe: List[List[int]],
        ) -> "group.PermutationGroup": ...
        @staticmethod
        def prod(p1: List[int], p2: List[int]) -> List[int]: ...
        @staticmethod
        def inv(p: List[int]) -> List[int]: ...
        @staticmethod
        def id(set_size: int) -> List[int]: ...
        def get_name(self) -> str: ...
        def get_generators(self) -> List[List[int]]: ...
        def get_universe_list(self) -> Optional[List[List[int]]]: ...
        def get_underlying_set_size(self) -> int: ...
        def get_identity(self) -> Optional[List[int]]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...

# ============================================================================
# FPLAT MODULE
# ============================================================================

class fplat:
    """Fplat module for partially defined lattices."""
    
    class PartiallyDefinedLattice:
        """Python wrapper for PartiallyDefinedLattice."""
        def __init__(
            self,
            name: str,
            joins: List[List["terms.VariableImp"]],
            meets: List[List["terms.VariableImp"]],
        ) -> None: ...
        def name(self) -> str: ...
        def get_defined_joins(self) -> List[List["terms.VariableImp"]]: ...
        def get_defined_meets(self) -> List[List["terms.VariableImp"]]: ...
        def leq(self, a: "terms.VariableImp", b: "terms.VariableImp") -> bool: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...

# ============================================================================
# ALG MODULE
# ============================================================================

class alg:
    """Algebra module - main algebra structures and operations."""
    
    class BasicAlgebra:
        """Python wrapper for BasicAlgebra."""
        def __init__(
            self,
            name: str,
            universe: List[int],
            operations: Optional[List[Any]] = None,
        ) -> None: ...
        @staticmethod
        def new_with_constant_op(name: str, universe: List[int]) -> "alg.BasicAlgebra": ...
        @staticmethod
        def from_general_algebra(general_algebra: "alg.GeneralAlgebra") -> "alg.BasicAlgebra": ...
        def name(self) -> str: ...
        def set_name(self, name: str) -> None: ...
        def description(self) -> Optional[str]: ...
        def set_description(self, desc: Optional[str]) -> None: ...
        def cardinality(self) -> int: ...
        def input_size(self) -> int: ...
        def is_unary(self) -> bool: ...
        def is_idempotent(self) -> bool: ...
        def is_total(self) -> bool: ...
        def monitoring(self) -> bool: ...
        def get_universe(self) -> List[int]: ...
        def algebra_type(self) -> str: ...
        def get_element(self, k: int) -> int: ...
        def element_index(self, elem: int) -> int: ...
        def get_universe_list(self) -> Optional[List[int]]: ...
        def get_universe_order(self) -> Optional[Dict[int, int]]: ...
        def int_universe(self) -> bool: ...
        def reset_con_and_sub(self) -> None: ...
        def convert_to_default_value_ops(self) -> None: ...
        def operations(self) -> List[Any]: ...
        def operations_count(self) -> int: ...
        def con(self) -> "alg.CongruenceLattice": ...
        def sub(self) -> "alg.SubalgebraLattice": ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
        def __eq__(self, other: object) -> bool: ...
    
    class BasicOperation:
        """Python wrapper for BasicOperation."""
        def __init__(
            self,
            symbol: "alg.OperationSymbol",
            set_size: int,
            table: Optional[List[int]] = None,
        ) -> None: ...
        @staticmethod
        def simple_binary_op(name: str, set_size: int) -> "alg.BasicOperation": ...
        @staticmethod
        def simple_unary_op(name: str, set_size: int) -> "alg.BasicOperation": ...
        @staticmethod
        def simple_nullary_op(name: str, set_size: int) -> "alg.BasicOperation": ...
        def arity(self) -> int: ...
        def get_set_size(self) -> int: ...
        def symbol(self) -> "alg.OperationSymbol": ...
        def value_at(self, args: List[int]) -> int: ...
        def get_table(self) -> Optional[List[int]]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class OperationSymbol:
        """Python wrapper for OperationSymbol."""
        def __init__(self, name: str, arity: int, associative: bool = False) -> None: ...
        def arity(self) -> int: ...
        def name(self) -> str: ...
        def is_associative(self) -> bool: ...
        def set_associative(self, assoc: bool) -> None: ...
        def to_string_with_arity(self, show_arity: Optional[bool] = None) -> str: ...
        @staticmethod
        def get_operation_symbol(arity: int) -> "alg.OperationSymbol": ...
        @staticmethod
        def join() -> "alg.OperationSymbol": ...
        @staticmethod
        def meet() -> "alg.OperationSymbol": ...
        @staticmethod
        def product() -> "alg.OperationSymbol": ...
        @staticmethod
        def inverse() -> "alg.OperationSymbol": ...
        @staticmethod
        def identity() -> "alg.OperationSymbol": ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
    
    class IntOperation:
        """Python wrapper for IntOperation."""
        def __init__(
            self,
            symbol: "alg.OperationSymbol",
            set_size: int,
            table: List[int],
        ) -> None: ...
        def arity(self) -> int: ...
        def get_set_size(self) -> int: ...
        def symbol(self) -> "alg.OperationSymbol": ...
        def int_value_at(self, args: List[int]) -> int: ...
        def get_table(self) -> Optional[List[int]]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class AbstractIntOperation:
        """Python wrapper for AbstractIntOperation."""
        def __init__(self, name: str, arity: int, alg_size: int) -> None: ...
        @staticmethod
        def with_symbol(symbol: "alg.OperationSymbol", alg_size: int) -> "alg.AbstractIntOperation": ...
        def arity(self) -> int: ...
        def get_set_size(self) -> int: ...
        def symbol(self) -> "alg.OperationSymbol": ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class AbstractOperation: ...
    
    class Operations: ...
    
    class OperationWithDefaultValue: ...
    
    class SimilarityType:
        """Python wrapper for SimilarityType."""
        def __init__(
            self,
            operation_symbols: List["alg.OperationSymbol"],
            sort: bool = False,
        ) -> None: ...
        def get_operation_symbols(self) -> List["alg.OperationSymbol"]: ...
        def get_sorted_operation_symbols(self) -> List["alg.OperationSymbol"]: ...
        def input_size(self, alg_size: int) -> int: ...
        def get_arities_map(self) -> Dict[int, int]: ...
        def get_max_arity(self) -> int: ...
        @staticmethod
        def lattice_similarity_type() -> "alg.SimilarityType": ...
        @staticmethod
        def group_similarity_type() -> "alg.SimilarityType": ...
        def arities_string(self) -> str: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
    
    class ParameterizedOperation: ...
    
    # Advanced algebra types
    class Homomorphism: ...
    class SubalgebraLattice: ...
    class BasicBinaryRelation: ...
    class CentralityData: ...
    class Partition: ...
    class PrintType: ...
    class CongruenceLattice: ...
    class BasicSet: ...
    class FreeAlgebra: ...
    class ProductAlgebra: ...
    class PowerAlgebra: ...
    class MatrixPowerAlgebra: ...
    class Subalgebra: ...
    class ReductAlgebra: ...
    class UnaryTermsMonoid: ...
    class ParameterizedAlgebra: ...
    class MaltsevProductDecomposition: ...
    class GeneralAlgebra: ...
    class Polymorphisms: ...
    class Subtrace: ...
    class TypeFinder: ...
    
    class Pool:
        """Python wrapper for Pool."""
        @staticmethod
        def fj_pool() -> str: ...
        @staticmethod
        def is_initialized() -> bool: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    
    class Closer: ...
    class CloserTiming: ...

# ============================================================================
# UTIL MODULE (Partial - will be expanded)
# ============================================================================

class util:
    """Utility module for utility functions and classes."""
    
    class IntArray:
        """Python wrapper for IntArray."""
        def __init__(self, size: int) -> None: ...
        @staticmethod
        def from_array(array: List[int]) -> "util.IntArray": ...
        def size(self) -> int: ...
        def get(self, index: int) -> int: ...
        def set(self, index: int, value: int) -> None: ...
        def as_slice(self) -> List[int]: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
    class Horner: ...
    class SimpleList: ...
    class ArrayString: ...
    class PermutationGenerator: ...
    class ArrayIncrementorImpl: ...
    class SimpleArrayIncrementor: ...
    class IntTuples: ...
    class IntTuplesWithMin: ...
    class TupleWithMin: ...
    class FixedSizedSubsets: ...
    class Subsets: ...
    class Permutations: ...
    class LongListUtils: ...
    class SequenceGenerator: ...
    class NondecreasingSequenceIncrementor: ...
    class IncreasingSequenceIncrementor: ...
    class SequenceIncrementor: ...
    class LeftSequenceIncrementor: ...
    class PartitionArrayIncrementor: ...
    class VirtualLists: ...
