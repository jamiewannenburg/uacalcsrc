import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.uacalc.alg.Algebra;
import org.uacalc.alg.conlat.CongruenceLattice;
import org.uacalc.alg.conlat.Partition;
import org.uacalc.alg.op.Operation;
import org.uacalc.io.AlgebraIO;
import org.uacalc.terms.Term;
import org.uacalc.terms.Terms;
import org.uacalc.terms.Variable;
import org.uacalc.terms.VariableImp;

/**
 * Java wrapper for UACalc functionality to enable comparison with Rust
 * implementation. Outputs results in JSON format.
 */
public class JavaWrapper {

    public static void main(String[] args) {
        if (args.length < 2) {
            System.err.println(
                    "Usage: JavaWrapper <operation> <ua_file> [args...]");
            System.err.println("Operations:");
            System.err.println(
                    "  properties <ua_file> - Print algebra properties");
            System.err.println(
                    "  cg <ua_file> <a> <b> - Print congruence generated by (a,b)");
            System.err.println(
                    "  lattice <ua_file> - Print congruence lattice properties");
            System.err.println(
                    "  parse_term <term_string> - Parse a term string");
            System.err.println(
                    "  create_variable <var_name> - Create a variable");
            System.err.println(
                    "  eval_term <term_string> <variables_json> - Evaluate a term");
            System.err.println(
                    "  validate_term <term_string> <ua_file> - Validate term against algebra");
            System.exit(1);
        }

        String operation = args[0];

        try {
            switch (operation) {
                case "properties":
                    if (args.length < 2) {
                        System.err.println(
                                "Usage: JavaWrapper properties <ua_file>");
                        System.exit(1);
                    }
                    outputProperties(args[1]);
                    break;
                case "cg":
                    if (args.length < 4) {
                        System.err.println(
                                "Usage: JavaWrapper cg <ua_file> <a> <b>");
                        System.exit(1);
                    }
                    int a = Integer.parseInt(args[2]);
                    int b = Integer.parseInt(args[3]);
                    outputCg(args[1], a, b);
                    break;
                case "lattice":
                    if (args.length < 2) {
                        System.err.println(
                                "Usage: JavaWrapper lattice <ua_file>");
                        System.exit(1);
                    }
                    outputLattice(args[1]);
                    break;
                case "parse_term":
                    if (args.length < 2) {
                        System.err.println(
                                "Usage: JavaWrapper parse_term <term_string>");
                        System.exit(1);
                    }
                    outputTermParse(args[1]);
                    break;
                case "create_variable":
                    if (args.length < 2) {
                        System.err.println(
                                "Usage: JavaWrapper create_variable <var_name>");
                        System.exit(1);
                    }
                    outputVariableCreate(args[1]);
                    break;
                case "eval_term":
                    if (args.length < 3) {
                        System.err.println(
                                "Usage: JavaWrapper eval_term <term_string> <variables_json>");
                        System.exit(1);
                    }
                    outputTermEval(args[1], args[2]);
                    break;
                case "validate_term":
                    if (args.length < 3) {
                        System.err.println(
                                "Usage: JavaWrapper validate_term <term_string> <ua_file>");
                        System.exit(1);
                    }
                    outputTermValidate(args[1], args[2]);
                    break;
                default:
                    System.err.println("Unknown operation: " + operation);
                    System.exit(1);
            }
        }
        catch (Exception e) {
            System.out.println("{\"error\":\""
                    + e.getMessage().replace("\"", "\\\"") + "\",\"type\":\""
                    + e.getClass().getSimpleName() + "\"}");
            System.exit(1);
        }
    }

    private static void outputProperties(String uaFile) throws Exception {
        long startMemory = getMemoryUsage();

        Algebra algebra = AlgebraIO.readAlgebraFile(uaFile);

        long endMemory = getMemoryUsage();

        StringBuilder result = new StringBuilder();
        result.append("{");
        result.append("\"name\":\"").append(algebra.getName()).append("\",");
        result.append("\"cardinality\":").append(algebra.cardinality())
                .append(",");
        result.append("\"operation_count\":")
                .append(algebra.operations().size()).append(",");

        // Operation symbols
        result.append("\"operation_symbols\":[");
        boolean first = true;
        for (Operation op : algebra.operations()) {
            if (!first) {
                result.append(",");
            }
            result.append("\"").append(op.symbol().toString()).append("\"");
            first = false;
        }
        result.append("],");

        // Operation arities
        result.append("\"operation_arities\":[");
        first = true;
        for (Operation op : algebra.operations()) {
            if (!first) {
                result.append(",");
            }
            result.append(op.arity());
            first = false;
        }
        result.append("]");
        result.append("}");

        System.out.println(result.toString());
    }

    private static void outputCg(String uaFile, int a, int b) throws Exception {
        long startMemory = getMemoryUsage();

        Algebra algebra = AlgebraIO.readAlgebraFile(uaFile);

        // Cast to SmallAlgebra since CongruenceLattice requires it
        org.uacalc.alg.SmallAlgebra smallAlgebra = (org.uacalc.alg.SmallAlgebra) algebra;
        CongruenceLattice conLat = new CongruenceLattice(smallAlgebra);

        Partition cg = conLat.Cg(a, b);

        long endMemory = getMemoryUsage();

        StringBuilder result = new StringBuilder();
        result.append("{");
        result.append("\"java_memory_mb\":")
                .append((endMemory - startMemory) / 1024.0 / 1024.0)
                .append(",");

        // Convert partition to list of blocks
        result.append("\"partition\":[");
        int[][] blocks = cg.getBlocks();
        for (int i = 0; i < blocks.length; i++) {
            if (i > 0) result.append(",");
            result.append("[");
            boolean first = true;
            for (int element : blocks[i]) {
                if (!first) result.append(",");
                result.append(element);
                first = false;
            }
            result.append("]");
        }
        result.append("]");
        result.append("}");

        System.out.println(result.toString());
    }

    private static void outputLattice(String uaFile) throws Exception {
        long startMemory = getMemoryUsage();

        Algebra algebra = AlgebraIO.readAlgebraFile(uaFile);

        // Cast to SmallAlgebra since CongruenceLattice requires it
        org.uacalc.alg.SmallAlgebra smallAlgebra = (org.uacalc.alg.SmallAlgebra) algebra;
        CongruenceLattice conLat = new CongruenceLattice(smallAlgebra);

        long endMemory = getMemoryUsage();

        StringBuilder result = new StringBuilder();
        result.append("{");
        result.append("\"size\":").append(conLat.cardinality()).append(",");
        result.append("\"join_irreducibles\":")
                .append(conLat.joinIrreducibles().size()).append(",");
        result.append("\"height\":").append(conLat.joinIrreducibles().size())
                .append(","); // Using join irreducibles as height approximation
        result.append("\"width\":").append(conLat.cardinality()).append(","); // Using
                                                                              // cardinality
                                                                              // as
                                                                              // width
                                                                              // approximation
        result.append("\"java_memory_mb\":")
                .append((endMemory - startMemory) / 1024.0 / 1024.0);
        result.append("}");

        System.out.println(result.toString());
    }

    private static void outputTermParse(String termString) throws Exception {
        try {
            Term term = Terms.stringToTerm(termString);

            StringBuilder result = new StringBuilder();
            result.append("{");
            result.append("\"success\":true,");
            result.append("\"is_variable\":").append(term.isaVariable())
                    .append(",");
            result.append("\"term_string\":\"").append(term.toString())
                    .append("\"");

            if (!term.isaVariable()) {
                result.append(",\"operation_symbol\":\"")
                        .append(term.leadingOperationSymbol().toString())
                        .append("\"");
                result.append(",\"arity\":")
                        .append(term.getChildren() != null
                                ? term.getChildren().size()
                                : 0);
            }

            result.append("}");
            System.out.println(result.toString());
        }
        catch (Exception e) {
            StringBuilder result = new StringBuilder();
            result.append("{");
            result.append("\"success\":false,");
            result.append("\"error\":\"")
                    .append(e.getMessage().replace("\"", "\\\"")).append("\"");
            result.append("}");
            System.out.println(result.toString());
        }
    }

    private static void outputVariableCreate(String varName) throws Exception {
        try {
            Variable variable = new VariableImp(varName);

            StringBuilder result = new StringBuilder();
            result.append("{");
            result.append("\"success\":true,");
            result.append("\"variable_name\":\"").append(variable.getName())
                    .append("\"");
            result.append("}");
            System.out.println(result.toString());
        }
        catch (Exception e) {
            StringBuilder result = new StringBuilder();
            result.append("{");
            result.append("\"success\":false,");
            result.append("\"error\":\"")
                    .append(e.getMessage().replace("\"", "\\\"")).append("\"");
            result.append("}");
            System.out.println(result.toString());
        }
    }

    private static void outputTermEval(String termString, String variablesJson)
            throws Exception {
        try {
            // Parse the term
            Term term = Terms.stringToTerm(termString);

            // Parse variables JSON
            // Simple JSON parsing for the format {"0":1,"1":2}
            Map<Variable, Integer> varMap = new HashMap<>();
            String json = variablesJson.trim();
            if (json.startsWith("{") && json.endsWith("}")) {
                String content = json.substring(1, json.length() - 1);
                String[] pairs = content.split(",");
                for (String pair : pairs) {
                    String[] keyValue = pair.split(":");
                    if (keyValue.length == 2) {
                        String key = keyValue[0].trim().replace("\"", "");
                        String value = keyValue[1].trim();
                        Variable var = new VariableImp("x" + key);
                        varMap.put(var, Integer.parseInt(value));
                    }
                }
            }

            // Create a simple algebra for evaluation
            org.uacalc.alg.SmallAlgebra algebra = createTestAlgebra();

            // Evaluate the term
            int result = term.intEval(algebra, varMap);

            StringBuilder resultJson = new StringBuilder();
            resultJson.append("{");
            resultJson.append("\"success\":true,");
            resultJson.append("\"result\":").append(result);
            resultJson.append("}");
            System.out.println(resultJson.toString());

        }
        catch (Exception e) {
            StringBuilder result = new StringBuilder();
            result.append("{");
            result.append("\"success\":false,");
            result.append("\"error\":\"")
                    .append(e.getMessage().replace("\"", "\\\"")).append("\"");
            result.append("}");
            System.out.println(result.toString());
        }
    }

    private static void outputTermValidate(String termString, String uaFile)
            throws Exception {
        try {
            // Parse the term
            Term term = Terms.stringToTerm(termString);

            // Load the algebra
            Algebra algebra = AlgebraIO.readAlgebraFile(uaFile);

            // Check if all operation symbols in the term exist in the algebra
            Set<String> algebraOps = new HashSet<>();
            for (Operation op : algebra.operations()) {
                algebraOps.add(op.symbol().toString());
            }

            Set<String> termOps = new HashSet<>();
            if (!term.isaVariable()) {
                collectOperationSymbols(term, termOps);
            }

            boolean isValid = true;
            String errorMessage = null;

            for (String opSymbol : termOps) {
                if (!algebraOps.contains(opSymbol)) {
                    isValid = false;
                    errorMessage = "Operation '" + opSymbol
                            + "' not found in algebra";
                    break;
                }
            }

            StringBuilder result = new StringBuilder();
            result.append("{");
            result.append("\"success\":true,");
            result.append("\"valid\":").append(isValid);
            if (!isValid) {
                result.append(",\"error\":\"")
                        .append(errorMessage.replace("\"", "\\\""))
                        .append("\"");
            }
            result.append("}");
            System.out.println(result.toString());

        }
        catch (Exception e) {
            StringBuilder result = new StringBuilder();
            result.append("{");
            result.append("\"success\":false,");
            result.append("\"error\":\"")
                    .append(e.getMessage().replace("\"", "\\\"")).append("\"");
            result.append("}");
            System.out.println(result.toString());
        }
    }

    private static void collectOperationSymbols(Term term,
            Set<String> symbols) {
        if (!term.isaVariable()) {
            symbols.add(term.leadingOperationSymbol().toString());
            if (term.getChildren() != null) {
                for (Term child : term.getChildren()) {
                    collectOperationSymbols(child, symbols);
                }
            }
        }
    }

    private static org.uacalc.alg.SmallAlgebra createTestAlgebra() {
        // Create a simple 3-element algebra with a binary operation
        int[][] table = { { 0, 1, 2 }, { 1, 1, 1 }, { 2, 1, 2 } };

        org.uacalc.alg.op.OperationSymbol symbol = new org.uacalc.alg.op.OperationSymbol(
                "f", 2);
        org.uacalc.alg.op.Operation op = org.uacalc.alg.op.Operations
                .makeBinaryIntOperation(symbol, 3, table);

        List<org.uacalc.alg.op.Operation> ops = new ArrayList<>();
        ops.add(op);

        org.uacalc.alg.SmallAlgebra algebra = new org.uacalc.alg.BasicAlgebra(
                "test", 3, ops);

        return algebra;
    }

    private static long getMemoryUsage() {
        Runtime runtime = Runtime.getRuntime();
        return runtime.totalMemory() - runtime.freeMemory();
    }
}
