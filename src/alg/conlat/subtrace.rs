/*! Subtrace implementation.

This module provides the Subtrace class which holds a subtrace {a, b} and its TCT type.
A subtrace represents a pair of elements in Tame Congruence Theory (TCT) analysis.

The implementation is based on the Java `org.uacalc.alg.conlat.Subtrace` class.
*/

use std::fmt;
use std::hash::{Hash, Hasher};
use crate::util::int_array::{IntArray, IntArrayTrait};

/// A subtrace represents a pair {a, b} with TCT type information.
/// 
/// This class holds data for Tame Congruence Theory (TCT) analysis, including
/// the subtrace elements, type classification, and associated universe data.
/// 
/// # Examples
/// ```
/// use uacalc::alg::conlat::Subtrace;
/// 
/// let subtrace = Subtrace::new(1, 2, true);
/// assert_eq!(subtrace.first(), 1);
/// assert_eq!(subtrace.second(), 2);
/// assert_eq!(subtrace.has_involution(), true);
/// ```
#[derive(Debug, Clone)]
pub struct Subtrace {
    /// First element of the subtrace pair
    a: i32,
    /// Second element of the subtrace pair  
    b: i32,
    /// TCT type classification (-1 if not set)
    type_value: i32,
    /// Whether this subtrace has involution
    has_involution: bool,
    /// Subuniverse of A^2 generated by diagonal and (a,b)
    subtrace_universe: Option<Vec<IntArray>>,
    /// Part of subuniverse of A^4 generated by diagonal and two 4-tuples
    matrix_universe: Option<Vec<IntArray>>,
}

impl Subtrace {
    /// Create a new Subtrace with given elements and involution flag.
    /// 
    /// # Arguments
    /// * `a` - First element of the subtrace pair
    /// * `b` - Second element of the subtrace pair
    /// * `has_involution` - Whether this subtrace has involution
    /// 
    /// # Returns
    /// A new Subtrace instance with type set to -1
    /// 
    /// # Examples
    /// ```
    /// use uacalc::alg::conlat::Subtrace;
    /// 
    /// let subtrace = Subtrace::new(0, 1, false);
    /// assert_eq!(subtrace.first(), 0);
    /// assert_eq!(subtrace.second(), 1);
    /// assert_eq!(subtrace.type_value(), -1);
    /// ```
    pub fn new(a: i32, b: i32, has_involution: bool) -> Self {
        Subtrace {
            a,
            b,
            type_value: -1,
            has_involution,
            subtrace_universe: None,
            matrix_universe: None,
        }
    }
    
    /// Create a new Subtrace with given elements, involution flag, and type.
    /// 
    /// # Arguments
    /// * `a` - First element of the subtrace pair
    /// * `b` - Second element of the subtrace pair
    /// * `has_involution` - Whether this subtrace has involution
    /// * `type_value` - TCT type classification
    /// 
    /// # Returns
    /// A new Subtrace instance with the specified type
    /// 
    /// # Examples
    /// ```
    /// use uacalc::alg::conlat::Subtrace;
    /// 
    /// let subtrace = Subtrace::new_with_type(0, 1, true, 2);
    /// assert_eq!(subtrace.first(), 0);
    /// assert_eq!(subtrace.second(), 1);
    /// assert_eq!(subtrace.type_value(), 2);
    /// assert_eq!(subtrace.has_involution(), true);
    /// ```
    pub fn new_with_type(a: i32, b: i32, has_involution: bool, type_value: i32) -> Self {
        Subtrace {
            a,
            b,
            type_value,
            has_involution,
            subtrace_universe: None,
            matrix_universe: None,
        }
    }
    
    /// Get the first element of the subtrace pair.
    /// 
    /// # Returns
    /// The first element `a`
    pub fn first(&self) -> i32 {
        self.a
    }
    
    /// Get the second element of the subtrace pair.
    /// 
    /// # Returns
    /// The second element `b`
    pub fn second(&self) -> i32 {
        self.b
    }
    
    /// Get the TCT type classification.
    /// 
    /// # Returns
    /// The type value (-1 if not set)
    pub fn type_value(&self) -> i32 {
        self.type_value
    }
    
    /// Check if this subtrace has involution.
    /// 
    /// # Returns
    /// `true` if the subtrace has involution, `false` otherwise
    pub fn has_involution(&self) -> bool {
        self.has_involution
    }
    
    /// Get the subtrace universe.
    /// 
    /// This is the subuniverse of A^2 generated by the diagonal and 
    /// a single pair (a,b), where {a,b} is a trace.
    /// 
    /// # Returns
    /// Reference to the subtrace universe if set, `None` otherwise
    pub fn get_subtrace_universe(&self) -> Option<&Vec<IntArray>> {
        self.subtrace_universe.as_ref()
    }
    
    /// Set the subtrace universe.
    /// 
    /// # Arguments
    /// * `universe` - The subtrace universe to set
    pub fn set_subtrace_universe(&mut self, universe: Vec<IntArray>) {
        self.subtrace_universe = Some(universe);
    }
    
    /// Get the matrix universe.
    /// 
    /// This is part of the subuniverse of A^4 generated by the diagonal and
    /// two 4-tuples, (a,a,b,b) and (a,b,a,b), where {a,b} is a trace.
    /// Only if the type is 1, 2, or 5 is this guaranteed to be the whole subuniverse.
    /// 
    /// # Returns
    /// Reference to the matrix universe if set, `None` otherwise
    pub fn get_matrix_universe(&self) -> Option<&Vec<IntArray>> {
        self.matrix_universe.as_ref()
    }
    
    /// Set the matrix universe.
    /// 
    /// # Arguments
    /// * `universe` - The matrix universe to set
    pub fn set_matrix_universe(&mut self, universe: Vec<IntArray>) {
        self.matrix_universe = Some(universe);
    }
    
    /// Set the TCT type classification.
    /// 
    /// # Arguments
    /// * `type_value` - The type to set
    pub fn set_type(&mut self, type_value: i32) {
        self.type_value = type_value;
    }
    
    /// Get a string representation in brief format.
    /// 
    /// # Arguments
    /// * `brief` - If `true`, returns brief format `[a, b]`, otherwise full format
    /// 
    /// # Returns
    /// String representation of the subtrace
    /// 
    /// # Examples
    /// ```
    /// use uacalc::alg::conlat::Subtrace;
    /// 
    /// let subtrace = Subtrace::new_with_type(1, 2, true, 3);
    /// assert_eq!(subtrace.to_string_brief(true), "[1, 2]");
    /// assert!(subtrace.to_string_brief(false).contains("subtrace [1, 2]"));
    /// ```
    pub fn to_string_brief(&self, brief: bool) -> String {
        if brief {
            format!("[{}, {}]", self.a, self.b)
        } else {
            self.to_string()
        }
    }
    
    /// Get a full string representation.
    /// 
    /// # Returns
    /// Full string representation including type and involution info
    pub fn to_string(&self) -> String {
        format!("subtrace [{}, {}] typ = {} inv: {}", 
                self.a, self.b, self.type_value, self.has_involution)
    }
}

impl fmt::Display for Subtrace {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.to_string())
    }
}

impl PartialEq for Subtrace {
    fn eq(&self, other: &Self) -> bool {
        self.a == other.a 
            && self.b == other.b 
            && self.type_value == other.type_value 
            && self.has_involution == other.has_involution
    }
}

impl Eq for Subtrace {}

impl Hash for Subtrace {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.a.hash(state);
        self.b.hash(state);
        self.type_value.hash(state);
        self.has_involution.hash(state);
    }
}

impl PartialOrd for Subtrace {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Subtrace {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        // Compare by (a, b, type, involution) lexicographically
        match self.a.cmp(&other.a) {
            std::cmp::Ordering::Equal => match self.b.cmp(&other.b) {
                std::cmp::Ordering::Equal => match self.type_value.cmp(&other.type_value) {
                    std::cmp::Ordering::Equal => self.has_involution.cmp(&other.has_involution),
                    other => other,
                },
                other => other,
            },
            other => other,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::util::int_array::IntArray;
    
    #[test]
    fn test_new() {
        let subtrace = Subtrace::new(1, 2, true);
        assert_eq!(subtrace.first(), 1);
        assert_eq!(subtrace.second(), 2);
        assert_eq!(subtrace.type_value(), -1);
        assert_eq!(subtrace.has_involution(), true);
        assert!(subtrace.get_subtrace_universe().is_none());
        assert!(subtrace.get_matrix_universe().is_none());
    }
    
    #[test]
    fn test_new_with_type() {
        let subtrace = Subtrace::new_with_type(0, 3, false, 5);
        assert_eq!(subtrace.first(), 0);
        assert_eq!(subtrace.second(), 3);
        assert_eq!(subtrace.type_value(), 5);
        assert_eq!(subtrace.has_involution(), false);
    }
    
    #[test]
    fn test_set_type() {
        let mut subtrace = Subtrace::new(1, 2, true);
        assert_eq!(subtrace.type_value(), -1);
        
        subtrace.set_type(3);
        assert_eq!(subtrace.type_value(), 3);
    }
    
    #[test]
    fn test_subtrace_universe() {
        let mut subtrace = Subtrace::new(1, 2, true);
        assert!(subtrace.get_subtrace_universe().is_none());
        
        let universe = vec![
            IntArray::from_array(vec![1, 1]).unwrap(),
            IntArray::from_array(vec![1, 2]).unwrap(),
            IntArray::from_array(vec![2, 2]).unwrap(),
        ];
        
        subtrace.set_subtrace_universe(universe.clone());
        assert!(subtrace.get_subtrace_universe().is_some());
        assert_eq!(subtrace.get_subtrace_universe().unwrap().len(), 3);
    }
    
    #[test]
    fn test_matrix_universe() {
        let mut subtrace = Subtrace::new(1, 2, true);
        assert!(subtrace.get_matrix_universe().is_none());
        
        let universe = vec![
            IntArray::from_array(vec![1, 1, 2, 2]).unwrap(),
            IntArray::from_array(vec![1, 2, 1, 2]).unwrap(),
        ];
        
        subtrace.set_matrix_universe(universe.clone());
        assert!(subtrace.get_matrix_universe().is_some());
        assert_eq!(subtrace.get_matrix_universe().unwrap().len(), 2);
    }
    
    #[test]
    fn test_to_string_brief() {
        let subtrace = Subtrace::new_with_type(1, 2, true, 3);
        
        assert_eq!(subtrace.to_string_brief(true), "[1, 2]");
        assert_eq!(subtrace.to_string_brief(false), "subtrace [1, 2] typ = 3 inv: true");
    }
    
    #[test]
    fn test_to_string() {
        let subtrace = Subtrace::new_with_type(0, 5, false, -1);
        assert_eq!(subtrace.to_string(), "subtrace [0, 5] typ = -1 inv: false");
    }
    
    #[test]
    fn test_display() {
        let subtrace = Subtrace::new_with_type(3, 4, true, 2);
        assert_eq!(format!("{}", subtrace), "subtrace [3, 4] typ = 2 inv: true");
    }
    
    #[test]
    fn test_equality() {
        let subtrace1 = Subtrace::new_with_type(1, 2, true, 3);
        let subtrace2 = Subtrace::new_with_type(1, 2, true, 3);
        let subtrace3 = Subtrace::new_with_type(1, 2, false, 3);
        let subtrace4 = Subtrace::new_with_type(1, 2, true, 4);
        
        assert_eq!(subtrace1, subtrace2);
        assert_ne!(subtrace1, subtrace3);
        assert_ne!(subtrace1, subtrace4);
    }
    
    #[test]
    fn test_ordering() {
        let subtrace1 = Subtrace::new_with_type(1, 2, true, 3);
        let subtrace2 = Subtrace::new_with_type(1, 3, true, 3);
        let subtrace3 = Subtrace::new_with_type(2, 2, true, 3);
        
        assert!(subtrace1 < subtrace2);
        assert!(subtrace1 < subtrace3);
        assert!(subtrace2 < subtrace3);
    }
    
    #[test]
    fn test_hash() {
        let subtrace1 = Subtrace::new_with_type(1, 2, true, 3);
        let subtrace2 = Subtrace::new_with_type(1, 2, true, 3);
        let subtrace3 = Subtrace::new_with_type(1, 2, false, 3);
        
        use std::collections::HashMap;
        let mut map = HashMap::new();
        map.insert(subtrace1, "first");
        map.insert(subtrace2.clone(), "second"); // Should overwrite first
        map.insert(subtrace3, "third");
        
        assert_eq!(map.len(), 2); // subtrace1 and subtrace2 are equal
        assert_eq!(map.get(&subtrace2), Some(&"second"));
    }
}
