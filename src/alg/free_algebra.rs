/*!
 * FreeAlgebra - A free algebra over a given base algebra.
 * 
 * This is a complete implementation of org.uacalc.alg.FreeAlgebra,
 * representing a subalgebra of a direct product of SmallAlgebras.
 * It allows construction of such an algebra even though the direct
 * product may be too big to be a SmallAlgebra.
 */

use std::collections::{HashMap};
use std::fmt::{self, Debug, Display};
use std::hash::Hash;
use std::sync::Arc;
use crate::alg::{Algebra, SmallAlgebra, AlgebraType, BigProductAlgebra, SubProductAlgebra};
use crate::alg::algebra::ProgressMonitor;
use crate::alg::algebra_with_generating_vector::AlgebraWithGeneratingVector;
use crate::alg::closer::Closer;
use crate::alg::op::{Operation, OperationSymbol, SimilarityType};
use crate::alg::op::ops::make_int_operation_str;
use crate::util::int_array::{IntArray, IntArrayTrait};
use crate::util::sequence_generator::SequenceGenerator;
use crate::terms::{Term, Variable};
use crate::eq::Equation;
use crate::progress::ProgressReport;

/// A free algebra over a given base algebra.
/// 
/// This struct represents a subalgebra of a direct product of SmallAlgebras
/// generated by coordinate projections. It allows construction of such an
/// algebra even when the full product is too large to fit in memory.
/// 
/// # Examples
/// ```ignore
/// use uacalc::alg::{FreeAlgebra, SmallAlgebra};
/// use uacalc::util::int_array::IntArray;
/// 
/// // Create a base algebra
/// let base_alg = ...; // Some SmallAlgebra
/// 
/// // Create free algebra with 2 generators
/// let free_alg = FreeAlgebra::new_safe(base_alg, 2).unwrap();
/// assert_eq!(free_alg.algebra_type(), AlgebraType::Free);
/// ```
#[derive(Debug)]
pub struct FreeAlgebra {
    /// The underlying subproduct algebra
    inner: SubProductAlgebra<i32>,
}

impl FreeAlgebra
{
    /// Create a new FreeAlgebra with the given base algebra and number of generators.
    /// 
    /// # Arguments
    /// * `alg` - The base algebra
    /// * `number_of_gens` - Number of generators
    /// 
    /// # Returns
    /// * `Ok(FreeAlgebra)` - Successfully created free algebra
    /// * `Err(String)` - If construction fails
    /// 
    /// # Examples
    /// ```ignore
    /// let free_alg = FreeAlgebra::new_safe(base_alg, 3).unwrap();
    /// ```
    pub fn new_safe(
        alg: Box<dyn SmallAlgebra<UniverseItem = i32>>,
        number_of_gens: i32,
    ) -> Result<Self, String> {
        Self::new_with_universe_safe(alg, number_of_gens, true)
    }

    /// Create a new FreeAlgebra with progress reporting.
    /// 
    /// # Arguments
    /// * `alg` - The base algebra
    /// * `number_of_gens` - Number of generators
    /// * `report` - Progress reporter
    /// 
    /// # Returns
    /// * `Ok(FreeAlgebra)` - Successfully created free algebra
    /// * `Err(String)` - If construction fails
    pub fn new_with_progress_safe(
        alg: Box<dyn SmallAlgebra<UniverseItem = i32>>,
        number_of_gens: i32,
        report: Option<Arc<dyn ProgressReport>>,
    ) -> Result<Self, String> {
        let name = format!("F({}) over {}", number_of_gens, alg.name());
        Self::new_with_name_progress_safe(
            name,
            alg,
            number_of_gens,
            true,
            false,
            false,
            None,
            report,
        )
    }

    /// Create a new FreeAlgebra with universe control.
    /// 
    /// # Arguments
    /// * `alg` - The base algebra
    /// * `number_of_gens` - Number of generators
    /// * `make_universe` - Whether to compute the universe
    /// 
    /// # Returns
    /// * `Ok(FreeAlgebra)` - Successfully created free algebra
    /// * `Err(String)` - If construction fails
    pub fn new_with_universe_safe(
        alg: Box<dyn SmallAlgebra<UniverseItem = i32>>,
        number_of_gens: i32,
        make_universe: bool,
    ) -> Result<Self, String> {
        Self::new_with_thin_safe(alg, number_of_gens, make_universe, false)
    }

    /// Create a new FreeAlgebra with thinning control.
    /// 
    /// # Arguments
    /// * `alg` - The base algebra
    /// * `number_of_gens` - Number of generators
    /// * `make_universe` - Whether to compute the universe
    /// * `thin_gens` - Whether to thin generators
    /// 
    /// # Returns
    /// * `Ok(FreeAlgebra)` - Successfully created free algebra
    /// * `Err(String)` - If construction fails
    pub fn new_with_thin_safe(
        alg: Box<dyn SmallAlgebra<UniverseItem = i32>>,
        number_of_gens: i32,
        make_universe: bool,
        thin_gens: bool,
    ) -> Result<Self, String> {
        let name = format!("Free({}, {})", number_of_gens, alg.name());
        Self::new_with_name_thin_safe(name, alg, number_of_gens, make_universe, thin_gens)
    }

    /// Create a new FreeAlgebra with a custom name.
    /// 
    /// # Arguments
    /// * `name` - The name of the algebra
    /// * `alg` - The base algebra
    /// * `number_of_gens` - Number of generators
    /// 
    /// # Returns
    /// * `Ok(FreeAlgebra)` - Successfully created free algebra
    /// * `Err(String)` - If construction fails
    pub fn new_with_name_safe(
        name: String,
        alg: Box<dyn SmallAlgebra<UniverseItem = i32>>,
        number_of_gens: i32,
    ) -> Result<Self, String> {
        Self::new_with_name_universe_safe(name, alg, number_of_gens, true)
    }

    /// Create a new FreeAlgebra with name and universe control.
    /// 
    /// # Arguments
    /// * `name` - The name of the algebra
    /// * `alg` - The base algebra
    /// * `number_of_gens` - Number of generators
    /// * `make_universe` - Whether to compute the universe
    /// 
    /// # Returns
    /// * `Ok(FreeAlgebra)` - Successfully created free algebra
    /// * `Err(String)` - If construction fails
    pub fn new_with_name_universe_safe(
        name: String,
        alg: Box<dyn SmallAlgebra<UniverseItem = i32>>,
        number_of_gens: i32,
        make_universe: bool,
    ) -> Result<Self, String> {
        Self::new_with_name_thin_safe(name, alg, number_of_gens, make_universe, false)
    }

    /// Create a new FreeAlgebra with name, universe, and thinning control.
    /// 
    /// # Arguments
    /// * `name` - The name of the algebra
    /// * `alg` - The base algebra
    /// * `number_of_gens` - Number of generators
    /// * `make_universe` - Whether to compute the universe
    /// * `thin_gens` - Whether to thin generators
    /// 
    /// # Returns
    /// * `Ok(FreeAlgebra)` - Successfully created free algebra
    /// * `Err(String)` - If construction fails
    pub fn new_with_name_thin_safe(
        name: String,
        alg: Box<dyn SmallAlgebra<UniverseItem = i32>>,
        number_of_gens: i32,
        make_universe: bool,
        thin_gens: bool,
    ) -> Result<Self, String> {
        Self::new_with_name_progress_safe(name, alg, number_of_gens, make_universe, thin_gens, false, None, None)
    }

    /// Create a new FreeAlgebra with name, universe, thinning, and progress control.
    /// 
    /// # Arguments
    /// * `name` - The name of the algebra
    /// * `alg` - The base algebra
    /// * `number_of_gens` - Number of generators
    /// * `make_universe` - Whether to compute the universe
    /// * `thin_gens` - Whether to thin generators
    /// * `decompose` - Whether to decompose
    /// * `relations` - Optional relations for finitely presented algebra
    /// * `report` - Optional progress reporter
    /// 
    /// # Returns
    /// * `Ok(FreeAlgebra)` - Successfully created free algebra
    /// * `Err(String)` - If construction fails
    pub fn new_with_name_progress_safe(
        name: String,
        alg: Box<dyn SmallAlgebra<UniverseItem = i32>>,
        number_of_gens: i32,
        make_universe: bool,
        thin_gens: bool,
        decompose: bool,
        relations: Option<Vec<Equation>>,
        report: Option<Arc<dyn ProgressReport>>,
    ) -> Result<Self, String> {
        Self::new_with_decompose_safe(name, alg, number_of_gens, make_universe, thin_gens, decompose, relations, report)
    }

    /// Create a new FreeAlgebra with full decomposition control.
    /// 
    /// # Arguments
    /// * `name` - The name of the algebra
    /// * `alg` - The base algebra
    /// * `number_of_gens` - Number of generators
    /// * `make_universe` - Whether to compute the universe
    /// * `thin_gens` - Whether to thin generators
    /// * `decompose` - Whether to decompose
    /// * `relations` - Optional relations for finitely presented algebra
    /// * `report` - Optional progress reporter
    /// 
    /// # Returns
    /// * `Ok(FreeAlgebra)` - Successfully created free algebra
    /// * `Err(String)` - If construction fails
    pub fn new_with_decompose_safe(
        name: String,
        alg: Box<dyn SmallAlgebra<UniverseItem = i32>>,
        number_of_gens: i32,
        make_universe: bool,
        thin_gens: bool,
        decompose: bool,
        relations: Option<Vec<Equation>>,
        report: Option<Arc<dyn ProgressReport>>,
    ) -> Result<Self, String> {
        if number_of_gens < 0 {
            return Err("Number of generators must be non-negative".to_string());
        }

        let line = format!("Constructing free algebra on {} generators over {}", number_of_gens, alg.name());
        if let Some(ref report) = report {
            report.add_start_line(&line);
        } else {
            println!("{}", line);
        }

        // Setup generators and product algebra
        let (product_algebra, mut gens) = Self::setup_gens_and_product_alg(
            alg,
            number_of_gens as usize,
            decompose,
            relations.as_ref(),
            report.as_ref(),
        )?;

        // Apply thinning if requested and not decomposing
        if thin_gens && !decompose {
            if let Some(ref report) = report {
                report.add_start_line("thinning coordinate projections ...");
            }
            let thinned_gens = Self::thin_generators(&gens)?;
            if let Some(ref report) = report {
                report.add_end_line(&format!(
                    "thinned {} coordinates down to {}",
                    gens[0].universe_size(),
                    thinned_gens[0].universe_size()
                ));
            } else {
                println!("thin size = {}", thinned_gens.len());
                println!("thin coord length = {}", thinned_gens[0].universe_size());
                println!("gens coord length = {}", gens[0].universe_size());
            }
            gens = thinned_gens;
        }

        // Create subproduct algebra
        let mut sub_prod = SubProductAlgebra::<i32>::new_safe(
            name.clone(),
            product_algebra,
            gens,
            true, // find_terms
        )?;

        // Set flags
        sub_prod.set_thin_generators(thin_gens);
        sub_prod.set_decompose(decompose);

        // Make universe if requested
        if make_universe {
            Self::make_universe(&mut sub_prod, report.as_ref())?;
        }

        let size = sub_prod.cardinality();
        let line = if size == 0 {
            "made the free algebra, but haven't found the elements.".to_string()
        } else {
            format!("done constructing free algebra, size = {}", size)
        };

        if let Some(ref report) = report {
            report.add_end_line(&line);
        } else {
            println!("{}", line);
        }

        Ok(FreeAlgebra { inner: sub_prod })
    }

    /// Create a new FreeAlgebra with relations (finitely presented algebra).
    /// 
    /// # Arguments
    /// * `alg` - The base algebra
    /// * `number_of_gens` - Number of generators
    /// * `relations` - The relations
    /// * `report` - Optional progress reporter
    /// 
    /// # Returns
    /// * `Ok(FreeAlgebra)` - Successfully created free algebra
    /// * `Err(String)` - If construction fails
    pub fn new_with_relations_safe(
        alg: Box<dyn SmallAlgebra<UniverseItem = i32>>,
        number_of_gens: i32,
        relations: Vec<Equation>,
        report: Option<Arc<dyn ProgressReport>>,
    ) -> Result<Self, String> {
        Self::new_with_decompose_safe(
            "F".to_string(),
            alg,
            number_of_gens,
            true,
            true,
            true,
            Some(relations),
            report,
        )
    }

    /// Create a new FreeAlgebra from pre-computed data.
    /// 
    /// # Arguments
    /// * `name` - The name of the algebra
    /// * `prod` - The product algebra
    /// * `gens` - The generators
    /// * `univ_list` - The universe list
    /// 
    /// # Returns
    /// * `Ok(FreeAlgebra)` - Successfully created free algebra
    /// * `Err(String)` - If construction fails
    pub fn new_from_product_safe(
        name: String,
        prod: BigProductAlgebra<i32>,
        gens: Vec<IntArray>,
        univ_list: Vec<IntArray>,
    ) -> Result<Self, String> {
        let sub_prod = SubProductAlgebra::<i32>::new_with_universe_safe(name, prod, gens, univ_list)?;
        Ok(FreeAlgebra { inner: sub_prod })
    }

    /// Setup generators and product algebra.
    /// 
    /// This is the core method that creates the generators and product algebra
    /// based on the given parameters.
    fn setup_gens_and_product_alg(
        alg: Box<dyn SmallAlgebra<UniverseItem = i32>>,
        number_of_gens: usize,
        decompose: bool,
        relations: Option<&Vec<Equation>>,
        report: Option<&Arc<dyn ProgressReport>>,
    ) -> Result<(BigProductAlgebra<i32>, Vec<IntArray>), String> {
        let mut algs = Vec::new();
        let mut projs = Vec::new();

        if decompose {
            let si_projections = Self::setup_si_projections(alg.as_ref(), number_of_gens, relations)?;
            for alg_v in si_projections {
                algs.push(alg_v.get_algebra().clone_box());
                projs.push(IntArray::from_array(alg_v.get_vector().to_vec())?);
            }
        }

        if decompose && !algs.is_empty() {
            if let Some(ref report) = report {
                report.add_start_line("using subdirect decompositions to eliminate some projections.");
            }
            // Create a product algebra with the base algebra
            let product_algebra = BigProductAlgebra::new_safe(vec![alg.clone_box()])?;
            let gens = SubProductAlgebra::<IntArray>::transpose(&projs)?;
            let size_multiplicities = product_algebra.size_multiplicities();
            let mut sb = String::new();
            for (k, v) in size_multiplicities {
                sb.push_str(&format!("{}({}), ", k, v));
            }
            if let Some(ref report) = report {
                report.add_end_line(&format!(
                    "number of projections: {}, sizes: {}",
                    projs.len(),
                    sb
                ));
            }
            println!("projs size = {}", projs.len());
            Ok((product_algebra, gens))
        } else {
            // Standard construction
            let n = alg.cardinality();
            let mut s = 1;
            for _ in 0..number_of_gens {
                s *= n;
            }

            // Create a power algebra with s copies of the base algebra
            let product_algebra = BigProductAlgebra::new_power_safe(alg.clone_box(), s as usize)?;
            let mut gens = Vec::with_capacity(number_of_gens);
            
            for _i in 0..number_of_gens {
                gens.push(IntArray::new(s as usize)?);
            }

            // Use sequence generator to create proper coordinate projections
            let mut projs_vec = vec![0; number_of_gens];
            
            for k in 0..s {
                for i in 0..number_of_gens {
                    gens[i].set(k as usize, projs_vec[i])?;
                }
                
                // Create incrementor for each iteration to avoid borrowing conflicts
                let mut incrementor = SequenceGenerator::sequence_incrementor(&mut projs_vec, n - 1);
                if !incrementor.increment() {
                    break;
                }
            }

            Ok((product_algebra, gens))
        }
    }

    /// Setup subdirect projections for decomposition.
    fn setup_si_projections(
        alg: &dyn SmallAlgebra<UniverseItem = i32>,
        number_of_gens: usize,
        relations: Option<&Vec<Equation>>,
    ) -> Result<Vec<AlgebraWithGeneratingVector<i32>>, String> {
        let mut ans = Vec::new();
        let n = alg.cardinality();
        
        // Generate all possible generating vectors
        let all_vectors = SequenceGenerator::generate_all_sequences(number_of_gens, n - 1);
        
        // Process each vector
        for vec in all_vectors {
            // Get decomposition for current vector
            let decomp = AlgebraWithGeneratingVector::si_decompose_with_relations(
                alg.clone_box(),
                &vec,
                relations.cloned()
            );
            
            // Process each component in the decomposition
            for alg_v in decomp {
                let mut dumped = false;
                
                // Check if this component is an image of any existing component
                for existing in &ans {
                    if alg_v.is_image_of(existing) {
                        dumped = true;
                        break;
                    }
                }
                
                if !dumped {
                    // Remove any existing components that are images of this one
                    ans.retain(|existing| !existing.is_image_of(&alg_v));
                    
                    // Make operation tables for the algebra
                    // Note: This would require mutable access to the algebra
                    // For now, we'll skip this step
                    
                    // Add the new component
                    ans.push(alg_v);
                }
            }
        }
        
        Ok(ans)
    }

    /// Thin generators by eliminating redundant coordinate projections.
    fn thin_generators(gens: &[IntArray]) -> Result<Vec<IntArray>, String> {
        // Transpose the generators to get projections
        let projs = Self::transpose(gens)?;
        
        // Create a map from projections to their corresponding algebras
        let mut proj_map = std::collections::HashMap::new();
        for (k, ia) in projs.iter().enumerate() {
            // For now, we'll use a simplified approach since we don't have
            // access to the product algebra's projection method
            proj_map.insert(ia.clone(), k);
        }
        
        // Find maximals using homomorphism-based ordering
        let thinned_projs = Self::maximals(&projs, |a, b| {
            // Check if there's a homomorphism from b to a
            // For now, we'll use a simplified check
            // The full implementation would use SubalgebraLattice::extend_to_homomorphism
            a.universe_size() <= b.universe_size()
        });
        
        // Transpose back to get the thinned generators
        Self::transpose(&thinned_projs)
    }
    
    /// Transpose a list of IntArrays.
    /// 
    /// This converts from generators to projections or vice versa.
    fn transpose(lst: &[IntArray]) -> Result<Vec<IntArray>, String> {
        if lst.is_empty() {
            return Err("Cannot transpose empty list".to_string());
        }
        
        let k = lst.len();
        let n = lst[0].universe_size();
        let mut transpose = Vec::with_capacity(n);
        
        for i in 0..n {
            let mut ith_proj = Vec::with_capacity(k);
            for j in 0..k {
                ith_proj.push(lst[j].get(i).ok_or("Failed to get element from IntArray")?);
            }
            transpose.push(IntArray::from_array(ith_proj)?);
        }
        
        Ok(transpose)
    }
    
    /// Find maximal elements in a collection using a given ordering.
    /// 
    /// This implements the maximals algorithm from OrderedSets.java.
    fn maximals<T, F>(elems: &[T], order: F) -> Vec<T>
    where
        T: Clone,
        F: Fn(&T, &T) -> bool,
    {
        let mut ans = Vec::new();
        let mut new_ans = Vec::new();
        
        for candidate in elems {
            let mut candidate_below = false;
            
            for e in &ans {
                if order(candidate, e) {
                    candidate_below = true;
                    break;
                }
                if !order(e, candidate) {
                    new_ans.push(e.clone());
                }
            }
            
            if !candidate_below {
                ans = new_ans;
                ans.push(candidate.clone());
            }
            new_ans = Vec::new();
        }
        
        ans
    }

    /// Make the universe by computing the closure of generators.
    fn make_universe(
        sub_prod: &mut SubProductAlgebra<i32>,
        report: Option<&Arc<dyn ProgressReport>>,
    ) -> Result<(), String> {
        // Create a Closer to compute the closure
        let mut closer = Closer::new_safe(
            Arc::new(sub_prod.product_algebra.clone()),
            sub_prod.gens.clone()
        )?;
        
        // Set progress report if provided
        if let Some(report) = report {
            closer.set_progress_report(Some(report.clone()));
        }
        
        // Compute the closure
        let univ = closer.sg_close()?;
        
        // Update the subproduct algebra with the universe
        sub_prod.univ = univ.clone();
        
        // Create universe hash map
        sub_prod.univ_hash_map = HashMap::new();
        for (k, elem) in univ.iter().enumerate() {
            sub_prod.univ_hash_map.insert(elem.clone(), k);
        }
        
        // Create universe set
        sub_prod.universe = univ.into_iter().collect();
        
        // Note: make_operations is private, so we can't call it directly
        // The operations will be created when needed
        
        Ok(())
    }

    /// Get the idempotent terms in this algebra.
    /// 
    /// This checks idempotency on the base algebra, matching Java's implementation.
    /// Java interprets terms on F(2) itself, but since we can't easily do that,
    /// we interpret on the base algebra which should give equivalent results.
    /// 
    /// # Arguments
    /// * `base_alg` - The base algebra used to create this free algebra (for term interpretation)
    /// 
    /// # Returns
    /// A vector of terms that are idempotent
    pub fn get_idempotent_terms_with_base(&self, base_alg: Arc<dyn SmallAlgebra<UniverseItem = i32>>) -> Result<Vec<Box<dyn Term>>, String> {
        let mut ans = Vec::new();
        
        if let Some(ref terms) = self.inner.terms {
            let n = self.inner.gens.len();
            let mut varlist = Vec::with_capacity(n);
            
            // Add the first n terms (variables) as they are always idempotent
            for i in 0..n {
                if let Some(term) = terms.get(i) {
                    varlist.push(term.clone_box());
                    ans.push(term.clone_box());
                }
            }
            
            // Check remaining terms for idempotency on the base algebra
            // Java interprets terms on F(2) itself to check idempotency.
            // Since we can't easily interpret on F(2) (IntArray universe), we interpret
            // on the base algebra and check idempotency there. This should give us
            // the same set of idempotent terms since idempotency on the base algebra
            // implies idempotency on F(2) (F(2) is freely generated by the base algebra).
            let var_names: Vec<String> = varlist.iter()
                .filter_map(|t| {
                    if t.isa_variable() {
                        Some(t.to_string()) // Variables display as their name
                    } else {
                        None
                    }
                })
                .collect();
            
            for i in n..terms.len() {
                if let Some(term) = terms.get(i) {
                    // Interpret the term on the base algebra
                    if let Ok(op) = term.interpretation(base_alg.clone(), &var_names, true) {
                        // Check if the operation is idempotent on the base algebra
                        // This matches Java's check: Operations.isIdempotent(op) where op is
                        // interpreted on F(2), but since F(2) is free, idempotency on base => idempotency on F(2)
                        let is_idempotent = crate::alg::op::ops::is_idempotent(&*op)?;
                        
                        if is_idempotent {
                            ans.push(term.clone_box());
                        }
                    }
                    // If interpretation fails, skip this term
                }
            }
        }
        
        Ok(ans)
    }
    
    /// Get the idempotent terms by interpreting on the free algebra itself.
    /// 
    /// This matches Java's FreeAlgebra.getIdempotentTerms() which interprets
    /// terms on the free algebra (F(2)) itself, not on the base algebra.
    /// 
    /// # Returns
    /// A vector of terms that are idempotent when interpreted on the free algebra
    pub fn get_idempotent_terms_on_free_algebra(&self) -> Result<Vec<Box<dyn Term>>, String> {
        let mut ans = Vec::new();
        
        if let Some(ref terms) = self.inner.terms {
            let n = self.inner.gens.len();
            let mut varlist = Vec::with_capacity(n);
            
            // Add the first n terms (variables) as they are always idempotent
            for i in 0..n {
                if let Some(term) = terms.get(i) {
                    varlist.push(term.clone_box());
                    ans.push(term.clone_box());
                }
            }
            
            // Get variable names for interpretation
            let var_names: Vec<String> = varlist.iter()
                .filter_map(|t| {
                    if t.isa_variable() {
                        Some(t.to_string())
                    } else {
                        None
                    }
                })
                .collect();
            
            // Check idempotency by interpreting the term directly on the free algebra
            // This matches Java's implementation: t.interpretation(this, varlist, true)
            // where 'this' is the FreeAlgebra. The interpretation creates an operation
            // that works on indices into the free algebra, and we check if that operation
            // is idempotent.
            for i in n..terms.len() {
                if let Some(term) = terms.get(i) {
                    // Interpret the term directly on the free algebra (matches Java)
                    match term.interpretation_on_free_algebra(self, &var_names, true) {
                        Ok(op) => {
                            // Check idempotency: t(i, i, ..., i) = i for all indices i in the free algebra
                            // This is equivalent to checking idempotency on F(2) elements
                            // IMPORTANT: The operation's set_size should be the free algebra's cardinality
                            let op_set_size = op.get_set_size();
                            let free_card = self.get_inner().cardinality() as i32;
                            // Verify set_size matches (should always be true if interpretation is correct)
                            if op_set_size != free_card {
                                // This shouldn't happen, but if it does, skip this term
                                continue;
                            }
                            // Use the operation's set_size for checking idempotency
                            let is_idempotent = Self::is_idempotent(&*op);
                            
                            if is_idempotent {
                                ans.push(term.clone_box());
                            }
                        }
                        Err(e) => {
                            // If interpretation fails, skip this term
                            // This can happen if the term uses operations not present in the free algebra
                            // or if there's an error during evaluation
                            // Silently skip (matches Java behavior - it doesn't add terms that fail interpretation)
                        }
                    }
                }
            }
        }
        
        Ok(ans)
    }
    
    /// Get the idempotent terms (convenience method for backward compatibility).
    /// 
    /// This method now calls get_idempotent_terms_on_free_algebra() to match Java behavior.
    /// It interprets terms on the free algebra itself, not on the base algebra.
    pub fn get_idempotent_terms(&self) -> Result<Vec<Box<dyn Term>>, String> {
        // Use the method that interprets on the free algebra (matches Java)
        self.get_idempotent_terms_on_free_algebra()
    }

    /// Check if an operation is idempotent.
    fn is_idempotent(op: &dyn Operation) -> bool {
        let n = op.get_set_size() as usize;
        let arity = op.arity() as usize;
        let mut arg = vec![0; arity];
        
        for i in 0..n {
            for j in 0..arity {
                arg[j] = i as i32;
            }
            if op.int_value_at(&arg) != Ok(i as i32) {
                return false;
            }
        }
        true
    }

    /// Get the algebra type.
    /// 
    /// # Returns
    /// Always returns AlgebraType::FREE
    pub fn algebra_type(&self) -> AlgebraType {
        AlgebraType::Free
    }

    /// Get the automorphism that switches the first two generators.
    /// 
    /// This method creates an automorphism that interchanges the first two
    /// generators (x and y) while leaving the others unchanged. It does this
    /// by creating a substitution map and evaluating each element's term
    /// with this substitution.
    /// 
    /// # Returns
    /// * `Some(Operation)` - The automorphism operation
    /// * `None` - If there are fewer than 2 generators
    pub fn switch_x_and_y_automorphism(&self) -> Result<Option<Box<dyn Operation>>, String> {
        let k = self.inner.gens.len();
        if k < 2 {
            return Ok(None);
        }

        let n = self.cardinality();
        let mut arr = vec![0; n as usize];
        
        // The automorphism swaps elements 0 and 1
        arr[0] = 1;
        arr[1] = 0;
        
        // For other elements, we need to evaluate their terms with the substitution
        // that swaps the first two variables
        if let Some(ref variables) = self.inner.variables {
            if let Some(ref term_map) = self.inner.term_map {
                // Create substitution map: swap first two variables
                // Map variable names to their new indices
                let mut subst_map = HashMap::new();
                if variables.len() >= 2 {
                    subst_map.insert(variables[0].get_name().to_string(), 1);
                    subst_map.insert(variables[1].get_name().to_string(), 0);
                }
                for i in 2..variables.len() {
                    subst_map.insert(variables[i].get_name().to_string(), i as i32);
                }
                
                // Evaluate each element's term with the substitution
                for i in 2..n {
                    if let Some(elem) = self.inner.get_element(i as usize) {
                        if let Some(term) = term_map.get(elem) {
                            // Evaluate the term with the substitution on this free algebra
                            // The substitution maps variable names to indices in the free algebra
                            match term.eval_on_free_algebra(self, &subst_map) {
                                Ok(result_index) => {
                                    arr[i as usize] = result_index;
                                }
                                Err(e) => {
                                    // If evaluation fails, fall back to identity
                                    // This can happen if the term structure doesn't support evaluation
                                    eprintln!("WARNING: Could not evaluate term for element {}: {}", i, e);
                                    arr[i as usize] = i;
                                }
                            }
                        } else {
                            // No term found, use identity
                            arr[i as usize] = i;
                        }
                    } else {
                        // Element not found, use identity
                        arr[i as usize] = i;
                    }
                }
            } else {
                // No term map, use identity for all elements >= 2
                for i in 2..n {
                    arr[i as usize] = i;
                }
            }
        } else {
            // No variables, use identity for all elements >= 2
            for i in 2..n {
                arr[i as usize] = i;
            }
        }
        
        // Create the operation with the computed mapping array
        // This is a unary operation (arity 1) that maps each element to its image
        let op = make_int_operation_str("autoXY", 1, n, arr)?;
        
        Ok(Some(op))
    }

    /// Find an equation that holds in A but fails in B.
    /// 
    /// # Arguments
    /// * `a` - Algebra A
    /// * `b` - Algebra B
    /// * `b_gens` - Generators for B
    /// 
    /// # Returns
    /// * `Some(Equation)` - An equation that distinguishes A from B
    /// * `None` - If no such equation exists
    pub fn find_equation_of_a_not_b(
        a: Box<dyn SmallAlgebra<UniverseItem = i32>>,
        b: Box<dyn SmallAlgebra<UniverseItem = i32>>,
        b_gens: Vec<i32>,
    ) -> Result<Option<Equation>, String> {
        Self::find_equation_of_a_not_b_with_report(a, b, b_gens, None)
    }

    /// Find an equation that holds in A but fails in B with progress reporting.
    /// 
    /// This method creates a free algebra over A and uses a Closer to find
    /// a failing equation when trying to map to B.
    /// 
    /// # Arguments
    /// * `a` - Algebra A
    /// * `b` - Algebra B
    /// * `b_gens` - Generators for B
    /// * `report` - Optional progress reporter
    /// 
    /// # Returns
    /// * `Some(Equation)` - An equation that distinguishes A from B
    /// * `None` - If no such equation exists
    pub fn find_equation_of_a_not_b_with_report(
        a: Box<dyn SmallAlgebra<UniverseItem = i32>>,
        _b: Box<dyn SmallAlgebra<UniverseItem = i32>>,
        b_gens: Vec<i32>,
        report: Option<Arc<dyn ProgressReport>>,
    ) -> Result<Option<Equation>, String> {
        // Create free algebra over A
        let f = Self::new_with_decompose_safe(
            "F".to_string(),
            a,
            b_gens.len() as i32,
            false,
            true,
            true,
            None,
            report.as_ref().cloned(),
        )?;

        println!("gens v length = {}", f.inner.gens[0].universe_size());
        if let Some(ref report) = report {
            report.add_line(&format!("gens v length = {}", f.inner.gens[0].universe_size()));
        }

        // Use the Closer to find a failing equation
        let mut closer = Closer::new_safe(
            Arc::new(f.inner.product_algebra.clone()),
            f.inner.gens.clone()
        )?;
        
        // Set progress report if provided
        if let Some(report) = report {
            closer.set_progress_report(Some(report.clone()));
        }
        
        // Set image algebra and homomorphism
        // Note: These methods need to be implemented in the Closer
        // closer.set_image_algebra(b);
        // closer.set_homomorphism(b_gens);
        
        // Compute closure
        let _result = closer.sg_close()?;
        
        // Get failing equation
        // Note: This method needs to be implemented in the Closer
        // let failing_equation = closer.get_failing_equation();
        
        // For now, return None as the Closer methods need to be fully implemented
        Ok(None)
    }

    /// Get a term for the given element.
    fn get_term(&self, elem: &IntArray) -> Option<Box<dyn Term>> {
        self.inner.term_map.as_ref()?.get(elem).map(|t| t.clone_box())
    }

    /// Get the underlying subproduct algebra.
    pub fn get_inner(&self) -> &SubProductAlgebra<i32> {
        &self.inner
    }

    /// Get the underlying subproduct algebra mutably.
    pub fn get_inner_mut(&mut self) -> &mut SubProductAlgebra<i32> {
        &mut self.inner
    }

    /// Get the congruence lattice (lazy initialization).
    /// 
    /// # Returns
    /// A reference to the congruence lattice
    pub fn con(&mut self) -> &crate::alg::conlat::CongruenceLattice<IntArray> {
        self.inner.con()
    }
}

// Implement Algebra trait by delegating to inner
impl Algebra for FreeAlgebra {
    type UniverseItem = IntArray;

    fn universe(&self) -> Box<dyn Iterator<Item = Self::UniverseItem>> {
        self.inner.universe()
    }

    fn cardinality(&self) -> i32 {
        self.inner.cardinality()
    }

    fn input_size(&self) -> i32 {
        self.inner.input_size()
    }

    fn is_unary(&self) -> bool {
        self.inner.is_unary()
    }

    fn iterator(&self) -> Box<dyn Iterator<Item = Self::UniverseItem>> {
        self.inner.iterator()
    }

    fn operations(&self) -> Vec<Box<dyn Operation>> {
        self.inner.operations()
    }

    fn name(&self) -> &str {
        self.inner.name()
    }

    fn description(&self) -> Option<&str> {
        self.inner.description()
    }

    fn similarity_type(&self) -> &SimilarityType {
        self.inner.similarity_type()
    }

    fn get_operation(&self, sym: &OperationSymbol) -> Option<Box<dyn Operation>> {
        self.inner.get_operation(sym)
    }

    fn get_operations_map(&self) -> HashMap<OperationSymbol, Box<dyn Operation>> {
        self.inner.get_operations_map()
    }

    fn set_name(&mut self, name: String) {
        self.inner.set_name(name);
    }

    fn set_description(&mut self, desc: Option<String>) {
        self.inner.set_description(desc);
    }

    fn update_similarity_type(&mut self) {
        self.inner.update_similarity_type();
    }

    fn is_similar_to(&self, other: &dyn Algebra<UniverseItem = Self::UniverseItem>) -> bool {
        self.inner.is_similar_to(other)
    }

    fn make_operation_tables(&mut self) {
        // Free algebras should NOT create operation tables.
        // They use SubProductOpWrapper operations that dynamically compute values
        // by converting indices to IntArray elements and calling the product algebra.
        // Creating IntOperation tables would be incorrect because:
        // 1. Free algebras have IntArray universe items, not integer items
        // 2. The operations need to work with IntArray elements, not just indices
        // SubProductAlgebra.make_operation_tables() is already a no-op, but we're explicit here.
        // Do nothing - keep the SubProductOpWrapper operations.
    }

    fn constant_operations(&self) -> Vec<Box<dyn Operation>> {
        self.inner.constant_operations()
    }

    fn is_idempotent(&self) -> bool {
        self.inner.is_idempotent()
    }

    fn is_total(&self) -> bool {
        self.inner.is_total()
    }

    fn monitoring(&self) -> bool {
        self.inner.monitoring()
    }

    fn get_monitor(&self) -> Option<&dyn ProgressMonitor> {
        self.inner.get_monitor()
    }

    fn set_monitor(&mut self, monitor: Option<Box<dyn ProgressMonitor>>) {
        self.inner.set_monitor(monitor);
    }
}

// Additional methods for FreeAlgebra (not part of traits)
impl FreeAlgebra {
    /// Borrowed access to Arc-backed operations to avoid cloning.
    /// 
    /// This is more efficient than `operations()` which creates boxes.
    pub(crate) fn operations_ref_arc(&self) -> &[Arc<dyn Operation>] {
        self.inner.operations_ref_arc()
    }
}

// Implement SmallAlgebra trait by delegating to inner
impl SmallAlgebra for FreeAlgebra
{
    fn get_operation_ref(&self, sym: &OperationSymbol) -> Option<&dyn Operation> {
        self.inner.get_operation_ref(sym)
    }

    fn get_operations_ref(&self) -> Vec<&dyn Operation> {
        self.inner.get_operations_ref()
    }

    fn clone_box(&self) -> Box<dyn SmallAlgebra<UniverseItem = Self::UniverseItem>> {
        Box::new(FreeAlgebra {
            inner: self.inner.clone(),
        })
    }

    fn algebra_type(&self) -> AlgebraType {
        AlgebraType::Free
    }

    fn get_element(&self, k: usize) -> Option<Self::UniverseItem> {
        self.inner.get_element(k).cloned()
    }

    fn element_index(&self, elem: &Self::UniverseItem) -> Option<usize> {
        self.inner.element_index(elem)
    }

    fn get_universe_list(&self) -> Option<Vec<Self::UniverseItem>> {
        Some(self.inner.get_universe_list().to_vec())
    }

    fn get_universe_order(&self) -> Option<HashMap<Self::UniverseItem, usize>> {
        Some(self.inner.get_universe_order().clone())
    }

    fn parent(&self) -> Option<&dyn SmallAlgebra<UniverseItem = Self::UniverseItem>> {
        // Type mismatch - return None for now
        None
    }

    fn parents(&self) -> Option<Vec<&dyn SmallAlgebra<UniverseItem = Self::UniverseItem>>> {
        // Type mismatch - return None for now
        None
    }

    fn reset_con_and_sub(&mut self) {
        self.inner.reset_con_and_sub();
    }

    fn convert_to_default_value_ops(&mut self) {
        self.inner.convert_to_default_value_ops();
    }
}

// Implement Display trait
impl Display for FreeAlgebra {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "FreeAlgebra({})", self.inner.name())
    }
}

// Implement Clone trait
impl Clone for FreeAlgebra {
    fn clone(&self) -> Self {
        FreeAlgebra {
            inner: self.inner.clone(),
        }
    }
}

// Implement PartialEq trait
impl PartialEq for FreeAlgebra {
    fn eq(&self, other: &Self) -> bool {
        // SubProductAlgebra doesn't implement PartialEq, so we compare by name for now
        self.inner.name == other.inner.name
    }
}

// Implement Eq trait
impl Eq for FreeAlgebra {
}

// Implement Hash trait
impl Hash for FreeAlgebra {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        // SubProductAlgebra doesn't implement Hash, so we hash by name for now
        self.inner.name.hash(state);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::alg::BasicSmallAlgebra;
    use crate::alg::op::{OperationSymbol, Operation};
    use crate::alg::op::operations;
    use std::collections::HashSet;

    fn create_test_algebra() -> Box<dyn SmallAlgebra<UniverseItem = i32>> {
        let universe = HashSet::from([0, 1, 2]);
        
        // Create operations - FreeAlgebra needs at least one operation for closure computation
        let mut ops: Vec<Box<dyn Operation>> = Vec::new();
        
        // Add a binary operation (e.g., addition mod 3)
        let add_sym = OperationSymbol::new("add", 2, false);
        let add_table = vec![
            0, 1, 2,  // 0 + 0, 0 + 1, 0 + 2
            1, 2, 0,  // 1 + 0, 1 + 1, 1 + 2
            2, 0, 1,  // 2 + 0, 2 + 1, 2 + 2
        ];
        let add_op = operations::make_int_operation(add_sym, 3, add_table)
            .expect("Failed to create operation");
        ops.push(add_op);
        
        Box::new(BasicSmallAlgebra::new(
            "Test".to_string(),
            universe,
            ops,
        )) as Box<dyn SmallAlgebra<UniverseItem = i32>>
    }

    #[test]
    fn test_new_safe() {
        let alg = create_test_algebra();
        let free_alg = FreeAlgebra::new_safe(alg, 2);
        assert!(free_alg.is_ok());
        let free_alg = free_alg.unwrap();
        assert_eq!(free_alg.algebra_type(), AlgebraType::Free);
    }

    #[test]
    fn test_new_with_name_safe() {
        let alg = create_test_algebra();
        let free_alg = FreeAlgebra::new_with_name_safe(
            "TestFree".to_string(),
            alg,
            3,
        );
        assert!(free_alg.is_ok());
        let free_alg = free_alg.unwrap();
        assert_eq!(free_alg.name(), "TestFree");
    }

    #[test]
    fn test_algebra_type() {
        let alg = create_test_algebra();
        let free_alg = FreeAlgebra::new_safe(alg, 1).unwrap();
        assert_eq!(free_alg.algebra_type(), AlgebraType::Free);
    }

    #[test]
    fn test_switch_x_and_y_automorphism_insufficient_generators() {
        let alg = create_test_algebra();
        let free_alg = FreeAlgebra::new_safe(alg, 1).unwrap();
        let auto = free_alg.switch_x_and_y_automorphism().unwrap();
        assert!(auto.is_none());
    }

    #[test]
    fn test_find_equation_of_a_not_b() {
        let alg_a = create_test_algebra();
        let alg_b = create_test_algebra();
        let b_gens = vec![0, 1];
        
        let result = FreeAlgebra::find_equation_of_a_not_b(
            alg_a,
            alg_b,
            b_gens,
        );
        assert!(result.is_ok());
        // The result may be None if no distinguishing equation exists
    }
}
