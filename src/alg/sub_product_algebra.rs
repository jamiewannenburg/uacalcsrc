/*!
 * SubProductAlgebra - A subalgebra of a direct product of SmallAlgebras.
 * 
 * This is a partial implementation of org.uacalc.alg.SubProductAlgebra,
 * excluding methods that depend on TypeFinder, CongruenceLattice, and SubalgebraLattice.
 */

use std::collections::{HashMap, HashSet};
use std::fmt::{self, Debug, Display};
use std::hash::Hash;
use std::sync::Arc;
use crate::alg::{Algebra, SmallAlgebra, AlgebraType, BigProductAlgebra};
use crate::alg::algebra::ProgressMonitor;
use crate::alg::op::{Operation, OperationSymbol, SimilarityType};
use crate::alg::op::operation::boxed_arc_op;
use crate::util::int_array::{IntArray, IntArrayTrait};
use crate::terms::{Term, VariableImp};

/// A subalgebra of a direct product of SmallAlgebras.
/// 
/// This class represents a subalgebra of a BigProductAlgebra generated by
/// a given set of elements. It allows construction of such an algebra even
/// when the full product is too large to fit in memory.
/// 
/// # Examples
/// ```ignore
/// use uacalc::alg::{SubProductAlgebra, BigProductAlgebra, SmallAlgebra};
/// use uacalc::util::int_array::IntArray;
/// 
/// // Create a big product algebra
/// let product = BigProductAlgebra::<i32>::new_safe(vec![alg1, alg2]).unwrap();
/// 
/// // Create generators
/// let mut gens = vec![];
/// gens.push(IntArray::new_from_slice(&[0, 0]).unwrap());
/// gens.push(IntArray::new_from_slice(&[1, 0]).unwrap());
/// 
/// // Create subproduct algebra
/// let sub_prod = SubProductAlgebra::new_safe(
///     "SubProd".to_string(),
///     product,
///     gens,
///     false
/// ).unwrap();
/// ```
#[derive(Debug)]
pub struct SubProductAlgebra<T>
where
    T: Clone + PartialEq + Eq + Hash + std::fmt::Debug + Send + Sync + 'static
{
    /// Name of the algebra
    pub name: String,
    
    /// Description of the algebra
    pub description: Option<String>,
    
    /// The underlying product algebra
    pub product_algebra: BigProductAlgebra<T>,
    
    /// Generators as IntArray list
    pub gens: Vec<IntArray>,
    
    /// Universe as IntArray list
    pub univ: Vec<IntArray>,
    
    /// Whether to thin generators
    pub thin_generators: bool,
    
    /// Whether to decompose
    pub decompose: bool,
    
    /// Element to index mapping
    pub univ_hash_map: HashMap<IntArray, usize>,
    
    /// Terms associated with elements (if find_terms is true)
    pub terms: Option<Vec<Box<dyn Term>>>,
    
    /// Element to term mapping
    pub term_map: Option<HashMap<IntArray, Box<dyn Term>>>,
    
    /// Variables for generators
    pub variables: Option<Vec<VariableImp>>,
    
    /// Variable to generator mapping
    pub vars_map: Option<HashMap<VariableImp, IntArray>>,
    
    /// Universe as HashSet
    pub universe: HashSet<IntArray>,
    
    /// Operations on this algebra (Arc-backed, boxed view provided on demand)
    operations: Vec<Arc<dyn Operation>>,
    
    /// Similarity type
    similarity_type: Option<SimilarityType>,
    
    /// Progress monitor
    monitor: Option<Box<dyn ProgressMonitor>>,
    
    /// Lazy-initialized congruence lattice
    con: Option<Box<crate::alg::conlat::CongruenceLattice<IntArray>>>,
    
    /// Lazy-initialized subalgebra lattice
    sub: Option<Box<crate::alg::sublat::SubalgebraLattice<IntArray>>>,
}

impl<T> SubProductAlgebra<T>
where
    T: Clone + PartialEq + Eq + Hash + std::fmt::Debug + Send + Sync + 'static
{
    /// Construct a SubProductAlgebra from a BigProductAlgebra and generators.
    /// 
    /// # Arguments
    /// * `name` - The name of the algebra
    /// * `prod` - The underlying product algebra
    /// * `gens` - The generators as IntArray list
    /// * `find_terms` - Whether to compute terms for elements
    /// 
    /// # Returns
    /// * `Ok(SubProductAlgebra)` - Successfully created subproduct algebra
    /// * `Err(String)` - If construction fails
    pub fn new_safe(
        name: String,
        prod: BigProductAlgebra<T>,
        gens: Vec<IntArray>,
        find_terms: bool,
    ) -> Result<Self, String> {
        Self::new_full_safe(name, prod, gens, find_terms, false)
    }
    
    /// Construct a SubProductAlgebra with all options.
    /// 
    /// # Arguments
    /// * `name` - The name of the algebra
    /// * `prod` - The underlying product algebra
    /// * `gens` - The generators as IntArray list
    /// * `find_terms` - Whether to compute terms for elements
    /// * `include_constants` - Whether to include constant elements as generators
    /// 
    /// # Returns
    /// * `Ok(SubProductAlgebra)` - Successfully created subproduct algebra
    /// * `Err(String)` - If construction fails
    pub fn new_full_safe(
        name: String,
        prod: BigProductAlgebra<T>,
        mut gens: Vec<IntArray>,
        find_terms: bool,
        include_constants: bool,
    ) -> Result<Self, String> {
        // Add constants if requested and if product is a power
        if include_constants && prod.is_power() {
            if let Some(root_factors) = prod.root_factors() {
                if !root_factors.is_empty() {
                    let root_size = root_factors[0].cardinality();
                    let factors = prod.get_number_of_factors();
                    
                    for i in 0..root_size {
                        let arr = vec![i; factors];
                        gens.push(IntArray::from_array(arr)?);
                    }
                }
            }
        }
        
        // Eliminate duplicates but keep order
        let mut hs: HashSet<IntArray> = HashSet::new();
        let mut gens2: Vec<IntArray> = Vec::new();
        for elem in gens {
            if !hs.contains(&elem) {
                hs.insert(elem.clone());
                gens2.push(elem);
            }
        }
        gens = gens2;
        
        // Compute universe and terms if requested
        let (univ, term_map, terms, vars_map) = if find_terms {
            let term_map_init = Self::setup_gens_to_vars_map(&gens)?;
            let vars_map: HashMap<VariableImp, IntArray> = term_map_init.iter()
                .filter_map(|(ia, term)| {
                    if term.isa_variable() {
                        // Downcast to VariableImp
                        // This is a bit tricky since we have Box<dyn Term>
                        // For now, we'll extract the variable name and create a new VariableImp
                        let var_str = term.to_string();
                        Some((VariableImp::new(&var_str), ia.clone()))
                    } else {
                        None
                    }
                })
                .collect();
            
            // Use Closer directly to get updated term_map back
            use std::sync::Arc;
            use crate::alg::Closer;
            let prod_arc = Arc::new(prod.clone());
            let mut closer = Closer::new_safe(prod_arc, gens.clone())?;
            closer.set_term_map(Some(term_map_init));
            let univ = closer.sg_close()?;
            
            // Get the updated term_map from Closer
            let term_map = closer.get_term_map()
                .map(|tm| {
                    let mut result = HashMap::new();
                    for (k, v) in tm.iter() {
                        result.insert(k.clone(), v.clone_box());
                    }
                    result
                });
            
            let mut terms_vec = Vec::with_capacity(univ.len());
            if let Some(ref tm) = term_map {
                for ia in &univ {
                    if let Some(term) = tm.get(ia) {
                        terms_vec.push(term.clone_box());
                    }
                }
            }
            
            (univ, term_map, Some(terms_vec), Some(vars_map))
        } else {
            // Don't sort - Java uses the order from sgClose
            let univ = prod.sg_close(gens.clone())?;
            (univ, None, None, None)
        };
        
        let size = univ.len();
        
        // Create element to index mapping
        let mut univ_hash_map = HashMap::new();
        for (k, ia) in univ.iter().enumerate() {
            univ_hash_map.insert(ia.clone(), k);
        }
        
        // Create universe set
        let universe: HashSet<IntArray> = univ.iter().cloned().collect();
        
        // Extract variables from vars_map
        let variables = vars_map.as_ref().map(|vm| {
            vm.keys().cloned().collect::<Vec<VariableImp>>()
        });
        
        let mut sub_prod = SubProductAlgebra {
            name,
            description: None,
            product_algebra: prod,
            gens,
            univ,
            thin_generators: false,
            decompose: false,
            univ_hash_map,
            terms,
            term_map,
            variables,
            vars_map,
            universe,
            operations: Vec::new(),
            similarity_type: None,
            monitor: None,
            con: None,
            sub: None,
        };
        
        // Make operations
        sub_prod.make_operations()?;
        
        Ok(sub_prod)
    }
    
    /// Construct a SubProductAlgebra with pre-computed universe.
    /// 
    /// This is useful for reading from a file without recalculating the universe.
    /// 
    /// # Arguments
    /// * `name` - The name of the algebra
    /// * `prod` - The underlying product algebra
    /// * `gens` - The generators as IntArray list
    /// * `univ_list` - The pre-computed universe
    /// 
    /// # Returns
    /// * `Ok(SubProductAlgebra)` - Successfully created subproduct algebra
    /// * `Err(String)` - If construction fails
    pub fn new_with_universe_safe(
        name: String,
        prod: BigProductAlgebra<T>,
        gens: Vec<IntArray>,
        univ_list: Vec<IntArray>,
    ) -> Result<Self, String> {
        let mut sub_prod = SubProductAlgebra {
            name,
            description: None,
            product_algebra: prod,
            gens: gens.clone(),
            univ: univ_list.clone(),
            thin_generators: false,
            decompose: false,
            univ_hash_map: HashMap::new(),
            terms: None,
            term_map: None,
            variables: None,
            vars_map: None,
            universe: HashSet::new(),
            operations: Vec::new(),
            similarity_type: None,
            monitor: None,
            con: None,
            sub: None,
        };
        
        // Don't sort - preserve the order from the input (matching Java)
        sub_prod.univ = univ_list.clone();
        
        // Create element to index mapping
        for (k, ia) in univ_list.iter().enumerate() {
            sub_prod.univ_hash_map.insert(ia.clone(), k);
        }
        
        // Create universe set
        sub_prod.universe = univ_list.iter().cloned().collect();
        
        // Make operations
        sub_prod.make_operations()?;
        
        Ok(sub_prod)
    }
    
    /// Setup the generator to variable mapping for term computation.
    /// 
    /// # Arguments
    /// * `gens` - The generators
    /// 
    /// # Returns
    /// * `Ok(HashMap)` - The term map
    /// * `Err(String)` - If setup fails
    fn setup_gens_to_vars_map(gens: &[IntArray]) -> Result<HashMap<IntArray, Box<dyn Term>>, String> {
        let mut term_map = HashMap::new();
        
        match gens.len() {
            0 => {},
            1 => {
                term_map.insert(gens[0].clone(), Box::new(VariableImp::x()) as Box<dyn Term>);
            },
            2 => {
                term_map.insert(gens[0].clone(), Box::new(VariableImp::x()) as Box<dyn Term>);
                term_map.insert(gens[1].clone(), Box::new(VariableImp::y()) as Box<dyn Term>);
            },
            3 => {
                term_map.insert(gens[0].clone(), Box::new(VariableImp::x()) as Box<dyn Term>);
                term_map.insert(gens[1].clone(), Box::new(VariableImp::y()) as Box<dyn Term>);
                term_map.insert(gens[2].clone(), Box::new(VariableImp::z()) as Box<dyn Term>);
            },
            _ => {
                for (k, gen) in gens.iter().enumerate() {
                    let var_name = format!("x_{}", k);
                    term_map.insert(gen.clone(), Box::new(VariableImp::new(&var_name)) as Box<dyn Term>);
                }
            }
        }
        
        Ok(term_map)
    }
    
    /// Create operations for this algebra based on the product algebra operations.
    fn make_operations(&mut self) -> Result<(), String> {
        let size = self.univ.len() as i32;
        let prod_ops_ref = self.product_algebra.operations_ref_arc();
        let univ_ref = &self.univ;
        let univ_hash_map_ref = &self.univ_hash_map;
        let number_of_factors = self.product_algebra.get_number_of_factors();
        
        for prod_op in prod_ops_ref {
            let op_sym = prod_op.symbol().clone();
            let arity = prod_op.arity();
            let prod_op_clone = Arc::clone(prod_op);
            
            // Create a custom operation that delegates to the product algebra
            // This matches Java's SubProductAlgebra.intValueAt logic:
            // 1. Convert subalgebra indices to IntArray elements
            // 2. Apply product algebra operation
            // 3. Map result back to subalgebra index
            #[derive(Clone)]
            struct SubProductOpWrapper {
                symbol: OperationSymbol,
                arity: i32,
                size: i32,
                prod_op: Arc<dyn Operation>,
                univ: Vec<IntArray>,
                univ_hash_map: HashMap<IntArray, usize>,
                number_of_factors: usize,
            }
            
            impl Debug for SubProductOpWrapper {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.debug_struct("SubProductOpWrapper")
                        .field("symbol", &self.symbol)
                        .field("arity", &self.arity)
                        .field("size", &self.size)
                        .finish()
                }
            }
            
            impl Display for SubProductOpWrapper {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    write!(f, "SubProductOp({})", self.symbol)
                }
            }
            
            impl Operation for SubProductOpWrapper {
                fn symbol(&self) -> &OperationSymbol {
                    &self.symbol
                }
                
                fn arity(&self) -> i32 {
                    self.arity
                }
                
                fn get_set_size(&self) -> i32 {
                    self.size
                }
                
                fn int_value_at(&self, args: &[i32]) -> Result<i32, String> {
                    // Convert subalgebra indices to IntArray elements (matching Java's getElement)
                    let mut elem_args = Vec::with_capacity(args.len());
                    for &arg_idx in args {
                        if arg_idx < 0 || arg_idx >= self.univ.len() as i32 {
                            return Err(format!("Argument index {} out of range [0, {})", arg_idx, self.univ.len()));
                        }
                        elem_args.push(&self.univ[arg_idx as usize]);
                    }
                    
                    // Apply product algebra operation (matching Java's opx.valueAt)
                    // Extract components based on product algebra's number_of_factors
                    // If elements have different lengths, extract up to number_of_factors components
                    let mut elem_slices: Vec<Vec<i32>> = Vec::with_capacity(elem_args.len());
                    for elem in &elem_args {
                        let elem_slice = elem.as_slice();
                        let mut components = Vec::with_capacity(self.number_of_factors);
                        for j in 0..self.number_of_factors {
                            if j < elem_slice.len() {
                                components.push(elem_slice[j]);
                            } else {
                                // Pad with 0 if element is shorter than expected
                                components.push(0);
                            }
                        }
                        elem_slices.push(components);
                    }
                    let elem_slice_refs: Vec<&[i32]> = elem_slices.iter().map(|v| v.as_slice()).collect();
                    let result_array = self.prod_op.value_at_arrays(&elem_slice_refs)?;
                    let result_ia = IntArray::from_array(result_array)?;
                    
                    // Map result back to subalgebra index (matching Java's elementIndex)
                    // If result is not in subalgebra, this is an error (operation not closed)
                    // But during congruence computation, this might happen temporarily
                    match self.univ_hash_map.get(&result_ia) {
                        Some(&idx) => {
                            Ok(idx as i32)
                        },
                        None => {
                            Err(format!("Result {:?} not found in subalgebra universe (operation not closed)", result_ia))
                        }
                    }
                }
                
                fn value_at_arrays(&self, args: &[&[i32]]) -> Result<Vec<i32>, String> {
                    if args.is_empty() {
                        return Ok(Vec::new());
                    }
                    let len = args[0].len();
                    let mut result = Vec::with_capacity(len);
                    for i in 0..len {
                        let mut single_args = Vec::with_capacity(args.len());
                        for arg_array in args {
                            single_args.push(arg_array[i]);
                        }
                        result.push(self.int_value_at(&single_args)?);
                    }
                    Ok(result)
                }
                
                fn value_at(&self, _args: &[i32]) -> Result<i32, String> {
                    Err("SubProductOpWrapper does not support value_at".to_string())
                }
                
                fn int_value_at_horner(&self, arg: i32) -> Result<i32, String> {
                    use crate::util::horner;
                    let args = horner::horner_inv_same_size(arg, self.size, self.arity as usize);
                    self.int_value_at(&args)
                }
                
                fn make_table(&mut self) -> Result<(), String> {
                    // Tables will be made lazily if needed
                    Ok(())
                }
                
                fn get_table(&self) -> Option<&[i32]> {
                    None
                }
                
                fn get_table_force(&mut self, _make_table: bool) -> Result<&[i32], String> {
                    Err("Table not available for SubProductOpWrapper".to_string())
                }
                
                fn is_table_based(&self) -> bool {
                    false
                }
                
                fn is_idempotent(&self) -> Result<bool, String> {
                    self.prod_op.is_idempotent()
                }
                
                fn is_associative(&self) -> Result<bool, String> {
                    self.prod_op.is_associative()
                }
                
                fn is_commutative(&self) -> Result<bool, String> {
                    self.prod_op.is_commutative()
                }
                
                fn is_totally_symmetric(&self) -> Result<bool, String> {
                    self.prod_op.is_totally_symmetric()
                }
                
                fn is_maltsev(&self) -> Result<bool, String> {
                    self.prod_op.is_maltsev()
                }
                
                fn is_total(&self) -> Result<bool, String> {
                    self.prod_op.is_total()
                }
                
                fn clone_box(&self) -> Box<dyn Operation> {
                    Box::new(SubProductOpWrapper {
                        symbol: self.symbol.clone(),
                        arity: self.arity,
                        size: self.size,
                        prod_op: Arc::clone(&self.prod_op),
                        univ: self.univ.clone(),
                        univ_hash_map: self.univ_hash_map.clone(),
                        number_of_factors: self.number_of_factors,
                    })
                }
            }
            
            let wrapper = SubProductOpWrapper {
                symbol: op_sym,
                arity,
                size,
                prod_op: prod_op_clone,
                univ: univ_ref.clone(),
                univ_hash_map: univ_hash_map_ref.clone(),
                number_of_factors,
            };
            
            self.operations.push(Arc::new(wrapper));
        }
        
        Ok(())
    }
    
    /// Transpose a list of IntArrays (swap rows and columns).
    /// 
    /// # Arguments
    /// * `lst` - The list to transpose
    /// 
    /// # Returns
    /// * `Ok(Vec<IntArray>)` - The transposed list
    /// * `Err(String)` - If the list is empty or has inconsistent sizes
    pub fn transpose(lst: &[IntArray]) -> Result<Vec<IntArray>, String> {
        if lst.is_empty() {
            return Err("Cannot transpose empty list".to_string());
        }
        
        let k = lst.len();
        let n = lst[0].universe_size();
        
        let mut transpose = Vec::with_capacity(n);
        for i in 0..n {
            let mut ith_proj = Vec::with_capacity(k);
            for j in 0..k {
                let val = lst[j].get(i).ok_or_else(|| format!("Index {} out of bounds", i))?;
                ith_proj.push(val);
            }
            transpose.push(IntArray::from_array(ith_proj)?);
        }
        
        Ok(transpose)
    }
    
    /// Get the generators of this algebra.
    pub fn generators(&self) -> &[IntArray] {
        &self.gens
    }
    
    /// Get the universe list.
    pub fn get_universe_list(&self) -> &[IntArray] {
        &self.univ
    }
    
    /// Get the universe order (element to index mapping).
    pub fn get_universe_order(&self) -> &HashMap<IntArray, usize> {
        &self.univ_hash_map
    }
    
    /// Get the underlying product algebra.
    pub fn get_product_algebra(&self) -> &BigProductAlgebra<T> {
        &self.product_algebra
    }
    
    /// Get the super algebra (same as product algebra).
    pub fn super_algebra(&self) -> &BigProductAlgebra<T> {
        &self.product_algebra
    }
    
    /// Get the congruence lattice (lazy initialization).
    /// 
    /// # Returns
    /// A mutable reference to the congruence lattice
    pub fn con(&mut self) -> &mut crate::alg::conlat::CongruenceLattice<IntArray> {
        if self.con.is_none() {
            // Create congruence lattice using the type-erased wrapper
            use crate::alg::SmallAlgebraWrapper;
            
            // Clone this algebra as a trait object
            let alg_box = Box::new(self.clone()) as Box<dyn SmallAlgebra<UniverseItem = IntArray>>;
            let wrapper = Box::new(SmallAlgebraWrapper::<IntArray>::new(alg_box));
            self.con = Some(Box::new(crate::alg::conlat::CongruenceLattice::<IntArray>::new(wrapper)));
        }
        self.con.as_mut().unwrap()
    }
    
    /// Get the subalgebra lattice (lazy initialization).
    /// 
    /// # Returns
    /// A reference to the subalgebra lattice
    /// 
    /// # Note
    /// This method creates a SubalgebraLattice that works directly with IntArray
    /// universe types, which is the natural type for SubProductAlgebra.
    pub fn sub(&mut self) -> &crate::alg::sublat::SubalgebraLattice<IntArray> {
        if self.sub.is_none() {
            // Create SubalgebraLattice with IntArray universe type
            use crate::alg::SmallAlgebraWrapper;
            
            // Clone this algebra as a trait object for the SubalgebraLattice
            let alg_box = Box::new(self.clone()) as Box<dyn SmallAlgebra<UniverseItem = IntArray>>;
            let wrapper = Box::new(SmallAlgebraWrapper::<IntArray>::new(alg_box));
            
            match crate::alg::sublat::SubalgebraLattice::new_safe(wrapper) {
                Ok(sub_lat) => {
                    self.sub = Some(Box::new(sub_lat));
                }
                Err(e) => {
                    panic!("Failed to create SubalgebraLattice for SubProductAlgebra: {}", e);
                }
            }
        }
        self.sub.as_ref().unwrap()
    }
    
    /// Get the terms array (if terms were computed).
    pub fn get_terms(&self) -> Option<&[Box<dyn Term>]> {
        self.terms.as_deref()
    }
    
    /// Get the term associated with an element.
    /// 
    /// # Arguments
    /// * `elt` - The element as IntArray
    /// 
    /// # Returns
    /// The term for the element, or None if not found or terms not computed
    pub fn get_term(&self, elt: &IntArray) -> Option<&dyn Term> {
        if let Some(terms) = &self.terms {
            if let Some(&idx) = self.univ_hash_map.get(elt) {
                return Some(terms[idx].as_ref());
            }
        }
        None
    }
    
    /// Get the term map.
    pub fn get_term_map(&self) -> Option<&HashMap<IntArray, Box<dyn Term>>> {
        self.term_map.as_ref()
    }
    
    /// Get the variables corresponding to generators.
    pub fn get_variables(&self) -> Option<Vec<VariableImp>> {
        if let Some(vars) = &self.variables {
            return Some(vars.clone());
        }
        
        if self.terms.is_none() || self.gens.is_empty() {
            return None;
        }
        
        let terms = self.terms.as_ref().unwrap();
        let mut ans = Vec::new();
        
        for i in 0..self.gens.len() {
            if i < terms.len() && terms[i].isa_variable() {
                // Extract variable name and create VariableImp
                let var_name = terms[i].to_string();
                ans.push(VariableImp::new(&var_name));
            }
        }
        
        Some(ans)
    }
    
    /// Get the variable to generator mapping.
    pub fn get_variable_to_generator_map(&self) -> Option<&HashMap<VariableImp, IntArray>> {
        self.vars_map.as_ref()
    }
    
    /// Get the element from a term (linear search).
    /// 
    /// # Arguments
    /// * `t` - The term to search for
    /// 
    /// # Returns
    /// The element as IntArray, or None if not found
    pub fn get_element_from_term(&self, t: &dyn Term) -> Option<IntArray> {
        if let Some(terms) = &self.terms {
            for (i, term) in terms.iter().enumerate() {
                if term.to_string() == t.to_string() {
                    return Some(self.univ[i].clone());
                }
            }
        }
        None
    }
    
    /// Get the index of an element.
    /// 
    /// # Arguments
    /// * `elem` - The element as IntArray
    /// 
    /// # Returns
    /// * `Some(index)` - The index of the element
    /// * `None` - If the element is not in the universe
    pub fn element_index(&self, elem: &IntArray) -> Option<usize> {
        self.univ_hash_map.get(elem).copied()
    }
    
    /// Get an element by its index.
    /// 
    /// # Arguments
    /// * `index` - The index of the element
    /// 
    /// # Returns
    /// * `Some(element)` - The element at the index
    /// * `None` - If the index is out of bounds
    pub fn get_element(&self, index: usize) -> Option<&IntArray> {
        self.univ.get(index)
    }
    
    /// Set whether to thin generators.
    pub fn set_thin_generators(&mut self, v: bool) {
        self.thin_generators = v;
    }
    
    /// Get whether generators are thinned.
    pub fn get_thin_generators(&self) -> bool {
        self.thin_generators
    }
    
    /// Set whether to decompose.
    pub fn set_decompose(&mut self, v: bool) {
        self.decompose = v;
    }
    
    /// Get whether decomposed.
    pub fn get_decompose(&self) -> bool {
        self.decompose
    }
    
    /// Get the cardinality of this algebra.
    pub fn cardinality(&self) -> i32 {
        self.univ.len() as i32
    }
    
    /// Make operation tables for all operations.
    /// 
    /// This method creates operation tables up to a certain size limit.
    pub fn make_operation_tables(&mut self) {
        const MAX_ALG_SIZE_FOR_OP_TABLES: i32 = 8000000;
        
        let input_size = self.input_size();
        if input_size < 0 || input_size > MAX_ALG_SIZE_FOR_OP_TABLES {
            return;
        }
        // SubProduct operations are lightweight; avoid table materialization here.
    }
    
    /// Borrowed access to Arc-backed operations to avoid cloning.
    /// 
    /// This is more efficient than `operations()` which creates boxes.
    pub(crate) fn operations_ref_arc(&self) -> &[Arc<dyn Operation>] {
        &self.operations
    }
    
    /// Calculate the input size for operation tables.
    fn input_size(&self) -> i32 {
        // This is a simplified version
        // The full implementation would compute size^max_arity
        let size = self.cardinality();
        if self.operations.is_empty() {
            return 0;
        }
        
        let mut max_arity = 0;
        for op in &self.operations {
            if op.arity() > max_arity {
                max_arity = op.arity();
            }
        }
        
        if max_arity == 0 {
            return 0;
        }
        
        // Calculate size^max_arity with overflow check
        let mut result: i64 = 1;
        for _ in 0..max_arity {
            result = result.saturating_mul(size as i64);
            if result > i32::MAX as i64 {
                return -1;
            }
        }
        
        result as i32
    }
}

impl<T> Display for SubProductAlgebra<T>
where
    T: Clone + PartialEq + Eq + Hash + std::fmt::Debug + Send + Sync + 'static
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "SubProductAlgebra(name={}, size={})", self.name, self.univ.len())
    }
}

impl<T> Algebra for SubProductAlgebra<T>
where
    T: Clone + PartialEq + Eq + Hash + std::fmt::Debug + Send + Sync + 'static
{
    type UniverseItem = IntArray;
    
    fn universe(&self) -> Box<dyn Iterator<Item = Self::UniverseItem>> {
        Box::new(self.univ.clone().into_iter())
    }
    
    fn cardinality(&self) -> i32 {
        self.univ.len() as i32
    }
    
    fn input_size(&self) -> i32 {
        self.input_size()
    }
    
    fn is_unary(&self) -> bool {
        self.operations.iter().all(|op| op.arity() <= 1)
    }
    
    fn iterator(&self) -> Box<dyn Iterator<Item = Self::UniverseItem>> {
        Box::new(self.univ.clone().into_iter())
    }
    
    fn operations(&self) -> Vec<Box<dyn Operation>> {
        self.operations
            .iter()
            .map(|op| boxed_arc_op(Arc::clone(op)))
            .collect()
    }
    
    fn get_operation(&self, sym: &OperationSymbol) -> Option<Box<dyn Operation>> {
        None // Simplified
    }
    
    fn get_operations_map(&self) -> HashMap<OperationSymbol, Box<dyn Operation>> {
        HashMap::new() // Simplified
    }
    
    fn name(&self) -> &str {
        &self.name
    }
    
    fn set_name(&mut self, name: String) {
        self.name = name;
    }
    
    fn description(&self) -> Option<&str> {
        self.description.as_deref()
    }
    
    fn set_description(&mut self, desc: Option<String>) {
        self.description = desc;
    }
    
    fn similarity_type(&self) -> &SimilarityType {
        self.product_algebra.similarity_type()
    }
    
    fn update_similarity_type(&mut self) {
        // Delegate to product algebra
    }
    
    fn is_similar_to(&self, other: &dyn Algebra<UniverseItem = Self::UniverseItem>) -> bool {
        self.similarity_type() == other.similarity_type()
    }
    
    fn make_operation_tables(&mut self) {
        self.make_operation_tables();
    }
    
    fn constant_operations(&self) -> Vec<Box<dyn Operation>> {
        Vec::new() // Simplified
    }
    
    fn is_idempotent(&self) -> bool {
        false // Simplified
    }
    
    fn is_total(&self) -> bool {
        true
    }
    
    fn monitoring(&self) -> bool {
        self.monitor.is_some()
    }
    
    fn get_monitor(&self) -> Option<&dyn ProgressMonitor> {
        self.monitor.as_deref()
    }
    
    fn set_monitor(&mut self, monitor: Option<Box<dyn ProgressMonitor>>) {
        self.monitor = monitor;
    }
}

impl<T> Clone for SubProductAlgebra<T>
where
    T: Clone + PartialEq + Eq + Hash + std::fmt::Debug + Send + Sync + 'static
{
    fn clone(&self) -> Self {
        // Clone operations using Arc::clone (cheap, no deep copy)
        let cloned = SubProductAlgebra {
            name: self.name.clone(),
            description: self.description.clone(),
            product_algebra: self.product_algebra.clone(),
            gens: self.gens.clone(),
            univ: self.univ.clone(),
            thin_generators: self.thin_generators,
            decompose: self.decompose,
            univ_hash_map: self.univ_hash_map.clone(),
            terms: None, // Don't clone terms (too complex)
            term_map: None,
            variables: None,
            vars_map: None,
            universe: self.universe.clone(),
            operations: self.operations.iter().map(|op| Arc::clone(op)).collect(), // Clone Arc-backed operations
            similarity_type: None,
            monitor: None,
            con: None, // Don't clone cached lattices
            sub: None,
        };
        // Operations are already Arc-backed, so we can just clone the Vec of Arcs
        cloned
    }
}

impl<T> SmallAlgebra for SubProductAlgebra<T>
where
    T: Clone + PartialEq + Eq + Hash + std::fmt::Debug + Send + Sync + 'static
{
    fn get_operation_ref(&self, sym: &OperationSymbol) -> Option<&dyn Operation> {
        self.operations.iter().find(|op| op.symbol() == sym).map(|arc| arc.as_ref())
    }
    
    fn get_operations_ref(&self) -> Vec<&dyn Operation> {
        self.operations.iter().map(|arc| arc.as_ref() as &dyn Operation).collect()
    }
    
    fn clone_box(&self) -> Box<dyn SmallAlgebra<UniverseItem = Self::UniverseItem>> {
        Box::new(self.clone())
    }
    
    fn get_element(&self, k: usize) -> Option<Self::UniverseItem> {
        self.univ.get(k).cloned()
    }
    
    fn parent(&self) -> Option<&dyn SmallAlgebra<UniverseItem = Self::UniverseItem>> {
        None
    }
    
    fn parents(&self) -> Option<Vec<&dyn SmallAlgebra<UniverseItem = Self::UniverseItem>>> {
        None
    }
    
    fn reset_con_and_sub(&mut self) {
        // No cached lattices in partial implementation
    }
    
    fn element_index(&self, obj: &Self::UniverseItem) -> Option<usize> {
        self.element_index(obj)
    }
    
    fn get_universe_list(&self) -> Option<Vec<Self::UniverseItem>> {
        Some(self.univ.clone())
    }
    
    fn get_universe_order(&self) -> Option<HashMap<Self::UniverseItem, usize>> {
        Some(self.univ_hash_map.clone())
    }
    
    fn convert_to_default_value_ops(&mut self) {
        panic!("Only for basic algebras");
    }
    
    fn algebra_type(&self) -> AlgebraType {
        AlgebraType::Subproduct
    }
}
