/*!
 * SubProductAlgebra - A subalgebra of a direct product of SmallAlgebras.
 * 
 * This is a partial implementation of org.uacalc.alg.SubProductAlgebra,
 * excluding methods that depend on TypeFinder, CongruenceLattice, and SubalgebraLattice.
 */

use std::collections::{HashMap, HashSet};
use std::fmt::{self, Debug, Display};
use crate::alg::{Algebra, SmallAlgebra, AlgebraType, BigProductAlgebra};
use crate::alg::algebra::ProgressMonitor;
use crate::alg::op::{Operation, OperationSymbol, SimilarityType, AbstractIntOperation};
use crate::util::int_array::{IntArray, IntArrayTrait};
use crate::terms::{Term, VariableImp};

/// A subalgebra of a direct product of SmallAlgebras.
/// 
/// This class represents a subalgebra of a BigProductAlgebra generated by
/// a given set of elements. It allows construction of such an algebra even
/// when the full product is too large to fit in memory.
/// 
/// # Examples
/// ```ignore
/// use uacalc::alg::{SubProductAlgebra, BigProductAlgebra, SmallAlgebra};
/// use uacalc::util::int_array::IntArray;
/// 
/// // Create a big product algebra
/// let product = BigProductAlgebra::new_safe(vec![alg1, alg2]).unwrap();
/// 
/// // Create generators
/// let mut gens = vec![];
/// gens.push(IntArray::new_from_slice(&[0, 0]).unwrap());
/// gens.push(IntArray::new_from_slice(&[1, 0]).unwrap());
/// 
/// // Create subproduct algebra
/// let sub_prod = SubProductAlgebra::new_safe(
///     "SubProd".to_string(),
///     product,
///     gens,
///     false
/// ).unwrap();
/// ```
#[derive(Debug)]
pub struct SubProductAlgebra {
    /// Name of the algebra
    pub name: String,
    
    /// Description of the algebra
    pub description: Option<String>,
    
    /// The underlying product algebra
    pub product_algebra: BigProductAlgebra,
    
    /// Generators as IntArray list
    pub gens: Vec<IntArray>,
    
    /// Universe as IntArray list
    pub univ: Vec<IntArray>,
    
    /// Whether to thin generators
    pub thin_generators: bool,
    
    /// Whether to decompose
    pub decompose: bool,
    
    /// Element to index mapping
    pub univ_hash_map: HashMap<IntArray, usize>,
    
    /// Terms associated with elements (if find_terms is true)
    pub terms: Option<Vec<Box<dyn Term>>>,
    
    /// Element to term mapping
    pub term_map: Option<HashMap<IntArray, Box<dyn Term>>>,
    
    /// Variables for generators
    pub variables: Option<Vec<VariableImp>>,
    
    /// Variable to generator mapping
    pub vars_map: Option<HashMap<VariableImp, IntArray>>,
    
    /// Universe as HashSet
    pub universe: HashSet<IntArray>,
    
    /// Operations on this algebra
    operations: Vec<Box<dyn Operation>>,
    
    /// Similarity type
    similarity_type: Option<SimilarityType>,
    
    /// Progress monitor
    monitor: Option<Box<dyn ProgressMonitor>>,
    
    /// Lazy-initialized congruence lattice
    con: Option<Box<crate::alg::conlat::CongruenceLattice>>,
    
    /// Lazy-initialized subalgebra lattice
    sub: Option<Box<crate::alg::sublat::SubalgebraLattice>>,
}

impl SubProductAlgebra {
    /// Construct a SubProductAlgebra from a BigProductAlgebra and generators.
    /// 
    /// # Arguments
    /// * `name` - The name of the algebra
    /// * `prod` - The underlying product algebra
    /// * `gens` - The generators as IntArray list
    /// * `find_terms` - Whether to compute terms for elements
    /// 
    /// # Returns
    /// * `Ok(SubProductAlgebra)` - Successfully created subproduct algebra
    /// * `Err(String)` - If construction fails
    pub fn new_safe(
        name: String,
        prod: BigProductAlgebra,
        mut gens: Vec<IntArray>,
        find_terms: bool,
    ) -> Result<Self, String> {
        Self::new_full_safe(name, prod, gens, find_terms, false)
    }
    
    /// Construct a SubProductAlgebra with all options.
    /// 
    /// # Arguments
    /// * `name` - The name of the algebra
    /// * `prod` - The underlying product algebra
    /// * `gens` - The generators as IntArray list
    /// * `find_terms` - Whether to compute terms for elements
    /// * `include_constants` - Whether to include constant elements as generators
    /// 
    /// # Returns
    /// * `Ok(SubProductAlgebra)` - Successfully created subproduct algebra
    /// * `Err(String)` - If construction fails
    pub fn new_full_safe(
        name: String,
        mut prod: BigProductAlgebra,
        mut gens: Vec<IntArray>,
        find_terms: bool,
        include_constants: bool,
    ) -> Result<Self, String> {
        // Add constants if requested and if product is a power
        if include_constants && prod.is_power() {
            if let Some(root_factors) = prod.root_factors() {
                if !root_factors.is_empty() {
                    let root_size = root_factors[0].cardinality();
                    let factors = prod.get_number_of_factors();
                    
                    for i in 0..root_size {
                        let arr = vec![i; factors];
                        gens.push(IntArray::from_array(arr)?);
                    }
                }
            }
        }
        
        // Eliminate duplicates but keep order
        let mut hs: HashSet<IntArray> = HashSet::new();
        let mut gens2: Vec<IntArray> = Vec::new();
        for elem in gens {
            if !hs.contains(&elem) {
                hs.insert(elem.clone());
                gens2.push(elem);
            }
        }
        gens = gens2;
        
        // Compute universe and terms if requested
        let (univ, term_map, terms, vars_map) = if find_terms {
            let term_map = Self::setup_gens_to_vars_map(&gens)?;
            let vars_map = term_map.iter()
                .filter_map(|(ia, term)| {
                    if term.isa_variable() {
                        // Downcast to VariableImp
                        // This is a bit tricky since we have Box<dyn Term>
                        // For now, we'll extract the variable name and create a new VariableImp
                        let var_str = term.to_string();
                        Some((VariableImp::new(&var_str), ia.clone()))
                    } else {
                        None
                    }
                })
                .collect();
            
            // Note: The Java version passes a termMap to sgClose, but the Rust version
            // doesn't support this yet. We'll compute the universe without terms for now.
            let univ = prod.sg_close(gens.clone())?;
            
            let mut terms_vec = Vec::with_capacity(univ.len());
            for ia in &univ {
                if let Some(term) = term_map.get(ia) {
                    terms_vec.push(term.clone_box());
                } else {
                    // If no term exists for this element, we'll skip it
                    // This is a simplified implementation
                    continue;
                }
            }
            
            (univ, Some(term_map), Some(terms_vec), Some(vars_map))
        } else {
            let univ = prod.sg_close(gens.clone())?;
            (univ, None, None, None)
        };
        
        let size = univ.len();
        
        // Create element to index mapping
        let mut univ_hash_map = HashMap::new();
        for (k, ia) in univ.iter().enumerate() {
            univ_hash_map.insert(ia.clone(), k);
        }
        
        // Create universe set
        let universe: HashSet<IntArray> = univ.iter().cloned().collect();
        
        let mut sub_prod = SubProductAlgebra {
            name,
            description: None,
            product_algebra: prod,
            gens,
            univ,
            thin_generators: false,
            decompose: false,
            univ_hash_map,
            terms,
            term_map,
            variables: None,
            vars_map,
            universe,
            operations: Vec::new(),
            similarity_type: None,
            monitor: None,
            con: None,
            sub: None,
        };
        
        // Make operations
        sub_prod.make_operations()?;
        
        Ok(sub_prod)
    }
    
    /// Construct a SubProductAlgebra with pre-computed universe.
    /// 
    /// This is useful for reading from a file without recalculating the universe.
    /// 
    /// # Arguments
    /// * `name` - The name of the algebra
    /// * `prod` - The underlying product algebra
    /// * `gens` - The generators as IntArray list
    /// * `univ_list` - The pre-computed universe
    /// 
    /// # Returns
    /// * `Ok(SubProductAlgebra)` - Successfully created subproduct algebra
    /// * `Err(String)` - If construction fails
    pub fn new_with_universe_safe(
        name: String,
        prod: BigProductAlgebra,
        gens: Vec<IntArray>,
        univ_list: Vec<IntArray>,
    ) -> Result<Self, String> {
        let mut sub_prod = SubProductAlgebra {
            name,
            description: None,
            product_algebra: prod,
            gens: gens.clone(),
            univ: univ_list.clone(),
            thin_generators: false,
            decompose: false,
            univ_hash_map: HashMap::new(),
            terms: None,
            term_map: None,
            variables: None,
            vars_map: None,
            universe: HashSet::new(),
            operations: Vec::new(),
            similarity_type: None,
            monitor: None,
            con: None,
            sub: None,
        };
        
        // Create element to index mapping
        for (k, ia) in univ_list.iter().enumerate() {
            sub_prod.univ_hash_map.insert(ia.clone(), k);
        }
        
        // Create universe set
        sub_prod.universe = univ_list.iter().cloned().collect();
        
        // Make operations
        sub_prod.make_operations()?;
        
        Ok(sub_prod)
    }
    
    /// Setup the generator to variable mapping for term computation.
    /// 
    /// # Arguments
    /// * `gens` - The generators
    /// 
    /// # Returns
    /// * `Ok(HashMap)` - The term map
    /// * `Err(String)` - If setup fails
    fn setup_gens_to_vars_map(gens: &[IntArray]) -> Result<HashMap<IntArray, Box<dyn Term>>, String> {
        let mut term_map = HashMap::new();
        
        match gens.len() {
            0 => {},
            1 => {
                term_map.insert(gens[0].clone(), Box::new(VariableImp::x()) as Box<dyn Term>);
            },
            2 => {
                term_map.insert(gens[0].clone(), Box::new(VariableImp::x()) as Box<dyn Term>);
                term_map.insert(gens[1].clone(), Box::new(VariableImp::y()) as Box<dyn Term>);
            },
            3 => {
                term_map.insert(gens[0].clone(), Box::new(VariableImp::x()) as Box<dyn Term>);
                term_map.insert(gens[1].clone(), Box::new(VariableImp::y()) as Box<dyn Term>);
                term_map.insert(gens[2].clone(), Box::new(VariableImp::z()) as Box<dyn Term>);
            },
            _ => {
                for (k, gen) in gens.iter().enumerate() {
                    let var_name = format!("x_{}", k);
                    term_map.insert(gen.clone(), Box::new(VariableImp::new(&var_name)) as Box<dyn Term>);
                }
            }
        }
        
        Ok(term_map)
    }
    
    /// Create operations for this algebra based on the product algebra operations.
    fn make_operations(&mut self) -> Result<(), String> {
        let size = self.univ.len() as i32;
        let prod_ops = self.product_algebra.operations();
        
        for prod_op in prod_ops {
            let op_sym = prod_op.symbol().clone();
            let arity = prod_op.arity();
            
            // Create a new operation for the subalgebra
            // We need to capture the necessary data for the closure
            let univ = self.univ.clone();
            let univ_hash_map = self.univ_hash_map.clone();
            
            // Note: This is a simplified implementation
            // The full Java version has more complex logic with table operations
            let op = AbstractIntOperation::new_with_symbol_safe(op_sym, size)?;
            
            self.operations.push(Box::new(op));
        }
        
        Ok(())
    }
    
    /// Transpose a list of IntArrays (swap rows and columns).
    /// 
    /// # Arguments
    /// * `lst` - The list to transpose
    /// 
    /// # Returns
    /// * `Ok(Vec<IntArray>)` - The transposed list
    /// * `Err(String)` - If the list is empty or has inconsistent sizes
    pub fn transpose(lst: &[IntArray]) -> Result<Vec<IntArray>, String> {
        if lst.is_empty() {
            return Err("Cannot transpose empty list".to_string());
        }
        
        let k = lst.len();
        let n = lst[0].universe_size();
        
        let mut transpose = Vec::with_capacity(n);
        for i in 0..n {
            let mut ith_proj = Vec::with_capacity(k);
            for j in 0..k {
                let val = lst[j].get(i).ok_or_else(|| format!("Index {} out of bounds", i))?;
                ith_proj.push(val);
            }
            transpose.push(IntArray::from_array(ith_proj)?);
        }
        
        Ok(transpose)
    }
    
    /// Get the generators of this algebra.
    pub fn generators(&self) -> &[IntArray] {
        &self.gens
    }
    
    /// Get the universe list.
    pub fn get_universe_list(&self) -> &[IntArray] {
        &self.univ
    }
    
    /// Get the universe order (element to index mapping).
    pub fn get_universe_order(&self) -> &HashMap<IntArray, usize> {
        &self.univ_hash_map
    }
    
    /// Get the underlying product algebra.
    pub fn get_product_algebra(&self) -> &BigProductAlgebra {
        &self.product_algebra
    }
    
    /// Get the super algebra (same as product algebra).
    pub fn super_algebra(&self) -> &BigProductAlgebra {
        &self.product_algebra
    }
    
    /// Get the congruence lattice (lazy initialization).
    /// 
    /// # Returns
    /// A reference to the congruence lattice
    pub fn con(&mut self) -> &crate::alg::conlat::CongruenceLattice {
        if self.con.is_none() {
            // Create congruence lattice using the type-erased wrapper
            use crate::alg::conlat::congruence_lattice::SmallAlgebraWrapper;
            
            // Clone this algebra as a trait object
            let alg_box = Box::new(self.clone()) as Box<dyn SmallAlgebra<UniverseItem = IntArray>>;
            let wrapper = Box::new(SmallAlgebraWrapper::new(alg_box));
            self.con = Some(Box::new(crate::alg::conlat::CongruenceLattice::new(wrapper)));
        }
        self.con.as_ref().unwrap()
    }
    
    /// Get the subalgebra lattice (lazy initialization).
    /// 
    /// # Returns
    /// A reference to the subalgebra lattice
    /// 
    /// # Note
    /// This method is not yet implemented for SubProductAlgebra.
    /// It requires a different approach due to IntArray universe type.
    pub fn sub(&mut self) -> &crate::alg::sublat::SubalgebraLattice {
        if self.sub.is_none() {
            panic!("sub() method not yet implemented for SubProductAlgebra");
        }
        self.sub.as_ref().unwrap()
    }
    
    /// Get the terms array (if terms were computed).
    pub fn get_terms(&self) -> Option<&[Box<dyn Term>]> {
        self.terms.as_deref()
    }
    
    /// Get the term associated with an element.
    /// 
    /// # Arguments
    /// * `elt` - The element as IntArray
    /// 
    /// # Returns
    /// The term for the element, or None if not found or terms not computed
    pub fn get_term(&self, elt: &IntArray) -> Option<&dyn Term> {
        if let Some(terms) = &self.terms {
            if let Some(&idx) = self.univ_hash_map.get(elt) {
                return Some(terms[idx].as_ref());
            }
        }
        None
    }
    
    /// Get the term map.
    pub fn get_term_map(&self) -> Option<&HashMap<IntArray, Box<dyn Term>>> {
        self.term_map.as_ref()
    }
    
    /// Get the variables corresponding to generators.
    pub fn get_variables(&self) -> Option<Vec<VariableImp>> {
        if let Some(vars) = &self.variables {
            return Some(vars.clone());
        }
        
        if self.terms.is_none() || self.gens.is_empty() {
            return None;
        }
        
        let terms = self.terms.as_ref().unwrap();
        let mut ans = Vec::new();
        
        for i in 0..self.gens.len() {
            if i < terms.len() && terms[i].isa_variable() {
                // Extract variable name and create VariableImp
                let var_name = terms[i].to_string();
                ans.push(VariableImp::new(&var_name));
            }
        }
        
        Some(ans)
    }
    
    /// Get the variable to generator mapping.
    pub fn get_variable_to_generator_map(&self) -> Option<&HashMap<VariableImp, IntArray>> {
        self.vars_map.as_ref()
    }
    
    /// Get the element from a term (linear search).
    /// 
    /// # Arguments
    /// * `t` - The term to search for
    /// 
    /// # Returns
    /// The element as IntArray, or None if not found
    pub fn get_element_from_term(&self, t: &dyn Term) -> Option<IntArray> {
        if let Some(terms) = &self.terms {
            for (i, term) in terms.iter().enumerate() {
                if term.to_string() == t.to_string() {
                    return Some(self.univ[i].clone());
                }
            }
        }
        None
    }
    
    /// Get the index of an element.
    /// 
    /// # Arguments
    /// * `elem` - The element as IntArray
    /// 
    /// # Returns
    /// * `Some(index)` - The index of the element
    /// * `None` - If the element is not in the universe
    pub fn element_index(&self, elem: &IntArray) -> Option<usize> {
        self.univ_hash_map.get(elem).copied()
    }
    
    /// Get an element by its index.
    /// 
    /// # Arguments
    /// * `index` - The index of the element
    /// 
    /// # Returns
    /// * `Some(element)` - The element at the index
    /// * `None` - If the index is out of bounds
    pub fn get_element(&self, index: usize) -> Option<&IntArray> {
        self.univ.get(index)
    }
    
    /// Set whether to thin generators.
    pub fn set_thin_generators(&mut self, v: bool) {
        self.thin_generators = v;
    }
    
    /// Get whether generators are thinned.
    pub fn get_thin_generators(&self) -> bool {
        self.thin_generators
    }
    
    /// Set whether to decompose.
    pub fn set_decompose(&mut self, v: bool) {
        self.decompose = v;
    }
    
    /// Get whether decomposed.
    pub fn get_decompose(&self) -> bool {
        self.decompose
    }
    
    /// Get the cardinality of this algebra.
    pub fn cardinality(&self) -> i32 {
        self.univ.len() as i32
    }
    
    /// Make operation tables for all operations.
    /// 
    /// This method creates operation tables up to a certain size limit.
    pub fn make_operation_tables(&mut self) {
        const MAX_ALG_SIZE_FOR_OP_TABLES: i32 = 8000000;
        
        let input_size = self.input_size();
        if input_size < 0 || input_size > MAX_ALG_SIZE_FOR_OP_TABLES {
            return;
        }
        
        for op in &mut self.operations {
            // Try to make table, handling potential OOM
            // Note: In Rust we can't easily catch OOM, so this is best-effort
            match op.make_table() {
                Ok(_) => {},
                Err(_) => {
                    // Failed to make table, continue with next operation
                }
            }
        }
    }
    
    /// Calculate the input size for operation tables.
    fn input_size(&self) -> i32 {
        // This is a simplified version
        // The full implementation would compute size^max_arity
        let size = self.cardinality();
        if self.operations.is_empty() {
            return 0;
        }
        
        let mut max_arity = 0;
        for op in &self.operations {
            if op.arity() > max_arity {
                max_arity = op.arity();
            }
        }
        
        if max_arity == 0 {
            return 0;
        }
        
        // Calculate size^max_arity with overflow check
        let mut result: i64 = 1;
        for _ in 0..max_arity {
            result = result.saturating_mul(size as i64);
            if result > i32::MAX as i64 {
                return -1;
            }
        }
        
        result as i32
    }
}

impl Display for SubProductAlgebra {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "SubProductAlgebra(name={}, size={})", self.name, self.univ.len())
    }
}

impl Algebra for SubProductAlgebra {
    type UniverseItem = IntArray;
    
    fn universe(&self) -> Box<dyn Iterator<Item = Self::UniverseItem>> {
        Box::new(self.univ.clone().into_iter())
    }
    
    fn cardinality(&self) -> i32 {
        self.univ.len() as i32
    }
    
    fn input_size(&self) -> i32 {
        self.input_size()
    }
    
    fn is_unary(&self) -> bool {
        self.operations.iter().all(|op| op.arity() <= 1)
    }
    
    fn iterator(&self) -> Box<dyn Iterator<Item = Self::UniverseItem>> {
        Box::new(self.univ.clone().into_iter())
    }
    
    fn operations(&self) -> Vec<Box<dyn Operation>> {
        // Clone the operations (this is a simplified version)
        // In the full implementation, we'd properly clone the operations
        Vec::new()
    }
    
    fn get_operation(&self, sym: &OperationSymbol) -> Option<Box<dyn Operation>> {
        None // Simplified
    }
    
    fn get_operations_map(&self) -> HashMap<OperationSymbol, Box<dyn Operation>> {
        HashMap::new() // Simplified
    }
    
    fn name(&self) -> &str {
        &self.name
    }
    
    fn set_name(&mut self, name: String) {
        self.name = name;
    }
    
    fn description(&self) -> Option<&str> {
        self.description.as_deref()
    }
    
    fn set_description(&mut self, desc: Option<String>) {
        self.description = desc;
    }
    
    fn similarity_type(&self) -> &SimilarityType {
        self.product_algebra.similarity_type()
    }
    
    fn update_similarity_type(&mut self) {
        // Delegate to product algebra
    }
    
    fn is_similar_to(&self, other: &dyn Algebra<UniverseItem = Self::UniverseItem>) -> bool {
        self.similarity_type() == other.similarity_type()
    }
    
    fn make_operation_tables(&mut self) {
        self.make_operation_tables();
    }
    
    fn constant_operations(&self) -> Vec<Box<dyn Operation>> {
        Vec::new() // Simplified
    }
    
    fn is_idempotent(&self) -> bool {
        false // Simplified
    }
    
    fn is_total(&self) -> bool {
        true
    }
    
    fn monitoring(&self) -> bool {
        self.monitor.is_some()
    }
    
    fn get_monitor(&self) -> Option<&dyn ProgressMonitor> {
        self.monitor.as_deref()
    }
    
    fn set_monitor(&mut self, monitor: Option<Box<dyn ProgressMonitor>>) {
        self.monitor = monitor;
    }
}

impl Clone for SubProductAlgebra {
    fn clone(&self) -> Self {
        SubProductAlgebra {
            name: self.name.clone(),
            description: self.description.clone(),
            product_algebra: self.product_algebra.clone(),
            gens: self.gens.clone(),
            univ: self.univ.clone(),
            thin_generators: self.thin_generators,
            decompose: self.decompose,
            univ_hash_map: self.univ_hash_map.clone(),
            terms: None, // Don't clone terms (too complex)
            term_map: None,
            variables: None,
            vars_map: None,
            universe: self.universe.clone(),
            operations: Vec::new(), // Don't clone operations
            similarity_type: None,
            monitor: None,
            con: None, // Don't clone cached lattices
            sub: None,
        }
    }
}

impl SmallAlgebra for SubProductAlgebra {
    fn get_operation_ref(&self, sym: &OperationSymbol) -> Option<&dyn Operation> {
        None // Simplified
    }
    
    fn get_operations_ref(&self) -> Vec<&dyn Operation> {
        Vec::new() // Simplified
    }
    
    fn clone_box(&self) -> Box<dyn SmallAlgebra<UniverseItem = Self::UniverseItem>> {
        Box::new(self.clone())
    }
    
    fn get_element(&self, k: usize) -> Option<Self::UniverseItem> {
        self.univ.get(k).cloned()
    }
    
    fn parent(&self) -> Option<&dyn SmallAlgebra<UniverseItem = Self::UniverseItem>> {
        None
    }
    
    fn parents(&self) -> Option<Vec<&dyn SmallAlgebra<UniverseItem = Self::UniverseItem>>> {
        None
    }
    
    fn reset_con_and_sub(&mut self) {
        // No cached lattices in partial implementation
    }
    
    fn element_index(&self, obj: &Self::UniverseItem) -> Option<usize> {
        self.element_index(obj)
    }
    
    fn get_universe_list(&self) -> Option<Vec<Self::UniverseItem>> {
        Some(self.univ.clone())
    }
    
    fn get_universe_order(&self) -> Option<HashMap<Self::UniverseItem, usize>> {
        Some(self.univ_hash_map.clone())
    }
    
    fn convert_to_default_value_ops(&mut self) {
        panic!("Only for basic algebras");
    }
    
    fn algebra_type(&self) -> AlgebraType {
        AlgebraType::Subproduct
    }
}
