"""
Test suite for Subalgebra implementation in UACalc.

This module tests the new optimized Rust implementation of subalgebras,
including parent algebra links, index mapping, and API compatibility.
"""

import pytest
from typing import List

from uacalc import (
    create_algebra, create_operation, Algebra, Operation
)
from uacalc.algebra import create_subalgebra, AlgebraBuilder


class TestSubalgebraCreation:
    """Test basic subalgebra creation functionality."""
    
    def test_create_subalgebra_basic(self):
        """Test basic subalgebra creation with simple algebra."""
        # Create Z4 with addition mod 4
        z4 = AlgebraBuilder("Z4", 4)
        z4.add_binary_operation("add", [
            [0, 1, 2, 3],
            [1, 2, 3, 0], 
            [2, 3, 0, 1],
            [3, 0, 1, 2]
        ])
        algebra = z4.build()
        
        # Create subalgebra generated by {1}
        subalgebra = create_subalgebra(algebra, [1])
        
        # Test basic properties
        assert subalgebra.cardinality == 4  # Should generate full Z4
        assert subalgebra.universe == [0, 1, 2, 3]
        assert len(subalgebra.operations()) == 1
        assert hasattr(subalgebra, 'name')

    def test_create_subalgebra_single_element(self):
        """Test subalgebra with single element generator."""
        # Create algebra with identity operation
        algebra = AlgebraBuilder("test", 3)
        algebra.add_unary_operation("id", [0, 1, 2])
        built_algebra = algebra.build()
        
        # Create subalgebra generated by {0}
        subalgebra = create_subalgebra(built_algebra, [0])
        
        # Should only contain {0} since id(0) = 0
        assert subalgebra.cardinality == 1
        assert subalgebra.universe == [0]

    def test_create_subalgebra_multiple_generators(self):
        """Test subalgebra with multiple generators."""
        # Create simple algebra
        algebra = AlgebraBuilder("test", 4)
        algebra.add_unary_operation("id", [0, 1, 2, 3])
        built_algebra = algebra.build()
        
        # Create subalgebra with multiple generators
        subalgebra = create_subalgebra(built_algebra, [0, 2])
        
        # Should contain at least the generators
        assert subalgebra.cardinality >= 2
        assert 0 in subalgebra.universe

    def test_create_subalgebra_with_constants(self):
        """Test subalgebra creation with constant operations."""
        # Create algebra with constant and unary operation
        algebra = AlgebraBuilder("test", 3)
        algebra.add_constant("zero", 0)
        algebra.add_unary_operation("id", [0, 1, 2])
        built_algebra = algebra.build()
        
        # Create subalgebra generated by {1}
        subalgebra = create_subalgebra(built_algebra, [1])
        
        # Should contain {0, 1} due to constant operation
        assert subalgebra.cardinality >= 2


class TestSubalgebraOperations:
    """Test subalgebra operation evaluation and correctness."""
    
    def test_subalgebra_operation_evaluation(self):
        """Test that subalgebra operations work correctly."""
        # Create Z4 with addition
        z4 = AlgebraBuilder("Z4", 4)
        z4.add_binary_operation("add", [
            [0, 1, 2, 3],
            [1, 2, 3, 0],
            [2, 3, 0, 1], 
            [3, 0, 1, 2]
        ])
        algebra = z4.build()
        
        # Create subalgebra
        subalgebra = create_subalgebra(algebra, [1])
        
        # Test operation evaluation
        add_op = subalgebra.operation_by_symbol("add")
        
        # Test some additions
        assert add_op.value([1, 2]) == 3  # 1 + 2 = 3 in Z4
        assert add_op.value([2, 3]) == 1  # 2 + 3 = 1 in Z4
        assert add_op.value([0, 0]) == 0  # 0 + 0 = 0 in Z4

    def test_subalgebra_multiple_operations(self):
        """Test subalgebra with multiple operations."""
        # Create algebra with addition and a unary operation
        algebra = AlgebraBuilder("test", 3)
        algebra.add_binary_operation("add", [
            [0, 1, 2],
            [1, 2, 0],
            [2, 0, 1]
        ])
        algebra.add_unary_operation("neg", [0, 2, 1])  # negation in Z3
        built_algebra = algebra.build()
        
        # Create subalgebra
        subalgebra = create_subalgebra(built_algebra, [1])
        
        # Test both operations exist
        add_op = subalgebra.operation_by_symbol("add")
        neg_op = subalgebra.operation_by_symbol("neg")
        
        assert add_op.arity() == 2
        assert neg_op.arity() == 1
        
        # Test operation results
        assert neg_op.value([1]) == 2  # neg(1) = 2 in Z3


class TestSubalgebraParentLinks:
    """Test parent algebra links and index mapping functionality."""
    
    def test_parent_algebra_link(self):
        """Test that subalgebra maintains link to parent algebra."""
        # Create parent algebra
        parent = AlgebraBuilder("parent", 4)
        parent.add_unary_operation("id", [0, 1, 2, 3])
        parent_algebra = parent.build()
        
        # Create subalgebra
        subalgebra = create_subalgebra(parent_algebra, [0, 2])
        
        # Test parent algebra access (if available)
        if hasattr(subalgebra, 'parent_algebra'):
            parent_ref = subalgebra.parent_algebra()
            assert parent_ref is not None
            assert parent_ref.cardinality == 4

    def test_index_mapping(self):
        """Test index mapping between parent and subalgebra."""
        # Create parent algebra
        parent = AlgebraBuilder("parent", 5)
        parent.add_unary_operation("id", [0, 1, 2, 3, 4])
        parent_algebra = parent.build()
        
        # Create subalgebra with non-contiguous elements
        subalgebra = create_subalgebra(parent_algebra, [1, 3])
        
        # Test index mapping methods (if available)
        if hasattr(subalgebra, 'index_in_subalgebra'):
            # Test parent to sub mapping
            assert subalgebra.index_in_subalgebra(0) is None
            assert subalgebra.index_in_subalgebra(1) is not None
            assert subalgebra.index_in_subalgebra(2) is None  
            assert subalgebra.index_in_subalgebra(3) is not None
            assert subalgebra.index_in_subalgebra(4) is None
            
        if hasattr(subalgebra, 'element_in_parent'):
            # Test sub to parent mapping
            parent_elem_0 = subalgebra.element_in_parent(0)
            parent_elem_1 = subalgebra.element_in_parent(1) 
            assert parent_elem_0 in [1, 3]  # Should be one of the generators
            assert parent_elem_1 in [1, 3]  # Should be the other generator
            assert parent_elem_0 != parent_elem_1

    def test_subuniverse_array(self):
        """Test subuniverse array access."""
        # Create algebra
        algebra = AlgebraBuilder("test", 4)
        algebra.add_unary_operation("id", [0, 1, 2, 3])
        built_algebra = algebra.build()
        
        # Create subalgebra
        subalgebra = create_subalgebra(built_algebra, [1, 3])
        
        # Test subuniverse array (if available)
        if hasattr(subalgebra, 'subuniverse_array'):
            sub_array = subalgebra.subuniverse_array()
            assert isinstance(sub_array, list)
            assert 1 in sub_array
            assert 3 in sub_array


class TestSubalgebraErrorHandling:
    """Test error handling and edge cases."""
    
    def test_empty_generators_error(self):
        """Test that empty generators list raises error."""
        algebra = AlgebraBuilder("test", 3)
        algebra.add_unary_operation("id", [0, 1, 2])
        built_algebra = algebra.build()
        
        with pytest.raises(ValueError, match="empty"):
            create_subalgebra(built_algebra, [])

    def test_invalid_generator_error(self):
        """Test that invalid generator indices raise errors."""
        algebra = AlgebraBuilder("test", 3)
        algebra.add_unary_operation("id", [0, 1, 2])
        built_algebra = algebra.build()
        
        with pytest.raises(ValueError):
            create_subalgebra(built_algebra, [5])  # Out of bounds
            
        with pytest.raises(ValueError):
            create_subalgebra(built_algebra, [-1])  # Negative

    def test_out_of_bounds_access(self):
        """Test error handling for out of bounds access."""
        algebra = AlgebraBuilder("test", 3)
        algebra.add_unary_operation("id", [0, 1, 2])
        built_algebra = algebra.build()
        
        subalgebra = create_subalgebra(built_algebra, [0])
        
        # Test out of bounds operation evaluation
        op = subalgebra.operation_by_symbol("id")
        with pytest.raises((IndexError, ValueError)):
            op.value([5])  # Out of bounds argument


class TestSubalgebraAPICompatibility:
    """Test backward compatibility with existing API."""
    
    def test_with_progress_parameter(self):
        """Test that with_progress parameter is accepted."""
        algebra = AlgebraBuilder("test", 3)
        algebra.add_unary_operation("id", [0, 1, 2])
        built_algebra = algebra.build()
        
        # Create callback function
        progress_calls = []
        def progress_callback(progress: float, message: str):
            progress_calls.append((progress, message))
        
        # Should accept with_progress parameter without error
        subalgebra = create_subalgebra(built_algebra, [1], with_progress=progress_callback)
        assert subalgebra.cardinality >= 1

    def test_return_type_compatibility(self):
        """Test that returned subalgebra is compatible with Algebra interface."""
        algebra = AlgebraBuilder("test", 3)
        algebra.add_unary_operation("id", [0, 1, 2])
        built_algebra = algebra.build()
        
        subalgebra = create_subalgebra(built_algebra, [1])
        
        # Test Algebra interface methods
        assert hasattr(subalgebra, 'cardinality')
        assert hasattr(subalgebra, 'universe')
        assert hasattr(subalgebra, 'operations')
        assert hasattr(subalgebra, 'operation_by_symbol')
        
        # Test that methods work
        assert isinstance(subalgebra.cardinality, int)
        assert isinstance(subalgebra.universe, list)
        assert isinstance(subalgebra.operations(), list)

    def test_existing_code_compatibility(self):
        """Test that existing code using create_subalgebra still works."""
        # This simulates existing user code
        def existing_user_function(algebra: Algebra, gens: List[int]) -> int:
            """Simulated existing user function."""
            sub = create_subalgebra(algebra, gens)
            return sub.cardinality
        
        # Create test algebra
        algebra = AlgebraBuilder("test", 4)
        algebra.add_unary_operation("id", [0, 1, 2, 3])
        built_algebra = algebra.build()
        
        # Test existing function works
        result = existing_user_function(built_algebra, [1, 2])
        assert isinstance(result, int)
        assert result >= 2


class TestSubalgebraPerformance:
    """Test performance characteristics and optimization."""
    
    def test_large_algebra_subalgebra(self):
        """Test subalgebra creation on larger algebras."""
        # Create larger algebra (but not too large for test performance)
        size = 10
        algebra = AlgebraBuilder("large", size)
        algebra.add_binary_operation("add", [
            [(i + j) % size for j in range(size)]
            for i in range(size)
        ])
        built_algebra = algebra.build()
        
        # Create subalgebra
        subalgebra = create_subalgebra(built_algebra, [1])
        
        # Should complete without issues
        assert subalgebra.cardinality <= size
        assert len(subalgebra.operations()) == 1

    def test_closure_computation_correctness(self):
        """Test that closure computation is correct."""
        # Create Z6 with addition mod 6
        z6 = AlgebraBuilder("Z6", 6)
        z6.add_binary_operation("add", [
            [(i + j) % 6 for j in range(6)]
            for i in range(6)
        ])
        algebra = z6.build()
        
        # Subalgebra generated by 2 should be {0, 2, 4}
        subalgebra = create_subalgebra(algebra, [2])
        
        # Test that it has the right size
        assert subalgebra.cardinality == 3
        
        # Test that operations work correctly
        add_op = subalgebra.operation_by_symbol("add")
        
        # The subalgebra should be isomorphic to Z3
        # We can't directly test the mapping without knowing the internal structure,
        # but we can test that operations are closed
        for i in range(subalgebra.cardinality):
            for j in range(subalgebra.cardinality):
                result = add_op.value([i, j])
                assert 0 <= result < subalgebra.cardinality


class TestSubalgebraIntegration:
    """Test integration with other UACalc functionality."""
    
    def test_subalgebra_of_subalgebra(self):
        """Test creating subalgebra of subalgebra."""
        # Create base algebra
        algebra = AlgebraBuilder("base", 4)
        algebra.add_unary_operation("id", [0, 1, 2, 3])
        built_algebra = algebra.build()
        
        # Create first subalgebra
        sub1 = create_subalgebra(built_algebra, [0, 1, 2])
        
        # Create subalgebra of subalgebra
        sub2 = create_subalgebra(sub1, [0])
        
        # Should work and be smaller
        assert sub2.cardinality <= sub1.cardinality
        assert sub2.cardinality <= built_algebra.cardinality

    def test_subalgebra_with_different_algebra_types(self):
        """Test subalgebra creation with different types of algebras."""
        # Test with various algebra structures
        
        # Boolean algebra (simplified)
        bool_alg = AlgebraBuilder("bool", 2)
        bool_alg.add_binary_operation("and", [[0, 0], [0, 1]])
        bool_alg.add_binary_operation("or", [[0, 1], [1, 1]])
        bool_algebra = bool_alg.build()
        
        bool_sub = create_subalgebra(bool_algebra, [1])
        assert bool_sub.cardinality >= 1
        
        # Lattice-like structure  
        lattice = AlgebraBuilder("lattice", 3)
        lattice.add_binary_operation("meet", [
            [0, 0, 0],
            [0, 1, 1], 
            [0, 1, 2]
        ])
        lattice_algebra = lattice.build()
        
        lattice_sub = create_subalgebra(lattice_algebra, [1])
        assert lattice_sub.cardinality >= 1


if __name__ == "__main__":
    pytest.main([__file__])
