//! Congruence generation (Cg) algorithm implementation
//!
//! This module provides efficient congruence generation algorithms that
//! compute the least congruence containing a given set of pairs.

use crate::algebra::SmallAlgebra;
use crate::operation::Operation;
use crate::partition::{BasicPartition, Partition};
use crate::utils::{power_checked, MAX_OPERATION_ARITY};
use crate::{UACalcError, UACalcResult};
use std::collections::{HashSet, VecDeque};
use arrayvec::ArrayVec;
use std::sync::Arc;

/// Lightweight operation info for efficient propagation
struct OperationInfo<'a> {
    arity: usize,
    table_opt: Option<&'a crate::operation::FlatOperationTable>,
}

/// Congruence generator for efficient congruence computation
pub struct CongruenceGenerator<'a> {
    algebra: &'a dyn SmallAlgebra,
    partition: BasicPartition,
    dirty_pairs: VecDeque<(usize, usize)>,
    flat_table_ops: HashSet<usize>,
    progress_callback: Option<Box<dyn super::ProgressCallback>>,
    // Pre-allocated argument buffer for reuse
    args_buffer: ArrayVec<usize, MAX_OPERATION_ARITY>,
}

impl<'a> CongruenceGenerator<'a> {
    /// Create a new congruence generator for the given algebra
    pub fn new(algebra: &'a dyn SmallAlgebra) -> Self {
        let size = algebra.cardinality();
        Self {
            algebra,
            partition: BasicPartition::new(size),
            dirty_pairs: VecDeque::with_capacity(size * size), // Pre-allocate based on universe size
            flat_table_ops: HashSet::new(),
            progress_callback: None,
            args_buffer: ArrayVec::new(),
        }
    }

    /// Set a progress callback for long-running computations
    pub fn with_progress_callback(mut self, callback: Box<dyn super::ProgressCallback>) -> Self {
        self.progress_callback = Some(callback);
        self
    }

    /// Set a progress callback using a closure for long-running computations
    pub fn with_progress_closure<F>(self, cb: F) -> Self
    where
        F: Fn(f64) + Send + Sync + 'static,
    {
        let callback = Box::new(ProgressCallbackWrapper { callback: cb });
        self.with_progress_callback(callback)
    }

    /// Compute the congruence generated by the given pairs
    pub fn compute_congruence(&mut self, pairs: &[(usize, usize)]) -> UACalcResult<BasicPartition> {
        let size = self.algebra.cardinality();

        // Validate pairs
        for &(a, b) in pairs {
            if a >= size || b >= size {
                return Err(UACalcError::InvalidOperation {
                    message: format!("Invalid pair ({}, {}) for algebra of size {}", a, b, size),
                });
            }
        }

        // Initialize with finest partition
        self.partition = BasicPartition::new(size);
        self.dirty_pairs.clear();
        self.flat_table_ops.clear();

        // Add seed pairs to dirty queue
        for &(a, b) in pairs {
            if a != b {
                self.add_dirty_pair(a, b)?;
            }
        }

        // Main propagation loop
        while !self.dirty_pairs.is_empty() {
            // Check for cancellation
            if let Some(ref callback) = self.progress_callback {
                if callback.should_cancel() {
                    return Err(UACalcError::Cancelled {
                        message: "Congruence generation was cancelled".to_string(),
                    });
                }

                let progress = 1.0 - (self.dirty_pairs.len() as f64 / (size * size) as f64);
                callback.report_progress(progress);
            }

            // Early termination if we have the coarsest partition
            if self.partition.num_blocks() == 1 {
                break;
            }

            let (a, b) = self.dirty_pairs.pop_front().unwrap();

            // Propagate this pair through all operations
            self.propagate_through_operations(a, b)?;
        }

        Ok(self.partition.clone())
    }

    /// Add a pair to the dirty queue if it's not already unified
    fn add_dirty_pair(&mut self, a: usize, b: usize) -> UACalcResult<()> {
        if !self.partition.same_block(a, b)? {
            self.partition.union(a, b)?;
            self.dirty_pairs.push_back((a, b));
        }
        Ok(())
    }

    /// Propagate a pair through all operations in the algebra
    fn propagate_through_operations(&mut self, a: usize, b: usize) -> UACalcResult<()> {
        for (op_idx, operation) in self.algebra.operations().iter().enumerate() {
            let op_guard = operation
                .lock()
                .map_err(|_| UACalcError::InvalidOperation {
                    message: "Failed to lock operation".to_string(),
                })?;
            
            // Create lightweight operation info
            let op_info = OperationInfo {
                arity: op_guard.arity(),
                table_opt: op_guard.get_table(),
            };
            
            self.propagate_operation(&*op_guard, &op_info, a, b, op_idx)?;
        }
        Ok(())
    }

    /// Check if operation has a flat table available and cache the result
    fn check_operation_table(&mut self, operation: &dyn Operation, op_idx: usize) -> bool {
        // Check if we've already determined this operation has a flat table
        if !self.flat_table_ops.contains(&op_idx) {
            // Check if this operation has a flat table available
            if operation.get_table().is_some() {
                self.flat_table_ops.insert(op_idx);
                return true;
            }
            return false;
        }
        true
    }

    /// Propagate a pair through a specific operation
    fn propagate_operation(
        &mut self,
        operation: &dyn Operation,
        op_info: &OperationInfo<'_>,
        a: usize,
        b: usize,
        op_idx: usize,
    ) -> UACalcResult<()> {
        let arity = op_info.arity;
        let size = self.algebra.cardinality();

        // Predeclare other_indices once and reuse
        let mut other_indices: ArrayVec<usize, MAX_OPERATION_ARITY> = ArrayVec::new();
        for _ in 0..arity - 1 {
            other_indices.push(0);
        }
        
        // Pre-allocate args buffer if needed
        if self.args_buffer.len() < arity {
            self.args_buffer.clear();
            self.args_buffer.extend(std::iter::repeat(0).take(arity));
        }

        // Use the pre-captured table_opt
        let table_opt = op_info.table_opt;

        // For each position where a~b can differ
        for pos in 0..arity {
            // Generate all (arity-1)-tuples for other positions
            let other_arity = arity - 1;
            let total_other_tuples = power_checked(size, other_arity).ok_or_else(|| {
                UACalcError::ArithmeticOverflow {
                    operation: format!("size^{} for tuple enumeration", other_arity),
                }
            })?;

            // Reset other_indices for this position
            other_indices.fill(0);

            for _ in 0..total_other_tuples {
                // Fill args with other arguments, skipping pos (reuse buffer)
                let mut other_idx = 0;
                for i in 0..arity {
                    if i != pos {
                        self.args_buffer[i] = other_indices[other_idx];
                        other_idx += 1;
                    }
                }

                // Set args[pos] = a and evaluate
                self.args_buffer[pos] = a;
                let result_a = if let Some(table) = table_opt {
                    table.value_at(&self.args_buffer)?
                } else {
                    operation.value(&self.args_buffer)?
                };

                // Set args[pos] = b and evaluate
                self.args_buffer[pos] = b;
                let result_b = if let Some(table) = table_opt {
                    table.value_at(&self.args_buffer)?
                } else {
                    operation.value(&self.args_buffer)?
                };

                // If results are in different blocks, union them
                if !self.partition.same_block(result_a, result_b)? {
                    self.add_dirty_pair(result_a, result_b)?;

                    // Early termination if partition becomes coarsest
                    if self.partition.num_blocks() == 1 {
                        return Ok(());
                    }
                }

                // Increment other_indices for next iteration
                let mut i = 0;
                while i < other_arity {
                    other_indices[i] += 1;
                    if other_indices[i] < size {
                        break;
                    }
                    other_indices[i] = 0;
                    i += 1;
                }
            }
        }

        Ok(())
    }
}

/// Progress callback wrapper for closures
struct ProgressCallbackWrapper<F> {
    callback: F,
}

impl<F> super::ProgressCallback for ProgressCallbackWrapper<F>
where
    F: Fn(f64) + Send + Sync,
{
    fn report_progress(&self, progress: f64) {
        (self.callback)(progress);
    }

    fn should_cancel(&self) -> bool {
        false
    }
}

/// Compute the congruence generated by the given pairs
pub fn cg(algebra: &dyn SmallAlgebra, pairs: &[(usize, usize)]) -> UACalcResult<BasicPartition> {
    let mut generator = CongruenceGenerator::new(algebra);
    generator.compute_congruence(pairs)
}

/// Compute the principal congruence Î¸(a, b) generated by a single pair
pub fn principal_congruence(
    algebra: &dyn SmallAlgebra,
    a: usize,
    b: usize,
) -> UACalcResult<BasicPartition> {
    cg(algebra, &[(a, b)])
}

/// Check if a partition is compatible with all operations in an algebra
pub fn is_compatible_with_operation(
    partition: &dyn Partition,
    operation: &dyn Operation,
) -> UACalcResult<bool> {
    let arity = operation.arity();
    let size = partition.size();

    // Allocate args buffer once
    let mut args = vec![0; arity];

    // For each pair of elements in the same block
    for block in partition.blocks()? {
        for i in 0..block.len() {
            for j in (i + 1)..block.len() {
                let a = block[i];
                let b = block[j];

                // Check all possible argument tuples
                let total_tuples = power_checked(size, arity).ok_or_else(|| {
                    UACalcError::ArithmeticOverflow {
                        operation: format!("size^{} for tuple enumeration", arity),
                    }
                })?;

                for _ in 0..total_tuples {
                    // For each position, test a and b
                    for pos in 0..arity {
                        let old = args[pos];
                        
                        // Test with a
                        args[pos] = a;
                        let result_a = operation.value(&args)?;
                        
                        // Test with b
                        args[pos] = b;
                        let result_b = operation.value(&args)?;
                        
                        // Restore original value
                        args[pos] = old;

                        // If results are in different blocks, partition is not compatible
                        if !partition.same_block(result_a, result_b)? {
                            return Ok(false);
                        }
                    }

                    // Increment args for next iteration
                    let mut i = 0;
                    while i < arity {
                        args[i] += 1;
                        if args[i] < size {
                            break;
                        }
                        args[i] = 0;
                        i += 1;
                    }
                }
            }
        }
    }

    Ok(true)
}

/// Check if a partition is a congruence (compatible with all operations)
pub fn is_congruence(algebra: &dyn SmallAlgebra, partition: &dyn Partition) -> UACalcResult<bool> {
    for operation in algebra.operations() {
        let op_guard = operation
            .lock()
            .map_err(|_| UACalcError::InvalidOperation {
                message: "Failed to lock operation".to_string(),
            })?;
        if !is_compatible_with_operation(partition, &*op_guard)? {
            return Ok(false);
        }
    }
    Ok(true)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::algebra::BasicAlgebra;
    use crate::operation::{OperationSymbol, TableOperation};

    #[test]
    fn test_cg_empty_pairs() {
        let algebra = BasicAlgebra::with_cardinality("A".to_string(), 3).unwrap();
        let result = cg(&algebra, &[]);
        assert!(result.is_ok());
        let partition = result.unwrap();
        assert_eq!(partition.num_blocks(), 3); // Finest partition
    }

    #[test]
    fn test_cg_single_pair() {
        let algebra = BasicAlgebra::with_cardinality("A".to_string(), 3).unwrap();
        let result = cg(&algebra, &[(0, 1)]);
        assert!(result.is_ok());
        let partition = result.unwrap();
        assert_eq!(partition.num_blocks(), 2); // {0,1}, {2}
    }

    #[test]
    fn test_cg_coarsest_partition() {
        let algebra = BasicAlgebra::with_cardinality("A".to_string(), 3).unwrap();
        let result = cg(&algebra, &[(0, 1), (1, 2)]);
        assert!(result.is_ok());
        let partition = result.unwrap();
        assert_eq!(partition.num_blocks(), 1); // Coarsest partition
    }

    #[test]
    fn test_principal_congruence() {
        let algebra = BasicAlgebra::with_cardinality("A".to_string(), 3).unwrap();
        let result = principal_congruence(&algebra, 0, 1);
        assert!(result.is_ok());
        let partition = result.unwrap();
        assert!(partition.same_block(0, 1).unwrap());
        assert!(!partition.same_block(0, 2).unwrap());
    }
}
