//! Congruence generation (Cg) algorithm implementation
//!
//! This module provides efficient congruence generation algorithms that
//! compute the least congruence containing a given set of pairs.

use crate::algebra::SmallAlgebra;
use crate::operation::Operation;
use crate::partition::{BasicPartition, Partition};
use crate::utils::{horner_decode, power_checked};
use crate::{UACalcError, UACalcResult};
use std::collections::{HashSet, VecDeque};

/// Congruence generator for efficient congruence computation
pub struct CongruenceGenerator<'a> {
    algebra: &'a dyn SmallAlgebra,
    partition: BasicPartition,
    dirty_pairs: VecDeque<(usize, usize)>,
    flat_table_ops: HashSet<usize>,
    progress_callback: Option<Box<dyn super::ProgressCallback>>,
}

impl<'a> CongruenceGenerator<'a> {
    /// Create a new congruence generator for the given algebra
    pub fn new(algebra: &'a dyn SmallAlgebra) -> Self {
        let size = algebra.cardinality();
        Self {
            algebra,
            partition: BasicPartition::new(size),
            dirty_pairs: VecDeque::new(),
            flat_table_ops: HashSet::new(),
            progress_callback: None,
        }
    }

    /// Set a progress callback for long-running computations
    pub fn with_progress_callback(mut self, callback: Box<dyn super::ProgressCallback>) -> Self {
        self.progress_callback = Some(callback);
        self
    }

    /// Set a progress callback using a closure for long-running computations
    pub fn with_progress_closure<F>(self, cb: F) -> Self
    where
        F: Fn(f64) + Send + Sync + 'static,
    {
        let callback = Box::new(ProgressCallbackWrapper { callback: cb });
        self.with_progress_callback(callback)
    }

    /// Compute the congruence generated by the given pairs
    pub fn compute_congruence(&mut self, pairs: &[(usize, usize)]) -> UACalcResult<BasicPartition> {
        let size = self.algebra.cardinality();

        // Validate pairs
        for &(a, b) in pairs {
            if a >= size || b >= size {
                return Err(UACalcError::InvalidOperation {
                    message: format!("Invalid pair ({}, {}) for algebra of size {}", a, b, size),
                });
            }
        }

        // Initialize with finest partition
        self.partition = BasicPartition::new(size);
        self.dirty_pairs.clear();
        self.flat_table_ops.clear();

        // Add seed pairs to dirty queue
        for &(a, b) in pairs {
            if a != b {
                self.add_dirty_pair(a, b)?;
            }
        }

        // Main propagation loop
        while !self.dirty_pairs.is_empty() {
            // Check for cancellation
            if let Some(ref callback) = self.progress_callback {
                if callback.should_cancel() {
                    return Err(UACalcError::Cancelled {
                        message: "Congruence generation was cancelled".to_string(),
                    });
                }

                let progress = 1.0 - (self.dirty_pairs.len() as f64 / (size * size) as f64);
                callback.report_progress(progress);
            }

            // Early termination if we have the coarsest partition
            if self.partition.num_blocks() == 1 {
                break;
            }

            let (a, b) = self.dirty_pairs.pop_front().unwrap();

            // Propagate this pair through all operations
            self.propagate_through_operations(a, b)?;
        }

        Ok(self.partition.clone())
    }

    /// Add a pair to the dirty queue if it's not already unified
    fn add_dirty_pair(&mut self, a: usize, b: usize) -> UACalcResult<()> {
        if !self.partition.same_block(a, b)? {
            self.partition.union(a, b)?;
            self.dirty_pairs.push_back((a, b));
        }
        Ok(())
    }

    /// Propagate a pair through all operations in the algebra
    fn propagate_through_operations(&mut self, a: usize, b: usize) -> UACalcResult<()> {
        for (op_idx, operation) in self.algebra.operations().iter().enumerate() {
            let op_guard = operation
                .lock()
                .map_err(|_| UACalcError::InvalidOperation {
                    message: "Failed to lock operation".to_string(),
                })?;
            self.propagate_operation(&*op_guard, a, b, op_idx)?;
        }
        Ok(())
    }

    /// Propagate a pair through a specific operation
    fn propagate_operation(
        &mut self,
        operation: &dyn Operation,
        a: usize,
        b: usize,
        op_idx: usize,
    ) -> UACalcResult<()> {
        let arity = operation.arity();
        let size = self.algebra.cardinality();

        // For each position where a~b can differ
        for pos in 0..arity {
            // Generate all (arity-1)-tuples for other positions
            let other_arity = arity - 1;
            let total_other_tuples = power_checked(size, other_arity).ok_or_else(|| {
                UACalcError::ArithmeticOverflow {
                    operation: format!("size^{} for tuple enumeration", other_arity),
                }
            })?;

            // Reuse a single buffer for efficiency
            let mut args = vec![0; arity];

            for other_tuple_idx in 0..total_other_tuples {
                let other_args = horner_decode(other_tuple_idx, size, other_arity);

                // Fill args with other arguments, skipping pos
                let mut other_idx = 0;
                for i in 0..arity {
                    if i != pos {
                        args[i] = other_args[other_idx];
                        other_idx += 1;
                    }
                }

                // Set args[pos] = a and evaluate
                args[pos] = a;
                let result_a = {
                    let table = operation.get_table();
                    if let Some(table) = table {
                        table.value_at(&args)?
                    } else {
                        operation.value(&args)?
                    }
                };

                // Set args[pos] = b and evaluate
                args[pos] = b;
                let result_b = {
                    let table = operation.get_table();
                    if let Some(table) = table {
                        table.value_at(&args)?
                    } else {
                        operation.value(&args)?
                    }
                };

                // If results are in different blocks, union them
                if !self.partition.same_block(result_a, result_b)? {
                    self.add_dirty_pair(result_a, result_b)?;

                    // Early termination if partition becomes coarsest
                    if self.partition.num_blocks() == 1 {
                        return Ok(());
                    }
                }
            }
        }

        Ok(())
    }
}

/// Progress callback wrapper for closures
struct ProgressCallbackWrapper<F> {
    callback: F,
}

impl<F> super::ProgressCallback for ProgressCallbackWrapper<F>
where
    F: Fn(f64) + Send + Sync,
{
    fn report_progress(&self, progress: f64) {
        (self.callback)(progress);
    }

    fn should_cancel(&self) -> bool {
        false
    }
}

/// Compute the congruence generated by the given pairs
pub fn cg(algebra: &dyn SmallAlgebra, pairs: &[(usize, usize)]) -> UACalcResult<BasicPartition> {
    let mut generator = CongruenceGenerator::new(algebra);
    generator.compute_congruence(pairs)
}

/// Compute the principal congruence Î¸(a, b) generated by a single pair
pub fn principal_congruence(
    algebra: &dyn SmallAlgebra,
    a: usize,
    b: usize,
) -> UACalcResult<BasicPartition> {
    cg(algebra, &[(a, b)])
}

/// Check if a partition is compatible with all operations in an algebra
pub fn is_compatible_with_operation(
    partition: &dyn Partition,
    operation: &dyn Operation,
) -> UACalcResult<bool> {
    let arity = operation.arity();
    let size = partition.size();

    // For each pair of elements in the same block
    for block in partition.blocks()? {
        for i in 0..block.len() {
            for j in (i + 1)..block.len() {
                let a = block[i];
                let b = block[j];

                // Check all possible argument tuples
                let total_tuples = size.pow(arity as u32);

                for tuple_idx in 0..total_tuples {
                    let args = horner_decode(tuple_idx, size, arity);

                    // Create tuples with a and b in each position
                    for pos in 0..arity {
                        let mut args_a = args.clone();
                        let mut args_b = args.clone();
                        args_a[pos] = a;
                        args_b[pos] = b;

                        let result_a = operation.value(&args_a)?;
                        let result_b = operation.value(&args_b)?;

                        // If results are in different blocks, partition is not compatible
                        if !partition.same_block(result_a, result_b)? {
                            return Ok(false);
                        }
                    }
                }
            }
        }
    }

    Ok(true)
}

/// Check if a partition is a congruence (compatible with all operations)
pub fn is_congruence(algebra: &dyn SmallAlgebra, partition: &dyn Partition) -> UACalcResult<bool> {
    for operation in algebra.operations() {
        let op_guard = operation
            .lock()
            .map_err(|_| UACalcError::InvalidOperation {
                message: "Failed to lock operation".to_string(),
            })?;
        if !is_compatible_with_operation(partition, &*op_guard)? {
            return Ok(false);
        }
    }
    Ok(true)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::algebra::BasicAlgebra;
    use crate::operation::{OperationSymbol, TableOperation};

    #[test]
    fn test_cg_empty_pairs() {
        let algebra = BasicAlgebra::with_cardinality("A".to_string(), 3).unwrap();
        let result = cg(&algebra, &[]);
        assert!(result.is_ok());
        let partition = result.unwrap();
        assert_eq!(partition.num_blocks(), 3); // Finest partition
    }

    #[test]
    fn test_cg_single_pair() {
        let algebra = BasicAlgebra::with_cardinality("A".to_string(), 3).unwrap();
        let result = cg(&algebra, &[(0, 1)]);
        assert!(result.is_ok());
        let partition = result.unwrap();
        assert_eq!(partition.num_blocks(), 2); // {0,1}, {2}
    }

    #[test]
    fn test_cg_coarsest_partition() {
        let algebra = BasicAlgebra::with_cardinality("A".to_string(), 3).unwrap();
        let result = cg(&algebra, &[(0, 1), (1, 2)]);
        assert!(result.is_ok());
        let partition = result.unwrap();
        assert_eq!(partition.num_blocks(), 1); // Coarsest partition
    }

    #[test]
    fn test_principal_congruence() {
        let algebra = BasicAlgebra::with_cardinality("A".to_string(), 3).unwrap();
        let result = principal_congruence(&algebra, 0, 1);
        assert!(result.is_ok());
        let partition = result.unwrap();
        assert!(partition.same_block(0, 1).unwrap());
        assert!(!partition.same_block(0, 2).unwrap());
    }
}
