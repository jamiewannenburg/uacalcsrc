use crate::algebra::{Algebra, SmallAlgebra};
use crate::binary_relation::{BasicBinaryRelation, BinaryRelation};
use crate::conlat::{cg, lattice_builder};
use crate::partition::{BasicPartition, Partition};
use crate::{UACalcError, UACalcResult};
use serde::{Deserialize, Serialize};
use std::any::Any;
use std::collections::{HashMap, HashSet};
use std::sync::Arc;

/// Trait for congruence lattice structures
pub trait CongruenceLattice: Send + Sync {
    /// Get the algebra this congruence lattice is for
    fn algebra(&self) -> &dyn SmallAlgebra;

    /// Get all congruences in the lattice
    fn congruences(&self) -> Vec<Box<dyn Partition>>;

    /// Get the number of congruences
    fn num_congruences(&self) -> usize;

    /// Get the bottom congruence (identity relation)
    fn bottom(&self) -> Box<dyn Partition>;

    /// Get the top congruence (universal relation)
    fn top(&self) -> Box<dyn Partition>;

    /// Check if a partition is a congruence
    fn is_congruence(&self, partition: &dyn Partition) -> UACalcResult<bool>;

    /// Get the join of two congruences
    fn join(&self, a: &dyn Partition, b: &dyn Partition) -> UACalcResult<Box<dyn Partition>>;

    /// Get the meet of two congruences
    fn meet(&self, a: &dyn Partition, b: &dyn Partition) -> UACalcResult<Box<dyn Partition>>;

    /// Get the covering relation of the lattice
    fn covering_relation(&self) -> UACalcResult<Vec<(usize, usize)>>;

    /// Get the atoms of the lattice
    fn atoms(&self) -> UACalcResult<Vec<Box<dyn Partition>>>;

    /// Get the coatoms of the lattice
    fn coatoms(&self) -> UACalcResult<Vec<Box<dyn Partition>>>;

    /// Get the principal congruence θ(a, b) generated by a pair
    fn principal_congruence(&self, a: usize, b: usize) -> UACalcResult<Box<dyn Partition>>;

    /// Get the join-irreducible congruences
    fn join_irreducibles(&self) -> &[Box<dyn Partition>];

    /// Get the universe construction progress (0.0 to 1.0)
    fn universe_construction_progress(&self) -> Option<f64>;
}

/// Builder for congruence lattices
pub struct CongruenceLatticeBuilder {
    algebra: Option<Box<dyn SmallAlgebra>>,
}

impl CongruenceLatticeBuilder {
    /// Create a new builder
    pub fn new() -> Self {
        Self { algebra: None }
    }

    /// Set the algebra
    pub fn algebra(mut self, algebra: Box<dyn SmallAlgebra>) -> Self {
        self.algebra = Some(algebra);
        self
    }

    /// Build the congruence lattice
    pub fn build(self) -> UACalcResult<BasicCongruenceLattice> {
        let algebra = self.algebra.ok_or_else(|| UACalcError::InvalidOperation {
            message: "Algebra must be set".to_string(),
        })?;

        let size = algebra.cardinality();
        let bottom = BasicPartition::new(size);
        let top = coarsest_partition(size)?;

        let universe = vec![bottom, top];

        Ok(BasicCongruenceLattice {
            algebra,
            universe,
            join_irreducibles: Vec::new(),
            join_irreducible_boxes: Vec::new(),
            principal_cache: HashMap::new(),
            construction_progress: None,
        })
    }
}

/// Basic congruence lattice implementation
pub struct BasicCongruenceLattice {
    algebra: Box<dyn SmallAlgebra>,
    universe: Vec<BasicPartition>,
    join_irreducibles: Vec<BasicPartition>,
    join_irreducible_boxes: Vec<Box<dyn Partition>>,
    principal_cache: HashMap<(usize, usize), usize>,
    construction_progress: Option<f64>,
}

impl BasicCongruenceLattice {
    /// Create a new congruence lattice for an algebra
    pub fn new(algebra: Box<dyn SmallAlgebra>) -> UACalcResult<Self> {
        let size = algebra.cardinality();
        let bottom = BasicPartition::new(size);
        let top = coarsest_partition(size)?;

        let universe = vec![bottom, top];

        Ok(Self {
            algebra,
            universe,
            join_irreducibles: Vec::new(),
            join_irreducible_boxes: Vec::new(),
            principal_cache: HashMap::new(),
            construction_progress: None,
        })
    }

    /// Create a new congruence lattice with lazy universe construction
    pub fn with_lazy_construction(algebra: Box<dyn SmallAlgebra>) -> Self {
        let size = algebra.cardinality();
        let bottom = BasicPartition::new(size);
        let top = coarsest_partition(size).unwrap_or_else(|_| BasicPartition::new(size));

        let universe = vec![bottom, top];

        Self {
            algebra,
            universe,
            join_irreducibles: Vec::new(),
            join_irreducible_boxes: Vec::new(),
            principal_cache: HashMap::new(),
            construction_progress: None,
        }
    }

    /// Ensure the universe is built (trigger lazy construction if needed)
    pub fn ensure_universe_built(&mut self) -> UACalcResult<()> {
        if self.universe.len() <= 2 {
            // Only bottom and top, need to build the full universe
            let mut builder = lattice_builder::LatticeBuilder::new(self.algebra.as_ref());
            let universe = builder.build_universe()?;
            self.universe = universe;
            self.join_irreducibles =
                lattice_builder::find_join_irreducibles(self.algebra.as_ref())?;
            
            // Populate join_irreducible_boxes from join_irreducibles
            self.join_irreducible_boxes = self.join_irreducibles
                .iter()
                .map(|p| Box::new(p.clone()) as Box<dyn Partition>)
                .collect();
        }
        Ok(())
    }

    /// Build the universe with progress callback
    pub fn with_progress_callback<F>(mut self, callback: F) -> UACalcResult<Self>
    where
        F: Fn(f64) + Send + Sync + 'static,
    {
        let mut builder = lattice_builder::LatticeBuilder::new(self.algebra.as_ref());
        let progress_callback = Box::new(ProgressCallbackWrapper { callback });
        builder = builder.with_progress_callback(progress_callback);

        let universe = builder.build_universe()?;
        self.universe = universe;
        self.join_irreducibles = lattice_builder::find_join_irreducibles(self.algebra.as_ref())?;
        
        // Populate join_irreducible_boxes from join_irreducibles
        self.join_irreducible_boxes = self.join_irreducibles
            .iter()
            .map(|p| Box::new(p.clone()) as Box<dyn Partition>)
            .collect();

        Ok(self)
    }

    /// Get the principal congruence θ(a, b) with caching
    pub fn get_principal_congruence(
        &mut self,
        a: usize,
        b: usize,
    ) -> UACalcResult<&BasicPartition> {
        let key = if a < b { (a, b) } else { (b, a) };

        if let Some(&index) = self.principal_cache.get(&key) {
            return Ok(&self.universe[index]);
        }

        // Compute the principal congruence
        let principal = cg::principal_congruence(self.algebra.as_ref(), key.0, key.1)?;

        // Add to universe if not already present
        let index = if let Some(pos) = self.universe.iter().position(|p| p == &principal) {
            pos
        } else {
            self.universe.push(principal);
            self.universe.len() - 1
        };

        self.principal_cache.insert(key, index);
        Ok(&self.universe[index])
    }

    /// Generate all congruences for the algebra
    fn generate_congruences(&mut self) -> UACalcResult<()> {
        let size = self.algebra.cardinality();

        // Start with the finest and coarsest partitions
        let mut all_partitions = vec![BasicPartition::new(size), coarsest_partition(size)?];

        // Generate all possible partitions and check which are congruences
        // This is a very simplified approach - in practice, you'd use
        // more sophisticated algorithms

        // For now, we'll just add some basic congruences
        // In a real implementation, you'd generate all partitions and
        // filter by the congruence property

        Ok(())
    }

    /// Check if a partition is compatible with all operations
    fn is_compatible(&self, partition: &dyn Partition) -> UACalcResult<bool> {
        for operation in self.algebra.operations() {
            let op_guard = operation
                .lock()
                .map_err(|_| UACalcError::InvalidOperation {
                    message: "Failed to lock operation".to_string(),
                })?;
            if !self.is_compatible_with_operation(partition, &*op_guard)? {
                return Ok(false);
            }
        }
        Ok(true)
    }

    /// Check if a partition is compatible with a specific operation
    fn is_compatible_with_operation(
        &self,
        partition: &dyn Partition,
        operation: &dyn crate::operation::Operation,
    ) -> UACalcResult<bool> {
        let arity = operation.arity();
        let size = self.algebra.cardinality();

        // Check compatibility for all possible input tuples
        for args in self.generate_tuples(size, arity) {
            let result = operation.value(&args)?;

            // Check if the result is in the same block as the operation applied to representatives
            let mut representative_args = Vec::with_capacity(arity);
            for &arg in &args {
                representative_args.push(partition.representative(arg)?);
            }

            let representative_result = operation.value(&representative_args)?;

            if !partition.same_block(result, representative_result)? {
                return Ok(false);
            }
        }

        Ok(true)
    }

    /// Generate all possible tuples of given arity
    fn generate_tuples(&self, size: usize, arity: usize) -> Vec<Vec<usize>> {
        if arity == 0 {
            return vec![vec![]];
        }

        let mut tuples = Vec::new();
        let mut current = vec![0; arity];

        loop {
            tuples.push(current.clone());

            // Generate next tuple
            let mut i = arity - 1;
            while i < arity {
                current[i] += 1;
                if current[i] < size {
                    break;
                }
                current[i] = 0;
                if i == 0 {
                    break;
                }
                i -= 1;
            }

            if i == 0 && current[0] == 0 {
                break;
            }
        }

        tuples
    }
}

impl CongruenceLattice for BasicCongruenceLattice {
    fn algebra(&self) -> &dyn SmallAlgebra {
        self.algebra.as_ref()
    }

    fn congruences(&self) -> Vec<Box<dyn Partition>> {
        self.universe
            .iter()
            .map(|p| Box::new(p.clone()) as Box<dyn Partition>)
            .collect()
    }

    fn num_congruences(&self) -> usize {
        self.universe.len()
    }

    fn bottom(&self) -> Box<dyn Partition> {
        Box::new(BasicPartition::new(self.algebra.cardinality()))
    }

    fn top(&self) -> Box<dyn Partition> {
        coarsest_partition(self.algebra.cardinality())
            .map(|p| Box::new(p) as Box<dyn Partition>)
            .unwrap_or_else(|_| self.bottom())
    }

    fn is_congruence(&self, partition: &dyn Partition) -> UACalcResult<bool> {
        cg::is_congruence(self.algebra.as_ref(), partition)
    }

    fn join(&self, a: &dyn Partition, b: &dyn Partition) -> UACalcResult<Box<dyn Partition>> {
        // Downcast to BasicPartition for now
        if let Some(a_basic) = (a as &dyn Any).downcast_ref::<BasicPartition>() {
            if let Some(b_basic) = (b as &dyn Any).downcast_ref::<BasicPartition>() {
                let result = a_basic.join(b_basic)?;
                return Ok(Box::new(result));
            }
        }
        Err(UACalcError::InvalidOperation {
            message: "Can only join BasicPartition types".to_string(),
        })
    }

    fn meet(&self, a: &dyn Partition, b: &dyn Partition) -> UACalcResult<Box<dyn Partition>> {
        // Downcast to BasicPartition for now
        if let Some(a_basic) = (a as &dyn Any).downcast_ref::<BasicPartition>() {
            if let Some(b_basic) = (b as &dyn Any).downcast_ref::<BasicPartition>() {
                let result = a_basic.meet(b_basic)?;
                return Ok(Box::new(result));
            }
        }
        Err(UACalcError::InvalidOperation {
            message: "Can only meet BasicPartition types".to_string(),
        })
    }

    fn covering_relation(&self) -> UACalcResult<Vec<(usize, usize)>> {
        // Compute the covering relation of the lattice
        let mut covering = Vec::new();

        for i in 0..self.universe.len() {
            for j in 0..self.universe.len() {
                if i != j {
                    // Check if j covers i (i < j and no element between them)
                    if self.universe[i].is_finer_than(&self.universe[j])? {
                        let mut covers = true;
                        for k in 0..self.universe.len() {
                            if k != i && k != j {
                                if self.universe[i].is_finer_than(&self.universe[k])?
                                    && self.universe[k].is_finer_than(&self.universe[j])?
                                {
                                    covers = false;
                                    break;
                                }
                            }
                        }
                        if covers {
                            covering.push((i, j));
                        }
                    }
                }
            }
        }

        Ok(covering)
    }

    fn atoms(&self) -> UACalcResult<Vec<Box<dyn Partition>>> {
        // Find atoms (elements that cover the bottom)
        let mut atoms = Vec::new();
        let bottom = self.bottom();

        for congruence in &self.universe {
            if let Some(bottom_basic) =
                (bottom.as_ref() as &dyn Any).downcast_ref::<BasicPartition>()
            {
                if congruence.is_finer_than(bottom_basic)?
                    && congruence.num_blocks() == bottom_basic.num_blocks() + 1
                {
                    atoms.push(Box::new(congruence.clone()) as Box<dyn Partition>);
                }
            }
        }

        Ok(atoms)
    }

    fn coatoms(&self) -> UACalcResult<Vec<Box<dyn Partition>>> {
        // Find coatoms (elements covered by the top)
        let mut coatoms = Vec::new();
        let top = self.top();

        for congruence in &self.universe {
            if let Some(top_basic) = (top.as_ref() as &dyn Any).downcast_ref::<BasicPartition>() {
                if top_basic.is_finer_than(congruence)?
                    && top_basic.num_blocks() == congruence.num_blocks() + 1
                {
                    coatoms.push(Box::new(congruence.clone()) as Box<dyn Partition>);
                }
            }
        }

        Ok(coatoms)
    }

    fn principal_congruence(&self, a: usize, b: usize) -> UACalcResult<Box<dyn Partition>> {
        let principal = cg::principal_congruence(self.algebra.as_ref(), a, b)?;
        Ok(Box::new(principal) as Box<dyn Partition>)
    }

    fn join_irreducibles(&self) -> &[Box<dyn Partition>] {
        &self.join_irreducible_boxes
    }

    fn universe_construction_progress(&self) -> Option<f64> {
        self.construction_progress
    }
}

impl std::fmt::Debug for BasicCongruenceLattice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("BasicCongruenceLattice")
            .field("algebra", &"<dyn SmallAlgebra>")
            .field("universe", &self.universe)
            .field("join_irreducibles", &self.join_irreducibles)
            .field("principal_cache", &self.principal_cache)
            .field("construction_progress", &self.construction_progress)
            .finish()
    }
}

/// Progress callback wrapper for closures
struct ProgressCallbackWrapper<F> {
    callback: F,
}

impl<F> super::ProgressCallback for ProgressCallbackWrapper<F>
where
    F: Fn(f64) + Send + Sync,
{
    fn report_progress(&self, progress: f64) {
        (self.callback)(progress);
    }

    fn should_cancel(&self) -> bool {
        false
    }
}

/// Create the coarsest partition (all elements in one block)
fn coarsest_partition(size: usize) -> UACalcResult<BasicPartition> {
    let mut partition = BasicPartition::new(size);
    if size > 1 {
        for i in 1..size {
            partition.union(0, i)?;
        }
    }
    Ok(partition)
}
