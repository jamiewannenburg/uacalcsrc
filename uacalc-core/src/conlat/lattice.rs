use crate::algebra::SmallAlgebra;
use crate::conlat::{cg, lattice_builder};
use crate::partition::{coarsest_partition, BasicPartition, Partition};
use crate::{UACalcError, UACalcResult};
use std::any::Any;
use std::collections::HashMap;

/// Trait for congruence lattice structures
pub trait CongruenceLattice: Send + Sync {
    /// Get the algebra this congruence lattice is for
    fn algebra(&self) -> &dyn SmallAlgebra;

    /// Get all congruences in the lattice
    fn congruences(&self) -> Vec<Box<dyn Partition>>;

    /// Get the number of congruences
    fn num_congruences(&self) -> usize;

    /// Get the bottom congruence (identity relation)
    fn bottom(&self) -> Box<dyn Partition>;

    /// Get the top congruence (universal relation)
    fn top(&self) -> Box<dyn Partition>;

    /// Check if a partition is a congruence
    fn is_congruence(&self, partition: &dyn Partition) -> UACalcResult<bool>;

    /// Get the join of two congruences
    fn join(&self, a: &dyn Partition, b: &dyn Partition) -> UACalcResult<Box<dyn Partition>>;

    /// Get the meet of two congruences
    fn meet(&self, a: &dyn Partition, b: &dyn Partition) -> UACalcResult<Box<dyn Partition>>;

    /// Get the covering relation of the lattice
    fn covering_relation(&self) -> UACalcResult<Vec<(usize, usize)>>;

    /// Get the atoms of the lattice
    fn atoms(&self) -> UACalcResult<Vec<Box<dyn Partition>>>;

    /// Get the coatoms of the lattice
    fn coatoms(&self) -> UACalcResult<Vec<Box<dyn Partition>>>;

    /// Get the principal congruence θ(a, b) generated by a pair
    fn principal_congruence(&self, a: usize, b: usize) -> UACalcResult<Box<dyn Partition>>;

    /// Get the join-irreducible congruences
    fn join_irreducibles(&self) -> &[Box<dyn Partition>];

    /// Get the meet-irreducible congruences
    fn meet_irreducibles(&self) -> UACalcResult<Vec<Box<dyn Partition>>>;

    /// Get the zero element (bottom) of the lattice
    fn zero(&self) -> Box<dyn Partition>;

    /// Get the one element (top) of the lattice
    fn one(&self) -> UACalcResult<Box<dyn Partition>>;

    /// Check if the lattice is distributive
    fn is_distributive(&self) -> UACalcResult<bool>;

    /// Check if the lattice is modular
    fn is_modular(&self) -> UACalcResult<bool>;

    /// Check if the lattice is boolean (distributive and complemented)
    fn is_boolean(&self) -> UACalcResult<bool>;

    /// Get the height of the lattice
    fn height(&self) -> UACalcResult<usize>;

    /// Get the width of the lattice
    fn width(&self) -> UACalcResult<usize>;

    /// Get the universe construction progress (0.0 to 1.0)
    fn universe_construction_progress(&self) -> Option<f64>;
}

/// Builder for congruence lattices
pub struct CongruenceLatticeBuilder {
    algebra: Option<Box<dyn SmallAlgebra>>,
}

impl CongruenceLatticeBuilder {
    /// Create a new builder
    pub fn new() -> Self {
        Self { algebra: None }
    }

    /// Set the algebra
    pub fn algebra(mut self, algebra: Box<dyn SmallAlgebra>) -> Self {
        self.algebra = Some(algebra);
        self
    }

    /// Build the congruence lattice
    pub fn build(self) -> UACalcResult<BasicCongruenceLattice> {
        let algebra = self.algebra.ok_or_else(|| UACalcError::InvalidOperation {
            message: "Algebra must be set".to_string(),
        })?;

        let size = algebra.cardinality();
        let bottom = BasicPartition::new(size);
        let top = coarsest_partition(size)?;

        let universe = vec![bottom, top];

        Ok(BasicCongruenceLattice {
            algebra,
            universe,
            join_irreducibles: Vec::new(),
            join_irreducible_boxes: Vec::new(),
            principal_cache: HashMap::new(),
            construction_progress: None,
        })
    }
}

/// Basic congruence lattice implementation
pub struct BasicCongruenceLattice {
    algebra: Box<dyn SmallAlgebra>,
    universe: Vec<BasicPartition>,
    join_irreducibles: Vec<BasicPartition>,
    join_irreducible_boxes: Vec<Box<dyn Partition>>,
    principal_cache: HashMap<(usize, usize), usize>,
    construction_progress: Option<f64>,
}

impl BasicCongruenceLattice {
    /// Create a new congruence lattice for an algebra
    pub fn new(algebra: Box<dyn SmallAlgebra>) -> UACalcResult<Self> {
        let size = algebra.cardinality();
        let bottom = BasicPartition::new(size);
        let top = coarsest_partition(size)?;

        let universe = vec![bottom, top];

        Ok(Self {
            algebra,
            universe,
            join_irreducibles: Vec::new(),
            join_irreducible_boxes: Vec::new(),
            principal_cache: HashMap::new(),
            construction_progress: None,
        })
    }

    /// Create a new congruence lattice with lazy universe construction
    pub fn with_lazy_construction(algebra: Box<dyn SmallAlgebra>) -> Self {
        let size = algebra.cardinality();
        let bottom = BasicPartition::new(size);
        let top = coarsest_partition(size).unwrap_or_else(|_| BasicPartition::new(size));

        let universe = vec![bottom, top];

        Self {
            algebra,
            universe,
            join_irreducibles: Vec::new(),
            join_irreducible_boxes: Vec::new(),
            principal_cache: HashMap::new(),
            construction_progress: None,
        }
    }

    /// Ensure the universe is built (trigger lazy construction if needed)
    pub fn ensure_universe_built(&mut self) -> UACalcResult<()> {
        if self.universe.len() <= 2 {
            // Only bottom and top, need to build the full universe
            let mut builder = lattice_builder::LatticeBuilder::new(self.algebra.as_ref());
            let universe = builder.build_universe()?;
            self.universe = universe;
            self.join_irreducibles =
                lattice_builder::find_join_irreducibles(self.algebra.as_ref())?;

            // Populate join_irreducible_boxes from join_irreducibles
            self.join_irreducible_boxes = self
                .join_irreducibles
                .iter()
                .map(|p| Box::new(p.clone()) as Box<dyn Partition>)
                .collect();
        }
        Ok(())
    }

    /// Build the universe with progress callback
    pub fn with_progress_callback<F>(mut self, callback: F) -> UACalcResult<Self>
    where
        F: Fn(f64) + Send + Sync + 'static,
    {
        let mut builder = lattice_builder::LatticeBuilder::new(self.algebra.as_ref());
        let progress_callback = Box::new(ProgressCallbackWrapper { callback });
        builder = builder.with_progress_callback(progress_callback);

        let universe = builder.build_universe()?;
        self.universe = universe;
        self.join_irreducibles = lattice_builder::find_join_irreducibles(self.algebra.as_ref())?;

        // Populate join_irreducible_boxes from join_irreducibles
        self.join_irreducible_boxes = self
            .join_irreducibles
            .iter()
            .map(|p| Box::new(p.clone()) as Box<dyn Partition>)
            .collect();

        Ok(self)
    }

    /// Set a progress callback for an already built lattice
    pub fn set_progress_callback<F>(&mut self, _callback: F) -> UACalcResult<()>
    where
        F: Fn(f64) + Send + Sync + 'static,
    {
        // If the universe is already built, we can't easily add progress reporting
        // to the existing construction. However, we can store the callback for
        // future operations that might use it.
        // For now, we'll just ensure the universe is built and return success.
        self.ensure_universe_built()?;
        Ok(())
    }

    /// Get the principal congruence θ(a, b) with caching
    pub fn get_principal_congruence(
        &mut self,
        a: usize,
        b: usize,
    ) -> UACalcResult<&BasicPartition> {
        let key = if a < b { (a, b) } else { (b, a) };

        if let Some(&index) = self.principal_cache.get(&key) {
            return Ok(&self.universe[index]);
        }

        // Compute the principal congruence
        let principal = cg::principal_congruence(self.algebra.as_ref(), key.0, key.1)?;

        // Add to universe if not already present
        let index = if let Some(pos) = self.universe.iter().position(|p| p == &principal) {
            pos
        } else {
            self.universe.push(principal);
            self.universe.len() - 1
        };

        self.principal_cache.insert(key, index);
        Ok(&self.universe[index])
    }

    /// Generate all congruences for the algebra
    fn generate_congruences(&mut self) -> UACalcResult<()> {
        let size = self.algebra.cardinality();

        // Start with the finest and coarsest partitions
        let _all_partitions = vec![BasicPartition::new(size), coarsest_partition(size)?];

        // Generate all possible partitions and check which are congruences
        // This is a very simplified approach - in practice, you'd use
        // more sophisticated algorithms

        // For now, we'll just add some basic congruences
        // In a real implementation, you'd generate all partitions and
        // filter by the congruence property

        Ok(())
    }

    /// Check if a partition is compatible with all operations
    fn is_compatible(&self, partition: &dyn Partition) -> UACalcResult<bool> {
        for operation in self.algebra.operations() {
            let op_guard = operation
                .lock()
                .map_err(|_| UACalcError::InvalidOperation {
                    message: "Failed to lock operation".to_string(),
                })?;
            if !self.is_compatible_with_operation(partition, &*op_guard)? {
                return Ok(false);
            }
        }
        Ok(true)
    }

    /// Check if a partition is compatible with a specific operation
    fn is_compatible_with_operation(
        &self,
        partition: &dyn Partition,
        operation: &dyn crate::operation::Operation,
    ) -> UACalcResult<bool> {
        let arity = operation.arity();
        let size = self.algebra.cardinality();

        // Check compatibility for all possible input tuples
        for args in self.generate_tuples(size, arity) {
            let result = operation.value(&args)?;

            // Check if the result is in the same block as the operation applied to representatives
            let mut representative_args = Vec::with_capacity(arity);
            for &arg in &args {
                representative_args.push(partition.representative(arg)?);
            }

            let representative_result = operation.value(&representative_args)?;

            if !partition.same_block(result, representative_result)? {
                return Ok(false);
            }
        }

        Ok(true)
    }

    /// Generate all possible tuples of given arity
    fn generate_tuples(&self, size: usize, arity: usize) -> Vec<Vec<usize>> {
        if arity == 0 {
            return vec![vec![]];
        }

        let mut tuples = Vec::new();
        let mut current = vec![0; arity];

        loop {
            tuples.push(current.clone());

            // Generate next tuple
            let mut i = arity - 1;
            while i < arity {
                current[i] += 1;
                if current[i] < size {
                    break;
                }
                current[i] = 0;
                if i == 0 {
                    break;
                }
                i -= 1;
            }

            if i == 0 && current[0] == 0 {
                break;
            }
        }

        tuples
    }

    /// Get all congruences as BasicPartition instances (avoids Any downcasts)
    pub fn congruences_basic(&self) -> Vec<BasicPartition> {
        self.universe.clone()
    }

    /// Get atoms as BasicPartition instances (avoids Any downcasts)
    pub fn atoms_basic(&self) -> UACalcResult<Vec<BasicPartition>> {
        let mut atoms = Vec::new();
        let bottom = BasicPartition::new(self.algebra.cardinality());

        for congruence in &self.universe {
            if congruence.is_finer_than(&bottom)?
                && congruence.num_blocks() == bottom.num_blocks() + 1
            {
                atoms.push(congruence.clone());
            }
        }

        Ok(atoms)
    }

    /// Get coatoms as BasicPartition instances (avoids Any downcasts)
    pub fn coatoms_basic(&self) -> UACalcResult<Vec<BasicPartition>> {
        let mut coatoms = Vec::new();
        let top = coarsest_partition(self.algebra.cardinality())?;

        for congruence in &self.universe {
            if top.is_finer_than(congruence)? && top.num_blocks() == congruence.num_blocks() + 1 {
                coatoms.push(congruence.clone());
            }
        }

        Ok(coatoms)
    }

    /// Get join-irreducibles as BasicPartition instances (avoids Any downcasts)
    pub fn join_irreducibles_basic(&self) -> Vec<BasicPartition> {
        self.join_irreducibles.clone()
    }

    /// Get the join of two congruences by index (avoids Any downcasts)
    pub fn join_by_index(&self, i: usize, j: usize) -> UACalcResult<BasicPartition> {
        if i >= self.universe.len() || j >= self.universe.len() {
            return Err(UACalcError::IndexOutOfBounds {
                index: i.max(j),
                size: self.universe.len(),
            });
        }

        let a = &self.universe[i];
        let b = &self.universe[j];
        a.join(b)
    }

    /// Get the meet of two congruences by index (avoids Any downcasts)
    pub fn meet_by_index(&self, i: usize, j: usize) -> UACalcResult<BasicPartition> {
        if i >= self.universe.len() || j >= self.universe.len() {
            return Err(UACalcError::IndexOutOfBounds {
                index: i.max(j),
                size: self.universe.len(),
            });
        }

        let a = &self.universe[i];
        let b = &self.universe[j];
        a.meet(b)
    }

    /// Get the zero element (bottom) of the lattice
    pub fn zero(&self) -> BasicPartition {
        BasicPartition::new(self.algebra.cardinality())
    }

    /// Get the one element (top) of the lattice
    pub fn one(&self) -> UACalcResult<BasicPartition> {
        coarsest_partition(self.algebra.cardinality())
    }

    /// Get meet-irreducibles as BasicPartition instances
    pub fn meet_irreducibles_basic(&self) -> UACalcResult<Vec<BasicPartition>> {
        let mut meet_irreducibles = Vec::new();
        let top = self.one()?;

        for congruence in &self.universe {
            if congruence != &top {
                // Check if this congruence is meet-irreducible
                let mut is_meet_irreducible = true;
                
                // A congruence is meet-irreducible if it cannot be written as
                // the meet of two strictly larger congruences
                for i in 0..self.universe.len() {
                    for j in 0..self.universe.len() {
                        if i != j {
                            let meet_result = self.universe[i].meet(&self.universe[j])?;
                            if meet_result == *congruence 
                                && self.universe[i] != *congruence 
                                && self.universe[j] != *congruence {
                                is_meet_irreducible = false;
                                break;
                            }
                        }
                    }
                    if !is_meet_irreducible {
                        break;
                    }
                }
                
                if is_meet_irreducible {
                    meet_irreducibles.push(congruence.clone());
                }
            }
        }

        Ok(meet_irreducibles)
    }

    /// Check if the lattice is distributive
    pub fn is_distributive(&self) -> UACalcResult<bool> {
        // A lattice is distributive if it doesn't contain N5 or M3 as sublattices
        // For congruence lattices, we can use the fact that a lattice is distributive
        // if and only if it satisfies the distributive law: a ∧ (b ∨ c) = (a ∧ b) ∨ (a ∧ c)
        
        for i in 0..self.universe.len() {
            for j in 0..self.universe.len() {
                for k in 0..self.universe.len() {
                    let a = &self.universe[i];
                    let b = &self.universe[j];
                    let c = &self.universe[k];
                    
                    // Check distributive law: a ∧ (b ∨ c) = (a ∧ b) ∨ (a ∧ c)
                    let left_side = a.meet(&b.join(c)?)?;
                    let right_side = a.meet(b)?.join(&a.meet(c)?)?;
                    
                    if left_side != right_side {
                        return Ok(false);
                    }
                }
            }
        }
        
        Ok(true)
    }

    /// Check if the lattice is modular
    pub fn is_modular(&self) -> UACalcResult<bool> {
        // A lattice is modular if it doesn't contain N5 as a sublattice
        // Equivalently, if a ≤ c, then a ∨ (b ∧ c) = (a ∨ b) ∧ c
        
        for i in 0..self.universe.len() {
            for j in 0..self.universe.len() {
                for k in 0..self.universe.len() {
                    let a = &self.universe[i];
                    let b = &self.universe[j];
                    let c = &self.universe[k];
                    
                    // Check if a ≤ c
                    if a.is_finer_than(c)? {
                        // Check modular law: a ∨ (b ∧ c) = (a ∨ b) ∧ c
                        let left_side = a.join(&b.meet(c)?)?;
                        let right_side = a.join(b)?.meet(c)?;
                        
                        if left_side != right_side {
                            return Ok(false);
                        }
                    }
                }
            }
        }
        
        Ok(true)
    }

    /// Check if the lattice is boolean (distributive and complemented)
    pub fn is_boolean(&self) -> UACalcResult<bool> {
        // A lattice is boolean if it's distributive and every element has a complement
        if !self.is_distributive()? {
            return Ok(false);
        }
        
        // Check if every element has a complement
        for congruence in &self.universe {
            if !self.has_complement(congruence)? {
                return Ok(false);
            }
        }
        
        Ok(true)
    }

    /// Check if a congruence has a complement
    pub fn has_complement(&self, congruence: &BasicPartition) -> UACalcResult<bool> {
        let zero = self.zero();
        let one = self.one()?;
        
        for other in &self.universe {
            // Check if other is a complement of congruence
            if congruence.join(other)? == one && congruence.meet(other)? == zero {
                return Ok(true);
            }
        }
        
        Ok(false)
    }

    /// Get all complements of a congruence
    pub fn complements(&self, congruence: &BasicPartition) -> UACalcResult<Vec<BasicPartition>> {
        let mut complements = Vec::new();
        let zero = self.zero();
        let one = self.one()?;
        
        for other in &self.universe {
            // Check if other is a complement of congruence
            if congruence.join(other)? == one && congruence.meet(other)? == zero {
                complements.push(other.clone());
            }
        }
        
        Ok(complements)
    }

    /// Get the height of the lattice
    pub fn height(&self) -> UACalcResult<usize> {
        // The height is the length of the longest chain
        let mut max_chain_length = 0;
        
        for i in 0..self.universe.len() {
            let chain_length = self.longest_chain_from(i)?;
            max_chain_length = max_chain_length.max(chain_length);
        }
        
        Ok(max_chain_length)
    }

    /// Get the width of the lattice
    pub fn width(&self) -> UACalcResult<usize> {
        // The width is the size of the largest antichain
        // For now, use a simplified approach that returns the number of join-irreducibles
        // This is a reasonable approximation for many lattices
        Ok(self.join_irreducibles.len())
    }

    /// Find the length of the longest chain starting from a given element
    fn longest_chain_from(&self, start: usize) -> UACalcResult<usize> {
        let mut max_length = 1;
        
        for i in 0..self.universe.len() {
            if i != start && self.universe[start].is_finer_than(&self.universe[i])? {
                let length = 1 + self.longest_chain_from(i)?;
                max_length = max_length.max(length);
            }
        }
        
        Ok(max_length)
    }

    /// Check if there exists a lattice homomorphism from this lattice to another
    pub fn has_homomorphism_to(&self, other: &BasicCongruenceLattice) -> UACalcResult<bool> {
        // A lattice homomorphism preserves join and meet operations
        // For now, we'll use a simplified check based on lattice size and structure
        
        // If this lattice is larger than the other, there can't be a homomorphism
        if self.universe.len() > other.universe.len() {
            return Ok(false);
        }
        
        // Check if the lattice structures are compatible
        // This is a simplified check - in practice, you'd need to check
        // if there's a mapping that preserves the lattice operations
        
        // For now, we'll just check if the sizes are compatible
        Ok(self.universe.len() <= other.universe.len())
    }

    /// Check if this lattice is isomorphic to another lattice
    pub fn is_isomorphic_to(&self, other: &BasicCongruenceLattice) -> UACalcResult<bool> {
        // Two lattices are isomorphic if they have the same structure
        // For now, we'll use a simplified check based on size and basic properties
        
        if self.universe.len() != other.universe.len() {
            return Ok(false);
        }
        
        // Check if they have the same number of join-irreducibles
        if self.join_irreducibles.len() != other.join_irreducibles.len() {
            return Ok(false);
        }
        
        // Check if they have the same height and width
        let self_height = self.height()?;
        let other_height = other.height()?;
        let self_width = self.width()?;
        let other_width = other.width()?;
        
        if self_height != other_height || self_width != other_width {
            return Ok(false);
        }
        
        // Check if they have the same lattice properties
        let self_distributive = self.is_distributive()?;
        let other_distributive = other.is_distributive()?;
        let self_modular = self.is_modular()?;
        let other_modular = other.is_modular()?;
        let self_boolean = self.is_boolean()?;
        let other_boolean = other.is_boolean()?;
        
        if self_distributive != other_distributive 
            || self_modular != other_modular 
            || self_boolean != other_boolean {
            return Ok(false);
        }
        
        // If all basic properties match, assume they're isomorphic
        // In a full implementation, you'd need to check for an actual bijection
        // that preserves the lattice operations
        Ok(true)
    }

    /// Find a lattice homomorphism to another lattice (if one exists)
    pub fn find_homomorphism_to(&self, other: &BasicCongruenceLattice) -> UACalcResult<Option<Vec<usize>>> {
        // This is a simplified implementation that just checks if a homomorphism exists
        // In practice, you'd need to implement a more sophisticated algorithm
        
        if !self.has_homomorphism_to(other)? {
            return Ok(None);
        }
        
        // For now, return a simple mapping based on indices
        // This is not a real homomorphism, just a placeholder
        let mut mapping = Vec::new();
        for i in 0..self.universe.len() {
            mapping.push(i % other.universe.len());
        }
        
        Ok(Some(mapping))
    }

    /// Find a lattice isomorphism to another lattice (if one exists)
    pub fn find_isomorphism_to(&self, other: &BasicCongruenceLattice) -> UACalcResult<Option<Vec<usize>>> {
        // This is a simplified implementation that just checks if an isomorphism exists
        // In practice, you'd need to implement a more sophisticated algorithm
        
        if !self.is_isomorphic_to(other)? {
            return Ok(None);
        }
        
        // For now, return a simple bijection based on indices
        // This is not a real isomorphism, just a placeholder
        let mut mapping = Vec::new();
        for i in 0..self.universe.len() {
            mapping.push(i);
        }
        
        Ok(Some(mapping))
    }
}

impl CongruenceLattice for BasicCongruenceLattice {
    fn algebra(&self) -> &dyn SmallAlgebra {
        self.algebra.as_ref()
    }

    fn congruences(&self) -> Vec<Box<dyn Partition>> {
        self.universe
            .iter()
            .map(|p| Box::new(p.clone()) as Box<dyn Partition>)
            .collect()
    }

    fn num_congruences(&self) -> usize {
        self.universe.len()
    }

    fn bottom(&self) -> Box<dyn Partition> {
        Box::new(BasicPartition::new(self.algebra.cardinality()))
    }

    fn top(&self) -> Box<dyn Partition> {
        coarsest_partition(self.algebra.cardinality())
            .map(|p| Box::new(p) as Box<dyn Partition>)
            .unwrap_or_else(|_| self.bottom())
    }

    fn is_congruence(&self, partition: &dyn Partition) -> UACalcResult<bool> {
        cg::is_congruence(self.algebra.as_ref(), partition)
    }

    fn join(&self, a: &dyn Partition, b: &dyn Partition) -> UACalcResult<Box<dyn Partition>> {
        // Downcast to BasicPartition for now
        if let Some(a_basic) = (a as &dyn Any).downcast_ref::<BasicPartition>() {
            if let Some(b_basic) = (b as &dyn Any).downcast_ref::<BasicPartition>() {
                let result = a_basic.join(b_basic)?;
                return Ok(Box::new(result));
            }
        }
        Err(UACalcError::InvalidOperation {
            message: "Can only join BasicPartition types".to_string(),
        })
    }

    fn meet(&self, a: &dyn Partition, b: &dyn Partition) -> UACalcResult<Box<dyn Partition>> {
        // Downcast to BasicPartition for now
        if let Some(a_basic) = (a as &dyn Any).downcast_ref::<BasicPartition>() {
            if let Some(b_basic) = (b as &dyn Any).downcast_ref::<BasicPartition>() {
                let result = a_basic.meet(b_basic)?;
                return Ok(Box::new(result));
            }
        }
        Err(UACalcError::InvalidOperation {
            message: "Can only meet BasicPartition types".to_string(),
        })
    }

    fn covering_relation(&self) -> UACalcResult<Vec<(usize, usize)>> {
        // Compute the covering relation of the lattice
        let mut covering = Vec::new();

        for i in 0..self.universe.len() {
            for j in 0..self.universe.len() {
                if i != j {
                    // Check if j covers i (i < j and no element between them)
                    if self.universe[i].is_finer_than(&self.universe[j])? {
                        let mut covers = true;
                        for k in 0..self.universe.len() {
                            if k != i && k != j {
                                if self.universe[i].is_finer_than(&self.universe[k])?
                                    && self.universe[k].is_finer_than(&self.universe[j])?
                                {
                                    covers = false;
                                    break;
                                }
                            }
                        }
                        if covers {
                            covering.push((i, j));
                        }
                    }
                }
            }
        }

        Ok(covering)
    }

    fn atoms(&self) -> UACalcResult<Vec<Box<dyn Partition>>> {
        // Find atoms (elements that cover the bottom)
        let mut atoms = Vec::new();
        let bottom = self.bottom();

        for congruence in &self.universe {
            if let Some(bottom_basic) =
                (bottom.as_ref() as &dyn Any).downcast_ref::<BasicPartition>()
            {
                if congruence.is_finer_than(bottom_basic)?
                    && congruence.num_blocks() == bottom_basic.num_blocks() + 1
                {
                    atoms.push(Box::new(congruence.clone()) as Box<dyn Partition>);
                }
            }
        }

        Ok(atoms)
    }

    fn coatoms(&self) -> UACalcResult<Vec<Box<dyn Partition>>> {
        // Find coatoms (elements covered by the top)
        let mut coatoms = Vec::new();
        let top = self.top();

        for congruence in &self.universe {
            if let Some(top_basic) = (top.as_ref() as &dyn Any).downcast_ref::<BasicPartition>() {
                if top_basic.is_finer_than(congruence)?
                    && top_basic.num_blocks() == congruence.num_blocks() + 1
                {
                    coatoms.push(Box::new(congruence.clone()) as Box<dyn Partition>);
                }
            }
        }

        Ok(coatoms)
    }

    fn principal_congruence(&self, a: usize, b: usize) -> UACalcResult<Box<dyn Partition>> {
        let principal = cg::principal_congruence(self.algebra.as_ref(), a, b)?;
        Ok(Box::new(principal) as Box<dyn Partition>)
    }

    fn join_irreducibles(&self) -> &[Box<dyn Partition>] {
        &self.join_irreducible_boxes
    }

    fn meet_irreducibles(&self) -> UACalcResult<Vec<Box<dyn Partition>>> {
        let meet_irreducibles = self.meet_irreducibles_basic()?;
        Ok(meet_irreducibles
            .into_iter()
            .map(|p| Box::new(p) as Box<dyn Partition>)
            .collect())
    }

    fn zero(&self) -> Box<dyn Partition> {
        Box::new(BasicPartition::new(self.algebra.cardinality()))
    }

    fn one(&self) -> UACalcResult<Box<dyn Partition>> {
        let one = coarsest_partition(self.algebra.cardinality())?;
        Ok(Box::new(one) as Box<dyn Partition>)
    }

    fn is_distributive(&self) -> UACalcResult<bool> {
        BasicCongruenceLattice::is_distributive(self)
    }

    fn is_modular(&self) -> UACalcResult<bool> {
        BasicCongruenceLattice::is_modular(self)
    }

    fn is_boolean(&self) -> UACalcResult<bool> {
        BasicCongruenceLattice::is_boolean(self)
    }

    fn height(&self) -> UACalcResult<usize> {
        BasicCongruenceLattice::height(self)
    }

    fn width(&self) -> UACalcResult<usize> {
        BasicCongruenceLattice::width(self)
    }

    fn universe_construction_progress(&self) -> Option<f64> {
        self.construction_progress
    }
}

impl std::fmt::Debug for BasicCongruenceLattice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("BasicCongruenceLattice")
            .field("algebra", &"<dyn SmallAlgebra>")
            .field("universe", &self.universe)
            .field("join_irreducibles", &self.join_irreducibles)
            .field("principal_cache", &self.principal_cache)
            .field("construction_progress", &self.construction_progress)
            .finish()
    }
}

/// Progress callback wrapper for closures
struct ProgressCallbackWrapper<F> {
    callback: F,
}

impl<F> super::ProgressCallback for ProgressCallbackWrapper<F>
where
    F: Fn(f64) + Send + Sync,
{
    fn report_progress(&self, progress: f64) {
        (self.callback)(progress);
    }

    fn should_cancel(&self) -> bool {
        false
    }
}
