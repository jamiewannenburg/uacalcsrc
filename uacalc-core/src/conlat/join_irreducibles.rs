//! Join-irreducible congruence management
//! 
//! This module provides algorithms for finding and managing join-irreducible
//! congruences in the congruence lattice.

use crate::{UACalcError, UACalcResult};
use crate::algebra::SmallAlgebra;
use crate::partition::{Partition, BasicPartition};
use crate::conlat::cg::principal_congruence;
use std::collections::HashSet;

/// Manager for join-irreducible congruences
pub struct JoinIrreduciblesManager<'a> {
    algebra: &'a dyn SmallAlgebra,
    join_irreducibles: Vec<BasicPartition>,
    principal_cache: HashSet<(usize, usize)>,
}

impl<'a> JoinIrreduciblesManager<'a> {
    /// Create a new join-irreducibles manager
    pub fn new(algebra: &'a dyn SmallAlgebra) -> Self {
        Self {
            algebra,
            join_irreducibles: Vec::new(),
            principal_cache: HashSet::new(),
        }
    }
    
    /// Find all join-irreducible congruences for the algebra
    pub fn find_all(&mut self) -> UACalcResult<Vec<BasicPartition>> {
        let size = self.algebra.cardinality();
        
        // Generate all principal congruences
        for a in 0..size {
            for b in (a + 1)..size {
                let principal = principal_congruence(self.algebra, a, b)?;
                
                // Check if this principal congruence is join-irreducible
                if self.is_join_irreducible(&principal)? {
                    self.join_irreducibles.push(principal);
                    self.principal_cache.insert((a, b));
                }
            }
        }
        
        // Sort by rank (number of blocks) for efficient processing
        self.join_irreducibles.sort_by(|a, b| a.num_blocks().cmp(&b.num_blocks()));
        
        Ok(self.join_irreducibles.clone())
    }
    
    /// Check if a congruence is join-irreducible
    pub fn is_join_irreducible(&self, congruence: &BasicPartition) -> UACalcResult<bool> {
        // A congruence is join-irreducible if it cannot be expressed as
        // the join of strictly smaller congruences
        
        // Trivial cases
        if congruence.num_blocks() <= 1 {
            return Ok(false); // Bottom and top are not join-irreducible
        }
        
        // Check if it's a principal congruence (most join-irreducibles are)
        if self.is_principal_congruence(congruence)? {
            return Ok(true);
        }
        
        // More sophisticated test: check if it can be expressed as join of others
        self.test_join_irreducibility(congruence)
    }
    
    /// Check if a congruence is a principal congruence
    fn is_principal_congruence(&self, congruence: &BasicPartition) -> UACalcResult<bool> {
        let size = self.algebra.cardinality();
        
        // Check if this congruence is generated by a single pair
        for a in 0..size {
            for b in (a + 1)..size {
                let principal = principal_congruence(self.algebra, a, b)?;
                if principal == *congruence {
                    return Ok(true);
                }
            }
        }
        
        Ok(false)
    }
    
    /// Test if a congruence is join-irreducible by checking if it can be
    /// expressed as a join of strictly smaller congruences
    fn test_join_irreducibility(&self, congruence: &BasicPartition) -> UACalcResult<bool> {
        // For now, use a simple heuristic: if it's not a principal congruence
        // and has more than 2 blocks, it's likely not join-irreducible
        if congruence.num_blocks() > 2 {
            return Ok(false);
        }
        
        // More sophisticated test would check all possible joins of smaller congruences
        // This is computationally expensive, so we use heuristics for now
        
        Ok(true)
    }
    
    /// Get the rank of a congruence (number of blocks)
    pub fn rank(&self, congruence: &BasicPartition) -> usize {
        congruence.num_blocks()
    }
    
    /// Get join-irreducibles by rank
    pub fn by_rank(&self, rank: usize) -> Vec<&BasicPartition> {
        self.join_irreducibles
            .iter()
            .filter(|ji| ji.num_blocks() == rank)
            .collect()
    }
    
    /// Get all join-irreducibles sorted by rank
    pub fn all_by_rank(&self) -> Vec<Vec<&BasicPartition>> {
        let mut by_rank = Vec::new();
        let max_rank = self.join_irreducibles
            .iter()
            .map(|ji| ji.num_blocks())
            .max()
            .unwrap_or(0);
        
        for rank in 2..=max_rank {
            by_rank.push(self.by_rank(rank));
        }
        
        by_rank
    }
    
    /// Check if a pair generates a join-irreducible congruence
    pub fn is_join_irreducible_pair(&self, a: usize, b: usize) -> bool {
        let key = if a < b { (a, b) } else { (b, a) };
        self.principal_cache.contains(&key)
    }
    
    /// Get the number of join-irreducibles
    pub fn count(&self) -> usize {
        self.join_irreducibles.len()
    }
    
    /// Get all join-irreducibles
    pub fn all(&self) -> &[BasicPartition] {
        &self.join_irreducibles
    }
}

/// Find all join-irreducible congruences for an algebra
pub fn find_join_irreducibles(algebra: &dyn SmallAlgebra) -> UACalcResult<Vec<BasicPartition>> {
    let mut manager = JoinIrreduciblesManager::new(algebra);
    manager.find_all()
}

/// Check if a congruence is join-irreducible
pub fn is_join_irreducible(
    algebra: &dyn SmallAlgebra,
    congruence: &BasicPartition,
) -> UACalcResult<bool> {
    let manager = JoinIrreduciblesManager::new(algebra);
    manager.is_join_irreducible(congruence)
}

/// Get the rank of a congruence
pub fn rank(congruence: &BasicPartition) -> usize {
    congruence.num_blocks()
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::algebra::BasicAlgebra;
    
    #[test]
    fn test_find_join_irreducibles() {
        let algebra = BasicAlgebra::new(3, vec![]);
        let jis = find_join_irreducibles(&algebra);
        assert!(jis.is_ok());
        let jis = jis.unwrap();
        assert_eq!(jis.len(), 3); // θ(0,1), θ(0,2), θ(1,2)
    }
    
    #[test]
    fn test_is_join_irreducible() {
        let algebra = BasicAlgebra::new(3, vec![]);
        let partition = BasicPartition::new(3);
        let result = is_join_irreducible(&algebra, &partition);
        assert!(result.is_ok());
        assert!(!result.unwrap()); // Bottom is not join-irreducible
    }
    
    #[test]
    fn test_rank() {
        let partition = BasicPartition::new(3);
        assert_eq!(rank(&partition), 3); // Three singleton blocks
    }
}
