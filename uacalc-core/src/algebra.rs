use crate::{UACalcError, UACalcResult};
use crate::operation::Operation;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Trait for universal algebra structures
pub trait Algebra {
    /// Get the universe (set of elements) of the algebra
    fn universe(&self) -> &[usize];
    
    /// Get the cardinality of the algebra
    fn cardinality(&self) -> usize;
    
    /// Get all operations of the algebra
    fn operations(&self) -> &[Box<dyn Operation>];
    
    /// Get an operation by index
    fn operation(&self, index: usize) -> UACalcResult<&dyn Operation>;
    
    /// Get an operation by symbol
    fn operation_by_symbol(&self, symbol: &str) -> UACalcResult<&dyn Operation>;
    
    /// Check if the algebra is finite
    fn is_finite(&self) -> bool {
        self.cardinality() < usize::MAX
    }
    
    /// Get the name of the algebra
    fn name(&self) -> &str;
}

/// Trait for finite algebras with efficient operations
pub trait SmallAlgebra: Algebra {
    /// Get the maximum arity of operations
    fn max_arity(&self) -> usize;
    
    /// Check if an operation is idempotent
    fn is_idempotent(&self, op_index: usize) -> UACalcResult<bool>;
    
    /// Check if an operation is associative
    fn is_associative(&self, op_index: usize) -> UACalcResult<bool>;
    
    /// Check if an operation is commutative
    fn is_commutative(&self, op_index: usize) -> UACalcResult<bool>;
    
    /// Get the subalgebra generated by a subset of elements
    fn subalgebra(&self, generators: &[usize]) -> UACalcResult<BasicAlgebra>;
}

/// Basic implementation of a finite algebra
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BasicAlgebra {
    name: String,
    universe: Vec<usize>,
    operations: Vec<Box<dyn Operation>>,
    operation_symbols: HashMap<String, usize>,
}

impl BasicAlgebra {
    /// Create a new basic algebra
    pub fn new(name: String, universe: Vec<usize>) -> Self {
        Self {
            name,
            universe,
            operations: Vec::new(),
            operation_symbols: HashMap::new(),
        }
    }
    
    /// Add an operation to the algebra
    pub fn add_operation(&mut self, symbol: String, operation: Box<dyn Operation>) -> UACalcResult<()> {
        let index = self.operations.len();
        self.operation_symbols.insert(symbol.clone(), index);
        self.operations.push(operation);
        Ok(())
    }
    
    /// Create an algebra from a universe and operations
    pub fn from_operations(
        name: String,
        universe: Vec<usize>,
        operations: Vec<(String, Box<dyn Operation>)>,
    ) -> UACalcResult<Self> {
        let mut algebra = Self::new(name, universe);
        for (symbol, operation) in operations {
            algebra.add_operation(symbol, operation)?;
        }
        Ok(algebra)
    }
}

impl Algebra for BasicAlgebra {
    fn universe(&self) -> &[usize] {
        &self.universe
    }
    
    fn cardinality(&self) -> usize {
        self.universe.len()
    }
    
    fn operations(&self) -> &[Box<dyn Operation>] {
        &self.operations
    }
    
    fn operation(&self, index: usize) -> UACalcResult<&dyn Operation> {
        self.operations
            .get(index)
            .map(|op| op.as_ref())
            .ok_or_else(|| UACalcError::IndexOutOfBounds {
                index,
                size: self.operations.len(),
            })
    }
    
    fn operation_by_symbol(&self, symbol: &str) -> UACalcResult<&dyn Operation> {
        let index = self.operation_symbols.get(symbol)
            .ok_or_else(|| UACalcError::AlgebraNotFound {
                name: symbol.to_string(),
            })?;
        self.operation(*index)
    }
    
    fn name(&self) -> &str {
        &self.name
    }
}

impl SmallAlgebra for BasicAlgebra {
    fn max_arity(&self) -> usize {
        self.operations
            .iter()
            .map(|op| op.arity())
            .max()
            .unwrap_or(0)
    }
    
    fn is_idempotent(&self, op_index: usize) -> UACalcResult<bool> {
        let operation = self.operation(op_index)?;
        if operation.arity() != 1 {
            return Ok(false);
        }
        
        for &element in &self.universe {
            if operation.value(&[element])? != element {
                return Ok(false);
            }
        }
        Ok(true)
    }
    
    fn is_associative(&self, op_index: usize) -> UACalcResult<bool> {
        let operation = self.operation(op_index)?;
        if operation.arity() != 2 {
            return Ok(false);
        }
        
        for &a in &self.universe {
            for &b in &self.universe {
                for &c in &self.universe {
                    let left = operation.value(&[operation.value(&[a, b])?, c])?;
                    let right = operation.value(&[a, operation.value(&[b, c])?])?;
                    if left != right {
                        return Ok(false);
                    }
                }
            }
        }
        Ok(true)
    }
    
    fn is_commutative(&self, op_index: usize) -> UACalcResult<bool> {
        let operation = self.operation(op_index)?;
        if operation.arity() != 2 {
            return Ok(false);
        }
        
        for &a in &self.universe {
            for &b in &self.universe {
                let left = operation.value(&[a, b])?;
                let right = operation.value(&[b, a])?;
                if left != right {
                    return Ok(false);
                }
            }
        }
        Ok(true)
    }
    
    fn subalgebra(&self, generators: &[usize]) -> UACalcResult<BasicAlgebra> {
        // Simple implementation - in practice, this would compute the closure
        // under all operations starting from the generators
        let mut universe = generators.to_vec();
        universe.sort();
        universe.dedup();
        
        let mut subalgebra = BasicAlgebra::new(
            format!("{}_sub", self.name),
            universe,
        );
        
        // Copy operations (this is a simplified version)
        for (symbol, operation) in &self.operations {
            subalgebra.add_operation(symbol.clone(), operation.clone())?;
        }
        
        Ok(subalgebra)
    }
}

