use crate::{UACalcError, UACalcResult};
use crate::operation::Operation;
use crate::utils::validate_universe_contiguous;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;

/// Trait for universal algebra structures
pub trait Algebra {
    /// Get the universe (set of elements) of the algebra
    fn universe(&self) -> &[usize];
    
    /// Get the cardinality of the algebra
    fn cardinality(&self) -> usize;
    
    /// Get all operations of the algebra
    fn operations(&self) -> &[Arc<dyn Operation>];
    
    /// Get an operation by index
    fn operation(&self, index: usize) -> UACalcResult<&dyn Operation>;
    
    /// Get an operation by symbol
    fn operation_by_symbol(&self, symbol: &str) -> UACalcResult<&dyn Operation>;
    
    /// Convert element to index (mirrors Java's elementIndex)
    fn element_to_index(&self, element: usize) -> UACalcResult<usize> {
        if element >= self.cardinality() {
            return Err(UACalcError::IndexOutOfBounds {
                index: element,
                size: self.cardinality(),
            });
        }
        Ok(element)
    }
    
    /// Convert index to element (mirrors Java's getElement)
    fn index_to_element(&self, index: usize) -> UACalcResult<usize> {
        if index >= self.cardinality() {
            return Err(UACalcError::IndexOutOfBounds {
                index,
                size: self.cardinality(),
            });
        }
        Ok(index)
    }
    
    /// Calculate input size (sum of cardinality^arity for all operations)
    fn input_size(&self) -> usize {
        self.operations().iter()
            .map(|op| {
                let arity = op.arity();
                let cardinality = self.cardinality();
                if arity == 0 {
                    1
                } else {
                    cardinality.pow(arity as u32)
                }
            })
            .sum()
    }
    
    /// Generate operation tables for all operations
    fn make_operation_tables(&mut self) -> UACalcResult<()>;
    
    /// Check if the algebra is finite
    fn is_finite(&self) -> bool {
        self.cardinality() < usize::MAX
    }
    
    /// Get the name of the algebra
    fn name(&self) -> &str;
}

/// Trait for finite algebras with efficient operations
pub trait SmallAlgebra: Algebra {
    /// Get the maximum arity of operations
    fn max_arity(&self) -> usize;
    
    /// Get the universe as a range for contiguous integer universe
    fn universe_as_range(&self) -> std::ops::Range<usize> {
        0..self.cardinality()
    }
    
    /// Integer-optimized operation evaluation (mirrors Java's operationIntValue)
    fn operation_int_value(&self, op_index: usize, args: &[usize]) -> UACalcResult<usize> {
        let operation = self.operation(op_index)?;
        operation.int_value_at(args)
    }
    
    /// Check if all operations are total (defined for all inputs)
    fn is_total(&self) -> bool {
        // For SmallAlgebra with contiguous universe, operations should always be total
        // This is a simplified check - in practice, you might want to verify each operation
        true
    }
    
    /// Check if an operation is idempotent
    fn is_idempotent(&self, op_index: usize) -> UACalcResult<bool> {
        let operation = self.operation(op_index)?;
        operation.is_idempotent_on_set(self.cardinality())
    }
    
    /// Check if an operation is associative
    fn is_associative(&self, op_index: usize) -> UACalcResult<bool> {
        let operation = self.operation(op_index)?;
        operation.is_associative_on_set(self.cardinality())
    }
    
    /// Check if an operation is commutative
    fn is_commutative(&self, op_index: usize) -> UACalcResult<bool> {
        let operation = self.operation(op_index)?;
        operation.is_commutative_on_set(self.cardinality())
    }
    
    /// Get the subalgebra generated by a subset of elements
    fn subalgebra(&self, generators: &[usize]) -> UACalcResult<BasicAlgebra>;
}

/// Basic implementation of a finite algebra
#[derive(Debug, Clone)]
pub struct BasicAlgebra {
    name: String,
    universe: Vec<usize>,
    operations: Vec<Arc<dyn Operation>>,
    operation_symbols: HashMap<String, usize>,
    operation_tables_built: bool,
}

impl BasicAlgebra {
    /// Create a new basic algebra
    pub fn new(name: String, universe: Vec<usize>) -> UACalcResult<Self> {
        // Validate that universe is contiguous starting from 0
        validate_universe_contiguous(&universe)?;
        
        Ok(Self {
            name,
            universe,
            operations: Vec::new(),
            operation_symbols: HashMap::new(),
            operation_tables_built: false,
        })
    }
    
    /// Add an operation to the algebra
    pub fn add_operation(&mut self, symbol: String, operation: Arc<dyn Operation>) -> UACalcResult<()> {
        // Validate that operation's set size matches algebra's cardinality
        if operation.set_size() != self.cardinality() {
            return Err(UACalcError::InvalidOperation {
                message: format!(
                    "Operation set size {} does not match algebra cardinality {}",
                    operation.set_size(),
                    self.cardinality()
                ),
            });
        }
        
        let index = self.operations.len();
        self.operation_symbols.insert(symbol.clone(), index);
        self.operations.push(operation);
        
        // Reset table building status since we added a new operation
        self.operation_tables_built = false;
        
        Ok(())
    }
    
    /// Create an algebra from a universe and operations
    pub fn from_operations(
        name: String,
        universe: Vec<usize>,
        operations: Vec<(String, Arc<dyn Operation>)>,
    ) -> UACalcResult<Self> {
        let mut algebra = Self::new(name, universe)?;
        for (symbol, operation) in operations {
            algebra.add_operation(symbol, operation)?;
        }
        Ok(algebra)
    }
    
    /// Get an operation by index as Arc<dyn Operation>
    pub fn operation_arc(&self, index: usize) -> UACalcResult<Arc<dyn Operation>> {
        self.operations
            .get(index)
            .cloned()
            .ok_or_else(|| UACalcError::IndexOutOfBounds {
                index,
                size: self.operations.len(),
            })
    }
    
    /// Get an operation by symbol as Arc<dyn Operation>
    pub fn operation_arc_by_symbol(&self, symbol: &str) -> UACalcResult<Arc<dyn Operation>> {
        let index = self.operation_symbols.get(symbol)
            .ok_or_else(|| UACalcError::OperationNotFound {
                symbol: symbol.to_string(),
            })?;
        self.operation_arc(*index)
    }
    
    /// Check if operation tables have been built
    pub fn tables_built(&self) -> bool {
        self.operation_tables_built
    }
    
    /// Get operation by index without Arc cloning overhead
    pub fn operation_direct(&self, index: usize) -> UACalcResult<&dyn Operation> {
        self.operations
            .get(index)
            .map(|op| op.as_ref())
            .ok_or_else(|| UACalcError::IndexOutOfBounds {
                index,
                size: self.operations.len(),
            })
    }
    
    /// Check if the algebra is idempotent (all unary operations are idempotent)
    pub fn is_idempotent(&self) -> UACalcResult<bool> {
        for i in 0..self.operations.len() {
            let operation = self.operation_direct(i)?;
            if operation.arity() == 1 && !operation.is_idempotent_on_set(self.cardinality())? {
                return Ok(false);
            }
        }
        Ok(true)
    }
    
    /// Check if the algebra is associative (all binary operations are associative)
    pub fn is_associative(&self) -> UACalcResult<bool> {
        for i in 0..self.operations.len() {
            let operation = self.operation_direct(i)?;
            if operation.arity() == 2 && !operation.is_associative_on_set(self.cardinality())? {
                return Ok(false);
            }
        }
        Ok(true)
    }
    
    /// Check if the algebra is commutative (all binary operations are commutative)
    pub fn is_commutative(&self) -> UACalcResult<bool> {
        for i in 0..self.operations.len() {
            let operation = self.operation_direct(i)?;
            if operation.arity() == 2 && !operation.is_commutative_on_set(self.cardinality())? {
                return Ok(false);
            }
        }
        Ok(true)
    }
}

impl Algebra for BasicAlgebra {
    fn universe(&self) -> &[usize] {
        &self.universe
    }
    
    fn cardinality(&self) -> usize {
        self.universe.len()
    }
    
    fn operations(&self) -> &[Arc<dyn Operation>] {
        &self.operations
    }
    
    fn operation(&self, index: usize) -> UACalcResult<&dyn Operation> {
        self.operation_direct(index)
    }
    
    fn operation_by_symbol(&self, symbol: &str) -> UACalcResult<&dyn Operation> {
        let index = self.operation_symbols.get(symbol)
            .ok_or_else(|| UACalcError::OperationNotFound {
                symbol: symbol.to_string(),
            })?;
        self.operation(*index)
    }
    
    fn make_operation_tables(&mut self) -> UACalcResult<()> {
        if self.operation_tables_built {
            return Ok(());
        }
        
        for operation in &mut self.operations {
            // We need to get a mutable reference to the operation
            // This is tricky with Arc<dyn Operation>, so we'll need to rebuild the operations
            // For now, we'll assume operations are already built with tables
            // In a more sophisticated implementation, you might use Arc<Mutex<dyn Operation>>
            // or a different approach to allow mutation
        }
        
        self.operation_tables_built = true;
        Ok(())
    }
    
    fn name(&self) -> &str {
        &self.name
    }
}

impl SmallAlgebra for BasicAlgebra {
    fn max_arity(&self) -> usize {
        self.operations
            .iter()
            .map(|op| op.arity())
            .max()
            .unwrap_or(0)
    }
    
    fn subalgebra(&self, generators: &[usize]) -> UACalcResult<BasicAlgebra> {
        // Validate generators
        for &generator in generators {
            if generator >= self.cardinality() {
                return Err(UACalcError::IndexOutOfBounds {
                    index: generator,
                    size: self.cardinality(),
                });
            }
        }
        
        // Compute closure under all operations
        let mut universe = generators.to_vec();
        universe.sort();
        universe.dedup();
        
        let mut changed = true;
        while changed {
            changed = false;
            let current_universe = universe.clone();
            
            // Apply all operations to all combinations of elements
            for operation in &self.operations {
                let arity = operation.arity();
                if arity == 0 {
                    // Constant operation - add result to universe
                    let result = operation.value(&[])?;
                    if !universe.contains(&result) {
                        universe.push(result);
                        changed = true;
                    }
                } else {
                    // Generate all combinations of arity elements from current universe
                    let mut args = vec![0; arity];
                    let mut indices = vec![0; arity];
                    
                    loop {
                        // Set arguments for current combination
                        for (i, &idx) in indices.iter().enumerate() {
                            if idx >= current_universe.len() {
                                if i == 0 {
                                    // We're done with this operation
                                    break;
                                }
                                // Reset this position and increment the previous one
                                indices[i] = 0;
                                indices[i - 1] += 1;
                                continue;
                            }
                            args[i] = current_universe[idx];
                        }
                        
                        // Check if we're done
                        if indices[0] >= current_universe.len() {
                            break;
                        }
                        
                        // Apply operation
                        let result = operation.value(&args)?;
                        if !universe.contains(&result) {
                            universe.push(result);
                            changed = true;
                        }
                        
                        // Move to next combination
                        indices[arity - 1] += 1;
                    }
                }
            }
        }
        
        // Sort and deduplicate final universe
        universe.sort();
        universe.dedup();
        
        // Create subalgebra
        let mut subalgebra = BasicAlgebra::new(
            format!("{}_sub", self.name),
            universe,
        )?;
        
        // Copy operations (this is simplified - in practice you'd need to clone operations)
        // For now, we'll return an error indicating this needs more sophisticated implementation
        Err(UACalcError::UnsupportedOperation {
            operation: "subalgebra operation copying".to_string(),
        })
    }
}

