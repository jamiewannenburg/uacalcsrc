use std::sync::{Arc, Mutex};
use uacalc_core::algebra::{Algebra, BasicAlgebra, SmallAlgebra};
use uacalc_core::operation::TableOperation;
use uacalc_core::partition::{BasicPartition, Partition};
use uacalc_core::subalgebra::Subalgebra;
use uacalc_core::UACalcResult;

#[test]
fn test_subalgebra_creation_basic() -> UACalcResult<()> {
    // Create a simple algebra Z4 = {0, 1, 2, 3} with addition mod 4
    let mut z4 = BasicAlgebra::with_cardinality("Z4".to_string(), 4)?;
    let add_op = Arc::new(Mutex::new(TableOperation::binary(
        "add".to_string(),
        4,
        |a, b| (a + b) % 4,
    )?));
    z4.add_operation("add".to_string(), add_op)?;

    let z4_arc = Arc::new(Mutex::new(z4));

    // Create subalgebra generated by {1}
    let subalgebra = Subalgebra::new("Z4_sub".to_string(), z4_arc, &[1])?;

    // Test basic properties
    assert_eq!(subalgebra.name(), "Z4_sub");
    assert_eq!(subalgebra.cardinality(), 4); // Should generate the full algebra
    assert_eq!(subalgebra.universe(), &[0, 1, 2, 3]);
    assert_eq!(subalgebra.operations().len(), 1);

    Ok(())
}

#[test]
fn test_subalgebra_single_element() -> UACalcResult<()> {
    // Create algebra with unary identity operation
    let mut algebra = BasicAlgebra::with_cardinality("test".to_string(), 3)?;
    let id_op = Arc::new(Mutex::new(TableOperation::unary(
        "id".to_string(),
        3,
        |x| x,
    )?));
    algebra.add_operation("id".to_string(), id_op)?;

    let algebra_arc = Arc::new(Mutex::new(algebra));

    // Create subalgebra generated by {0}
    let subalgebra = Subalgebra::new("test_sub".to_string(), algebra_arc, &[0])?;

    // Should only contain {0} since id(0) = 0
    assert_eq!(subalgebra.cardinality(), 1);
    assert_eq!(subalgebra.universe(), &[0]);

    // Test element mapping
    assert_eq!(subalgebra.index_in_subalgebra(0), Some(0));
    assert_eq!(subalgebra.index_in_subalgebra(1), None);
    assert_eq!(subalgebra.index_in_subalgebra(2), None);

    assert_eq!(subalgebra.element_in_parent(0)?, 0);

    Ok(())
}

#[test]
fn test_subalgebra_operation_evaluation() -> UACalcResult<()> {
    // Create Z4 with addition
    let mut z4 = BasicAlgebra::with_cardinality("Z4".to_string(), 4)?;
    let add_op = Arc::new(Mutex::new(TableOperation::binary(
        "add".to_string(),
        4,
        |a, b| (a + b) % 4,
    )?));
    z4.add_operation("add".to_string(), add_op)?;

    let z4_arc = Arc::new(Mutex::new(z4));

    // Create subalgebra generated by {1}
    let subalgebra = Subalgebra::new("Z4_sub".to_string(), z4_arc, &[1])?;

    // Test operation evaluation
    let add_subalgebra = subalgebra.operation_arc_by_symbol("add")?;
    let add_guard = add_subalgebra.lock().unwrap();

    // Test addition in subalgebra (should match Z4 addition)
    assert_eq!(add_guard.value(&[1, 2])?, 3); // 1 + 2 = 3 in Z4
    assert_eq!(add_guard.value(&[2, 3])?, 1); // 2 + 3 = 1 in Z4
    assert_eq!(add_guard.value(&[3, 1])?, 0); // 3 + 1 = 0 in Z4
    assert_eq!(add_guard.value(&[0, 0])?, 0); // 0 + 0 = 0 in Z4

    Ok(())
}

#[test]
fn test_subalgebra_with_multiple_operations() -> UACalcResult<()> {
    // Create algebra with addition and multiplication mod 4
    let mut z4 = BasicAlgebra::with_cardinality("Z4".to_string(), 4)?;

    let add_op = Arc::new(Mutex::new(TableOperation::binary(
        "add".to_string(),
        4,
        |a, b| (a + b) % 4,
    )?));
    let mul_op = Arc::new(Mutex::new(TableOperation::binary(
        "mul".to_string(),
        4,
        |a, b| (a * b) % 4,
    )?));

    z4.add_operation("add".to_string(), add_op)?;
    z4.add_operation("mul".to_string(), mul_op)?;

    let z4_arc = Arc::new(Mutex::new(z4));

    // Create subalgebra generated by {1}
    let subalgebra = Subalgebra::new("Z4_sub".to_string(), z4_arc, &[1])?;

    // Test both operations
    let add_sub = subalgebra.operation_arc_by_symbol("add")?;
    let mul_sub = subalgebra.operation_arc_by_symbol("mul")?;

    let add_guard = add_sub.lock().unwrap();
    let mul_guard = mul_sub.lock().unwrap();

    // Test addition
    assert_eq!(add_guard.value(&[1, 1])?, 2);
    assert_eq!(add_guard.value(&[2, 2])?, 0);

    // Test multiplication
    assert_eq!(mul_guard.value(&[1, 1])?, 1);
    assert_eq!(mul_guard.value(&[2, 2])?, 0);
    assert_eq!(mul_guard.value(&[1, 3])?, 3);

    Ok(())
}

#[test]
fn test_subalgebra_partial_closure() -> UACalcResult<()> {
    // Create algebra where not all elements are reachable
    let mut algebra = BasicAlgebra::with_cardinality("test".to_string(), 4)?;

    // Create operation that maps: 0->0, 1->2, 2->1, 3->3
    let permute_op = Arc::new(Mutex::new(TableOperation::unary(
        "permute".to_string(),
        4,
        |x| match x {
            0 => 0,
            1 => 2,
            2 => 1,
            3 => 3,
            _ => 0,
        },
    )?));
    algebra.add_operation("permute".to_string(), permute_op)?;

    let algebra_arc = Arc::new(Mutex::new(algebra));

    // Generate subalgebra from {1}
    let subalgebra = Subalgebra::new("test_sub".to_string(), algebra_arc, &[1])?;

    // Should contain {1, 2} since permute(1) = 2 and permute(2) = 1
    assert_eq!(subalgebra.cardinality(), 2);

    // Test element mapping
    let sub_array = subalgebra.subuniverse_array();
    assert!(sub_array.contains(&1));
    assert!(sub_array.contains(&2));
    assert!(!sub_array.contains(&0));
    assert!(!sub_array.contains(&3));

    Ok(())
}

#[test]
fn test_subalgebra_with_constants() -> UACalcResult<()> {
    // Create algebra with a constant operation
    let mut algebra = BasicAlgebra::with_cardinality("test".to_string(), 3)?;

    let const_op = Arc::new(Mutex::new(TableOperation::constant(
        "zero".to_string(),
        0,
        3,
    )?));
    let id_op = Arc::new(Mutex::new(TableOperation::unary(
        "id".to_string(),
        3,
        |x| x,
    )?));

    algebra.add_operation("zero".to_string(), const_op)?;
    algebra.add_operation("id".to_string(), id_op)?;

    let algebra_arc = Arc::new(Mutex::new(algebra));

    // Generate subalgebra from {1}
    let subalgebra = Subalgebra::new("test_sub".to_string(), algebra_arc, &[1])?;

    // Should contain {0, 1} because of the constant operation
    assert_eq!(subalgebra.cardinality(), 2);

    // Test constant operation
    let zero_op = subalgebra.operation_arc_by_symbol("zero")?;
    let zero_guard = zero_op.lock().unwrap();
    assert_eq!(zero_guard.value(&[])?, 0); // Should map parent 0 to subalgebra index 0

    Ok(())
}

#[test]
fn test_subalgebra_error_cases() -> UACalcResult<()> {
    let mut algebra = BasicAlgebra::with_cardinality("test".to_string(), 3)?;
    let op = Arc::new(Mutex::new(TableOperation::unary(
        "id".to_string(),
        3,
        |x| x,
    )?));
    algebra.add_operation("id".to_string(), op)?;

    let algebra_arc = Arc::new(Mutex::new(algebra));

    // Test empty generators
    let result = Subalgebra::new("test_sub".to_string(), algebra_arc.clone(), &[]);
    assert!(result.is_err());

    // Test invalid generator index
    let result = Subalgebra::new("test_sub".to_string(), algebra_arc.clone(), &[5]);
    assert!(result.is_err());

    // Test out of bounds in element_in_parent
    let subalgebra = Subalgebra::new("test_sub".to_string(), algebra_arc, &[0])?;
    let result = subalgebra.element_in_parent(5);
    assert!(result.is_err());

    Ok(())
}

#[test]
fn test_subalgebra_restrict_partition() -> UACalcResult<()> {
    // Create algebra
    let mut algebra = BasicAlgebra::with_cardinality("test".to_string(), 6)?;
    let id_op = Arc::new(Mutex::new(TableOperation::unary(
        "id".to_string(),
        6,
        |x| x,
    )?));
    algebra.add_operation("id".to_string(), id_op)?;

    let algebra_arc = Arc::new(Mutex::new(algebra));

    // Create subalgebra containing elements {0, 2, 4}
    let subalgebra = Subalgebra::new("test_sub".to_string(), algebra_arc, &[0, 2, 4])?;
    assert_eq!(subalgebra.cardinality(), 3);

    // Create partition on parent algebra: {0,1}, {2,3}, {4,5}
    let parent_partition =
        BasicPartition::from_blocks(6, vec![vec![0, 1], vec![2, 3], vec![4, 5]])?;

    // Restrict partition to subalgebra
    let restricted = subalgebra.restrict_partition(&parent_partition)?;

    // Should have 3 singleton blocks since 0, 2, 4 are in different parent blocks
    assert_eq!(restricted.num_blocks(), 3);

    // Elements should not be in the same block
    assert!(!restricted.same_block(0, 1)?); // 0 and 2 in subalgebra indices
    assert!(!restricted.same_block(0, 2)?); // 0 and 4 in subalgebra indices
    assert!(!restricted.same_block(1, 2)?); // 2 and 4 in subalgebra indices

    Ok(())
}

#[test]
fn test_subalgebra_nested() -> UACalcResult<()> {
    // Create Z4 with addition
    let mut z4 = BasicAlgebra::with_cardinality("Z4".to_string(), 4)?;
    let add_op = Arc::new(Mutex::new(TableOperation::binary(
        "add".to_string(),
        4,
        |a, b| (a + b) % 4,
    )?));
    z4.add_operation("add".to_string(), add_op)?;

    let z4_arc = Arc::new(Mutex::new(z4));

    // Create subalgebra generated by {1} (should be all of Z4)
    let full_sub = Subalgebra::new("Z4_full_sub".to_string(), z4_arc, &[1])?;
    assert_eq!(full_sub.cardinality(), 4);

    // Create subalgebra of the subalgebra generated by {0} (in subalgebra indices)
    let nested_sub = full_sub.subalgebra(&[0])?; // 0 in subalgebra maps to 0 in parent
    assert_eq!(nested_sub.cardinality(), 1);
    assert_eq!(nested_sub.universe(), &[0]);

    Ok(())
}

#[test]
fn test_subalgebra_index_mapping() -> UACalcResult<()> {
    // Create algebra
    let mut algebra = BasicAlgebra::with_cardinality("test".to_string(), 5)?;
    let id_op = Arc::new(Mutex::new(TableOperation::unary(
        "id".to_string(),
        5,
        |x| x,
    )?));
    algebra.add_operation("id".to_string(), id_op)?;

    let algebra_arc = Arc::new(Mutex::new(algebra));

    // Create subalgebra with elements {1, 3, 4}
    let subalgebra = Subalgebra::new("test_sub".to_string(), algebra_arc, &[1, 3, 4])?;

    // Test index mapping
    assert_eq!(subalgebra.index_in_subalgebra(0), None);
    assert_eq!(subalgebra.index_in_subalgebra(1), Some(0));
    assert_eq!(subalgebra.index_in_subalgebra(2), None);
    assert_eq!(subalgebra.index_in_subalgebra(3), Some(1));
    assert_eq!(subalgebra.index_in_subalgebra(4), Some(2));

    // Test reverse mapping
    assert_eq!(subalgebra.element_in_parent(0)?, 1);
    assert_eq!(subalgebra.element_in_parent(1)?, 3);
    assert_eq!(subalgebra.element_in_parent(2)?, 4);

    // Test subuniverse array
    let sub_array = subalgebra.subuniverse_array();
    assert_eq!(sub_array, &[1, 3, 4]);

    Ok(())
}

#[test]
fn test_subalgebra_debug_hang() -> UACalcResult<()> {
    println!("Creating algebra...");
    // Create simple algebra
    let mut algebra = BasicAlgebra::with_cardinality("test".to_string(), 3)?;
    let id_op = Arc::new(Mutex::new(TableOperation::unary(
        "id".to_string(),
        3,
        |x| x,
    )?));
    algebra.add_operation("id".to_string(), id_op)?;

    let algebra_arc = Arc::new(Mutex::new(algebra));
    println!("Creating subalgebra...");
    let subalgebra = Subalgebra::new("test_sub".to_string(), algebra_arc, &[0, 1])?;
    println!("Subalgebra created successfully");

    // Test Algebra trait methods
    println!("Testing basic methods...");
    assert_eq!(subalgebra.universe(), &[0, 1]);
    assert_eq!(subalgebra.cardinality(), 2);
    assert_eq!(subalgebra.operations().len(), 1);
    assert!(subalgebra.is_finite());

    println!("Testing operation access...");
    // Test operation access - this might be where it hangs
    let op = subalgebra.operation_arc(0)?;
    println!("Got operation arc, trying to lock...");
    let op_guard = op.lock().unwrap();
    println!("Locked operation successfully");
    assert_eq!(op_guard.arity(), 1);
    drop(op_guard);

    println!("Testing operation by symbol...");
    // Test operation by symbol
    let op_by_symbol = subalgebra.operation_arc_by_symbol("id")?;
    println!("Got operation by symbol, trying to lock...");
    let op_by_symbol_guard = op_by_symbol.lock().unwrap();
    println!("Locked operation by symbol successfully");
    assert_eq!(op_by_symbol_guard.arity(), 1);

    println!("Test completed successfully");
    Ok(())
}

#[test]
fn test_subalgebra_algebra_trait_methods() -> UACalcResult<()> {
    // Create simple algebra
    let mut algebra = BasicAlgebra::with_cardinality("test".to_string(), 3)?;
    let id_op = Arc::new(Mutex::new(TableOperation::unary(
        "id".to_string(),
        3,
        |x| x,
    )?));
    algebra.add_operation("id".to_string(), id_op)?;

    let algebra_arc = Arc::new(Mutex::new(algebra));
    let subalgebra = Subalgebra::new("test_sub".to_string(), algebra_arc, &[0, 1])?;

    // Test Algebra trait methods
    assert_eq!(subalgebra.universe(), &[0, 1]);
    assert_eq!(subalgebra.cardinality(), 2);
    assert_eq!(subalgebra.operations().len(), 1);
    assert!(subalgebra.is_finite());

    // Test operation access
    {
        let op = subalgebra.operation_arc(0)?;
        let op_guard = op.lock().unwrap();
        assert_eq!(op_guard.arity(), 1);
        // Lock is dropped here at end of scope
    }

    // Test operation by symbol
    {
        let op_by_symbol = subalgebra.operation_arc_by_symbol("id")?;
        let op_by_symbol_guard = op_by_symbol.lock().unwrap();
        assert_eq!(op_by_symbol_guard.arity(), 1);
        // Lock is dropped here at end of scope
    }

    Ok(())
}

#[test]
fn test_subalgebra_small_algebra_trait() -> UACalcResult<()> {
    // Create algebra with binary operation
    let mut algebra = BasicAlgebra::with_cardinality("test".to_string(), 3)?;
    let add_op = Arc::new(Mutex::new(TableOperation::binary(
        "add".to_string(),
        3,
        |a, b| (a + b) % 3,
    )?));
    algebra.add_operation("add".to_string(), add_op)?;

    let algebra_arc = Arc::new(Mutex::new(algebra));
    let subalgebra = Subalgebra::new("test_sub".to_string(), algebra_arc, &[1])?;

    // Test SmallAlgebra trait methods
    assert_eq!(subalgebra.max_arity(), 2);

    // Test operation_int_value
    let result = subalgebra.operation_int_value(0, &[1, 2])?;
    assert_eq!(result, 0); // (1 + 2) % 3 = 0 in parent, which maps to some subalgebra index

    // Test subalgebra method (nested subalgebra)
    let nested = subalgebra.subalgebra(&[0])?;
    assert_eq!(nested.cardinality(), 1);

    Ok(())
}
